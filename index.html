<!doctype html>
<html lang="ru">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Breaking Bad Chemistry Lab</title>
    <meta
      name="description"
      content="Say my name. Интерактивная химическая лаборатория в стиле Breaking Bad"
    />
    <meta name="author" content="Heisenberg Labs" />

    <meta property="og:title" content="Breaking Bad Chemistry Lab" />
    <meta
      property="og:description"
      content="I am the one who knocks. Изучай химию как Хайзенберг!"
    />
    <meta property="og:type" content="website" />
    <meta
      property="og:image"
      content="https://kroch228.github.io/chimia-coloring/images/raketa.png"
    />

    <meta name="twitter:card" content="summary_large_image" />
    <meta
      name="twitter:image"
      content="https://kroch228.github.io/chimia-coloring/images/raketa.png"
    />
    <script type="module" crossorigin>
      function _mergeNamespaces(n, m) {
        for (var i = 0; i < m.length; i++) {
          const e = m[i];
          if (typeof e !== "string" && !Array.isArray(e)) {
            for (const k in e) {
              if (k !== "default" && !(k in n)) {
                const d = Object.getOwnPropertyDescriptor(e, k);
                if (d) {
                  Object.defineProperty(
                    n,
                    k,
                    d.get
                      ? d
                      : {
                          enumerable: true,
                          get: () => e[k],
                        },
                  );
                }
              }
            }
          }
        }
        return Object.freeze(
          Object.defineProperty(n, Symbol.toStringTag, { value: "Module" }),
        );
      }

      true &&
        (function polyfill() {
          const relList = document.createElement("link").relList;
          if (
            relList &&
            relList.supports &&
            relList.supports("modulepreload")
          ) {
            return;
          }
          for (const link of document.querySelectorAll(
            'link[rel="modulepreload"]',
          )) {
            processPreload(link);
          }
          new MutationObserver((mutations) => {
            for (const mutation of mutations) {
              if (mutation.type !== "childList") {
                continue;
              }
              for (const node of mutation.addedNodes) {
                if (node.tagName === "LINK" && node.rel === "modulepreload")
                  processPreload(node);
              }
            }
          }).observe(document, { childList: true, subtree: true });
          function getFetchOpts(link) {
            const fetchOpts = {};
            if (link.integrity) fetchOpts.integrity = link.integrity;
            if (link.referrerPolicy)
              fetchOpts.referrerPolicy = link.referrerPolicy;
            if (link.crossOrigin === "use-credentials")
              fetchOpts.credentials = "include";
            else if (link.crossOrigin === "anonymous")
              fetchOpts.credentials = "omit";
            else fetchOpts.credentials = "same-origin";
            return fetchOpts;
          }
          function processPreload(link) {
            if (link.ep) return;
            link.ep = true;
            const fetchOpts = getFetchOpts(link);
            fetch(link.href, fetchOpts);
          }
        })();

      function getDefaultExportFromCjs(x) {
        return x &&
          x.__esModule &&
          Object.prototype.hasOwnProperty.call(x, "default")
          ? x["default"]
          : x;
      }

      var jsxRuntime = { exports: {} };

      var reactJsxRuntime_production_min = {};

      var react = { exports: {} };

      var react_production_min = {};

      var l$1 = Symbol.for("react.element"),
        n$1 = Symbol.for("react.portal"),
        p$2 = Symbol.for("react.fragment"),
        q$1 = Symbol.for("react.strict_mode"),
        r$1 = Symbol.for("react.profiler"),
        t = Symbol.for("react.provider"),
        u = Symbol.for("react.context"),
        v$2 = Symbol.for("react.forward_ref"),
        w = Symbol.for("react.suspense"),
        x = Symbol.for("react.memo"),
        y = Symbol.for("react.lazy"),
        z$1 = Symbol.iterator;
      function A$1(a) {
        if (null === a || "object" !== typeof a) return null;
        a = (z$1 && a[z$1]) || a["@@iterator"];
        return "function" === typeof a ? a : null;
      }
      var B$1 = {
          isMounted: function () {
            return false;
          },
          enqueueForceUpdate: function () {},
          enqueueReplaceState: function () {},
          enqueueSetState: function () {},
        },
        C$1 = Object.assign,
        D$2 = {};
      function E$2(a, b, e) {
        this.props = a;
        this.context = b;
        this.refs = D$2;
        this.updater = e || B$1;
      }
      E$2.prototype.isReactComponent = {};
      E$2.prototype.setState = function (a, b) {
        if ("object" !== typeof a && "function" !== typeof a && null != a)
          throw Error(
            "setState(...): takes an object of state variables to update or a function which returns an object of state variables.",
          );
        this.updater.enqueueSetState(this, a, b, "setState");
      };
      E$2.prototype.forceUpdate = function (a) {
        this.updater.enqueueForceUpdate(this, a, "forceUpdate");
      };
      function F() {}
      F.prototype = E$2.prototype;
      function G$1(a, b, e) {
        this.props = a;
        this.context = b;
        this.refs = D$2;
        this.updater = e || B$1;
      }
      var H$1 = (G$1.prototype = new F());
      H$1.constructor = G$1;
      C$1(H$1, E$2.prototype);
      H$1.isPureReactComponent = true;
      var I$1 = Array.isArray,
        J = Object.prototype.hasOwnProperty,
        K$1 = { current: null },
        L$2 = { key: true, ref: true, __self: true, __source: true };
      function M$2(a, b, e) {
        var d,
          c = {},
          k = null,
          h = null;
        if (null != b)
          for (d in (void 0 !== b.ref && (h = b.ref),
          void 0 !== b.key && (k = "" + b.key),
          b))
            J.call(b, d) && !L$2.hasOwnProperty(d) && (c[d] = b[d]);
        var g = arguments.length - 2;
        if (1 === g) c.children = e;
        else if (1 < g) {
          for (var f = Array(g), m = 0; m < g; m++) f[m] = arguments[m + 2];
          c.children = f;
        }
        if (a && a.defaultProps)
          for (d in ((g = a.defaultProps), g)) void 0 === c[d] && (c[d] = g[d]);
        return {
          $$typeof: l$1,
          type: a,
          key: k,
          ref: h,
          props: c,
          _owner: K$1.current,
        };
      }
      function N$1(a, b) {
        return {
          $$typeof: l$1,
          type: a.type,
          key: b,
          ref: a.ref,
          props: a.props,
          _owner: a._owner,
        };
      }
      function O$1(a) {
        return "object" === typeof a && null !== a && a.$$typeof === l$1;
      }
      function escape(a) {
        var b = { "=": "=0", ":": "=2" };
        return (
          "$" +
          a.replace(/[=:]/g, function (a) {
            return b[a];
          })
        );
      }
      var P$2 = /\/+/g;
      function Q$1(a, b) {
        return "object" === typeof a && null !== a && null != a.key
          ? escape("" + a.key)
          : b.toString(36);
      }
      function R$1(a, b, e, d, c) {
        var k = typeof a;
        if ("undefined" === k || "boolean" === k) a = null;
        var h = false;
        if (null === a) h = true;
        else
          switch (k) {
            case "string":
            case "number":
              h = true;
              break;
            case "object":
              switch (a.$$typeof) {
                case l$1:
                case n$1:
                  h = true;
              }
          }
        if (h)
          return (
            (h = a),
            (c = c(h)),
            (a = "" === d ? "." + Q$1(h, 0) : d),
            I$1(c)
              ? ((e = ""),
                null != a && (e = a.replace(P$2, "$&/") + "/"),
                R$1(c, b, e, "", function (a) {
                  return a;
                }))
              : null != c &&
                (O$1(c) &&
                  (c = N$1(
                    c,
                    e +
                      (!c.key || (h && h.key === c.key)
                        ? ""
                        : ("" + c.key).replace(P$2, "$&/") + "/") +
                      a,
                  )),
                b.push(c)),
            1
          );
        h = 0;
        d = "" === d ? "." : d + ":";
        if (I$1(a))
          for (var g = 0; g < a.length; g++) {
            k = a[g];
            var f = d + Q$1(k, g);
            h += R$1(k, b, e, f, c);
          }
        else if (((f = A$1(a)), "function" === typeof f))
          for (a = f.call(a), g = 0; !(k = a.next()).done; )
            ((k = k.value), (f = d + Q$1(k, g++)), (h += R$1(k, b, e, f, c)));
        else if ("object" === k)
          throw (
            (b = String(a)),
            Error(
              "Objects are not valid as a React child (found: " +
                ("[object Object]" === b
                  ? "object with keys {" + Object.keys(a).join(", ") + "}"
                  : b) +
                "). If you meant to render a collection of children, use an array instead.",
            )
          );
        return h;
      }
      function S$1(a, b, e) {
        if (null == a) return a;
        var d = [],
          c = 0;
        R$1(a, d, "", "", function (a) {
          return b.call(e, a, c++);
        });
        return d;
      }
      function T$1(a) {
        if (-1 === a._status) {
          var b = a._result;
          b = b();
          b.then(
            function (b) {
              if (0 === a._status || -1 === a._status)
                ((a._status = 1), (a._result = b));
            },
            function (b) {
              if (0 === a._status || -1 === a._status)
                ((a._status = 2), (a._result = b));
            },
          );
          -1 === a._status && ((a._status = 0), (a._result = b));
        }
        if (1 === a._status) return a._result.default;
        throw a._result;
      }
      var U$1 = { current: null },
        V$1 = { transition: null },
        W$1 = {
          ReactCurrentDispatcher: U$1,
          ReactCurrentBatchConfig: V$1,
          ReactCurrentOwner: K$1,
        };
      function X$2() {
        throw Error("act(...) is not supported in production builds of React.");
      }
      react_production_min.Children = {
        map: S$1,
        forEach: function (a, b, e) {
          S$1(
            a,
            function () {
              b.apply(this, arguments);
            },
            e,
          );
        },
        count: function (a) {
          var b = 0;
          S$1(a, function () {
            b++;
          });
          return b;
        },
        toArray: function (a) {
          return (
            S$1(a, function (a) {
              return a;
            }) || []
          );
        },
        only: function (a) {
          if (!O$1(a))
            throw Error(
              "React.Children.only expected to receive a single React element child.",
            );
          return a;
        },
      };
      react_production_min.Component = E$2;
      react_production_min.Fragment = p$2;
      react_production_min.Profiler = r$1;
      react_production_min.PureComponent = G$1;
      react_production_min.StrictMode = q$1;
      react_production_min.Suspense = w;
      react_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED =
        W$1;
      react_production_min.act = X$2;
      react_production_min.cloneElement = function (a, b, e) {
        if (null === a || void 0 === a)
          throw Error(
            "React.cloneElement(...): The argument must be a React element, but you passed " +
              a +
              ".",
          );
        var d = C$1({}, a.props),
          c = a.key,
          k = a.ref,
          h = a._owner;
        if (null != b) {
          void 0 !== b.ref && ((k = b.ref), (h = K$1.current));
          void 0 !== b.key && (c = "" + b.key);
          if (a.type && a.type.defaultProps) var g = a.type.defaultProps;
          for (f in b)
            J.call(b, f) &&
              !L$2.hasOwnProperty(f) &&
              (d[f] = void 0 === b[f] && void 0 !== g ? g[f] : b[f]);
        }
        var f = arguments.length - 2;
        if (1 === f) d.children = e;
        else if (1 < f) {
          g = Array(f);
          for (var m = 0; m < f; m++) g[m] = arguments[m + 2];
          d.children = g;
        }
        return {
          $$typeof: l$1,
          type: a.type,
          key: c,
          ref: k,
          props: d,
          _owner: h,
        };
      };
      react_production_min.createContext = function (a) {
        a = {
          $$typeof: u,
          _currentValue: a,
          _currentValue2: a,
          _threadCount: 0,
          Provider: null,
          Consumer: null,
          _defaultValue: null,
          _globalName: null,
        };
        a.Provider = { $$typeof: t, _context: a };
        return (a.Consumer = a);
      };
      react_production_min.createElement = M$2;
      react_production_min.createFactory = function (a) {
        var b = M$2.bind(null, a);
        b.type = a;
        return b;
      };
      react_production_min.createRef = function () {
        return { current: null };
      };
      react_production_min.forwardRef = function (a) {
        return { $$typeof: v$2, render: a };
      };
      react_production_min.isValidElement = O$1;
      react_production_min.lazy = function (a) {
        return {
          $$typeof: y,
          _payload: { _status: -1, _result: a },
          _init: T$1,
        };
      };
      react_production_min.memo = function (a, b) {
        return { $$typeof: x, type: a, compare: void 0 === b ? null : b };
      };
      react_production_min.startTransition = function (a) {
        var b = V$1.transition;
        V$1.transition = {};
        try {
          a();
        } finally {
          V$1.transition = b;
        }
      };
      react_production_min.unstable_act = X$2;
      react_production_min.useCallback = function (a, b) {
        return U$1.current.useCallback(a, b);
      };
      react_production_min.useContext = function (a) {
        return U$1.current.useContext(a);
      };
      react_production_min.useDebugValue = function () {};
      react_production_min.useDeferredValue = function (a) {
        return U$1.current.useDeferredValue(a);
      };
      react_production_min.useEffect = function (a, b) {
        return U$1.current.useEffect(a, b);
      };
      react_production_min.useId = function () {
        return U$1.current.useId();
      };
      react_production_min.useImperativeHandle = function (a, b, e) {
        return U$1.current.useImperativeHandle(a, b, e);
      };
      react_production_min.useInsertionEffect = function (a, b) {
        return U$1.current.useInsertionEffect(a, b);
      };
      react_production_min.useLayoutEffect = function (a, b) {
        return U$1.current.useLayoutEffect(a, b);
      };
      react_production_min.useMemo = function (a, b) {
        return U$1.current.useMemo(a, b);
      };
      react_production_min.useReducer = function (a, b, e) {
        return U$1.current.useReducer(a, b, e);
      };
      react_production_min.useRef = function (a) {
        return U$1.current.useRef(a);
      };
      react_production_min.useState = function (a) {
        return U$1.current.useState(a);
      };
      react_production_min.useSyncExternalStore = function (a, b, e) {
        return U$1.current.useSyncExternalStore(a, b, e);
      };
      react_production_min.useTransition = function () {
        return U$1.current.useTransition();
      };
      react_production_min.version = "18.3.1";

      {
        react.exports = react_production_min;
      }

      var reactExports = react.exports;
      const React = /*@__PURE__*/ getDefaultExportFromCjs(reactExports);

      const React$1 = /*#__PURE__*/ _mergeNamespaces(
        {
          __proto__: null,
          default: React,
        },
        [reactExports],
      );

      var f = reactExports,
        k = Symbol.for("react.element"),
        l = Symbol.for("react.fragment"),
        m$1 = Object.prototype.hasOwnProperty,
        n =
          f.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED
            .ReactCurrentOwner,
        p$1 = { key: true, ref: true, __self: true, __source: true };
      function q(c, a, g) {
        var b,
          d = {},
          e = null,
          h = null;
        void 0 !== g && (e = "" + g);
        void 0 !== a.key && (e = "" + a.key);
        void 0 !== a.ref && (h = a.ref);
        for (b in a) m$1.call(a, b) && !p$1.hasOwnProperty(b) && (d[b] = a[b]);
        if (c && c.defaultProps)
          for (b in ((a = c.defaultProps), a)) void 0 === d[b] && (d[b] = a[b]);
        return {
          $$typeof: k,
          type: c,
          key: e,
          ref: h,
          props: d,
          _owner: n.current,
        };
      }
      reactJsxRuntime_production_min.Fragment = l;
      reactJsxRuntime_production_min.jsx = q;
      reactJsxRuntime_production_min.jsxs = q;

      {
        jsxRuntime.exports = reactJsxRuntime_production_min;
      }

      var jsxRuntimeExports = jsxRuntime.exports;

      var reactDom = { exports: {} };

      var reactDom_production_min = {};

      var scheduler = { exports: {} };

      var scheduler_production_min = {};

      (function (exports$1) {
        function f(a, b) {
          var c = a.length;
          a.push(b);
          a: for (; 0 < c; ) {
            var d = (c - 1) >>> 1,
              e = a[d];
            if (0 < g(e, b)) ((a[d] = b), (a[c] = e), (c = d));
            else break a;
          }
        }
        function h(a) {
          return 0 === a.length ? null : a[0];
        }
        function k(a) {
          if (0 === a.length) return null;
          var b = a[0],
            c = a.pop();
          if (c !== b) {
            a[0] = c;
            a: for (var d = 0, e = a.length, w = e >>> 1; d < w; ) {
              var m = 2 * (d + 1) - 1,
                C = a[m],
                n = m + 1,
                x = a[n];
              if (0 > g(C, c))
                n < e && 0 > g(x, C)
                  ? ((a[d] = x), (a[n] = c), (d = n))
                  : ((a[d] = C), (a[m] = c), (d = m));
              else if (n < e && 0 > g(x, c)) ((a[d] = x), (a[n] = c), (d = n));
              else break a;
            }
          }
          return b;
        }
        function g(a, b) {
          var c = a.sortIndex - b.sortIndex;
          return 0 !== c ? c : a.id - b.id;
        }
        if (
          "object" === typeof performance &&
          "function" === typeof performance.now
        ) {
          var l = performance;
          exports$1.unstable_now = function () {
            return l.now();
          };
        } else {
          var p = Date,
            q = p.now();
          exports$1.unstable_now = function () {
            return p.now() - q;
          };
        }
        var r = [],
          t = [],
          u = 1,
          v = null,
          y = 3,
          z = false,
          A = false,
          B = false,
          D = "function" === typeof setTimeout ? setTimeout : null,
          E = "function" === typeof clearTimeout ? clearTimeout : null,
          F = "undefined" !== typeof setImmediate ? setImmediate : null;
        "undefined" !== typeof navigator &&
          void 0 !== navigator.scheduling &&
          void 0 !== navigator.scheduling.isInputPending &&
          navigator.scheduling.isInputPending.bind(navigator.scheduling);
        function G(a) {
          for (var b = h(t); null !== b; ) {
            if (null === b.callback) k(t);
            else if (b.startTime <= a)
              (k(t), (b.sortIndex = b.expirationTime), f(r, b));
            else break;
            b = h(t);
          }
        }
        function H(a) {
          B = false;
          G(a);
          if (!A)
            if (null !== h(r)) ((A = true), I(J));
            else {
              var b = h(t);
              null !== b && K(H, b.startTime - a);
            }
        }
        function J(a, b) {
          A = false;
          B && ((B = false), E(L), (L = -1));
          z = true;
          var c = y;
          try {
            G(b);
            for (
              v = h(r);
              null !== v && (!(v.expirationTime > b) || (a && !M()));
            ) {
              var d = v.callback;
              if ("function" === typeof d) {
                v.callback = null;
                y = v.priorityLevel;
                var e = d(v.expirationTime <= b);
                b = exports$1.unstable_now();
                "function" === typeof e ? (v.callback = e) : v === h(r) && k(r);
                G(b);
              } else k(r);
              v = h(r);
            }
            if (null !== v) var w = !0;
            else {
              var m = h(t);
              null !== m && K(H, m.startTime - b);
              w = !1;
            }
            return w;
          } finally {
            ((v = null), (y = c), (z = false));
          }
        }
        var N = false,
          O = null,
          L = -1,
          P = 5,
          Q = -1;
        function M() {
          return exports$1.unstable_now() - Q < P ? false : true;
        }
        function R() {
          if (null !== O) {
            var a = exports$1.unstable_now();
            Q = a;
            var b = true;
            try {
              b = O(!0, a);
            } finally {
              b ? S() : ((N = false), (O = null));
            }
          } else N = false;
        }
        var S;
        if ("function" === typeof F)
          S = function () {
            F(R);
          };
        else if ("undefined" !== typeof MessageChannel) {
          var T = new MessageChannel(),
            U = T.port2;
          T.port1.onmessage = R;
          S = function () {
            U.postMessage(null);
          };
        } else
          S = function () {
            D(R, 0);
          };
        function I(a) {
          O = a;
          N || ((N = true), S());
        }
        function K(a, b) {
          L = D(function () {
            a(exports$1.unstable_now());
          }, b);
        }
        exports$1.unstable_IdlePriority = 5;
        exports$1.unstable_ImmediatePriority = 1;
        exports$1.unstable_LowPriority = 4;
        exports$1.unstable_NormalPriority = 3;
        exports$1.unstable_Profiling = null;
        exports$1.unstable_UserBlockingPriority = 2;
        exports$1.unstable_cancelCallback = function (a) {
          a.callback = null;
        };
        exports$1.unstable_continueExecution = function () {
          A || z || ((A = true), I(J));
        };
        exports$1.unstable_forceFrameRate = function (a) {
          0 > a || 125 < a
            ? console.error(
                "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported",
              )
            : (P = 0 < a ? Math.floor(1e3 / a) : 5);
        };
        exports$1.unstable_getCurrentPriorityLevel = function () {
          return y;
        };
        exports$1.unstable_getFirstCallbackNode = function () {
          return h(r);
        };
        exports$1.unstable_next = function (a) {
          switch (y) {
            case 1:
            case 2:
            case 3:
              var b = 3;
              break;
            default:
              b = y;
          }
          var c = y;
          y = b;
          try {
            return a();
          } finally {
            y = c;
          }
        };
        exports$1.unstable_pauseExecution = function () {};
        exports$1.unstable_requestPaint = function () {};
        exports$1.unstable_runWithPriority = function (a, b) {
          switch (a) {
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
              break;
            default:
              a = 3;
          }
          var c = y;
          y = a;
          try {
            return b();
          } finally {
            y = c;
          }
        };
        exports$1.unstable_scheduleCallback = function (a, b, c) {
          var d = exports$1.unstable_now();
          "object" === typeof c && null !== c
            ? ((c = c.delay), (c = "number" === typeof c && 0 < c ? d + c : d))
            : (c = d);
          switch (a) {
            case 1:
              var e = -1;
              break;
            case 2:
              e = 250;
              break;
            case 5:
              e = 1073741823;
              break;
            case 4:
              e = 1e4;
              break;
            default:
              e = 5e3;
          }
          e = c + e;
          a = {
            id: u++,
            callback: b,
            priorityLevel: a,
            startTime: c,
            expirationTime: e,
            sortIndex: -1,
          };
          c > d
            ? ((a.sortIndex = c),
              f(t, a),
              null === h(r) &&
                a === h(t) &&
                (B ? (E(L), (L = -1)) : (B = true), K(H, c - d)))
            : ((a.sortIndex = e), f(r, a), A || z || ((A = true), I(J)));
          return a;
        };
        exports$1.unstable_shouldYield = M;
        exports$1.unstable_wrapCallback = function (a) {
          var b = y;
          return function () {
            var c = y;
            y = b;
            try {
              return a.apply(this, arguments);
            } finally {
              y = c;
            }
          };
        };
      })(scheduler_production_min);

      {
        scheduler.exports = scheduler_production_min;
      }

      var schedulerExports = scheduler.exports;

      var aa = reactExports,
        ca = schedulerExports;
      function p(a) {
        for (
          var b = "https://reactjs.org/docs/error-decoder.html?invariant=" + a,
            c = 1;
          c < arguments.length;
          c++
        )
          b += "&args[]=" + encodeURIComponent(arguments[c]);
        return (
          "Minified React error #" +
          a +
          "; visit " +
          b +
          " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
        );
      }
      var da = new Set(),
        ea = {};
      function fa(a, b) {
        ha(a, b);
        ha(a + "Capture", b);
      }
      function ha(a, b) {
        ea[a] = b;
        for (a = 0; a < b.length; a++) da.add(b[a]);
      }
      var ia = !(
          "undefined" === typeof window ||
          "undefined" === typeof window.document ||
          "undefined" === typeof window.document.createElement
        ),
        ja = Object.prototype.hasOwnProperty,
        ka =
          /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,
        la = {},
        ma = {};
      function oa(a) {
        if (ja.call(ma, a)) return true;
        if (ja.call(la, a)) return false;
        if (ka.test(a)) return (ma[a] = true);
        la[a] = true;
        return false;
      }
      function pa(a, b, c, d) {
        if (null !== c && 0 === c.type) return false;
        switch (typeof b) {
          case "function":
          case "symbol":
            return true;
          case "boolean":
            if (d) return false;
            if (null !== c) return !c.acceptsBooleans;
            a = a.toLowerCase().slice(0, 5);
            return "data-" !== a && "aria-" !== a;
          default:
            return false;
        }
      }
      function qa(a, b, c, d) {
        if (null === b || "undefined" === typeof b || pa(a, b, c, d))
          return true;
        if (d) return false;
        if (null !== c)
          switch (c.type) {
            case 3:
              return !b;
            case 4:
              return false === b;
            case 5:
              return isNaN(b);
            case 6:
              return isNaN(b) || 1 > b;
          }
        return false;
      }
      function v$1(a, b, c, d, e, f, g) {
        this.acceptsBooleans = 2 === b || 3 === b || 4 === b;
        this.attributeName = d;
        this.attributeNamespace = e;
        this.mustUseProperty = c;
        this.propertyName = a;
        this.type = b;
        this.sanitizeURL = f;
        this.removeEmptyString = g;
      }
      var z = {};
      "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style"
        .split(" ")
        .forEach(function (a) {
          z[a] = new v$1(a, 0, false, a, null, false, false);
        });
      [
        ["acceptCharset", "accept-charset"],
        ["className", "class"],
        ["htmlFor", "for"],
        ["httpEquiv", "http-equiv"],
      ].forEach(function (a) {
        var b = a[0];
        z[b] = new v$1(b, 1, false, a[1], null, false, false);
      });
      ["contentEditable", "draggable", "spellCheck", "value"].forEach(
        function (a) {
          z[a] = new v$1(a, 2, false, a.toLowerCase(), null, false, false);
        },
      );
      [
        "autoReverse",
        "externalResourcesRequired",
        "focusable",
        "preserveAlpha",
      ].forEach(function (a) {
        z[a] = new v$1(a, 2, false, a, null, false, false);
      });
      "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope"
        .split(" ")
        .forEach(function (a) {
          z[a] = new v$1(a, 3, false, a.toLowerCase(), null, false, false);
        });
      ["checked", "multiple", "muted", "selected"].forEach(function (a) {
        z[a] = new v$1(a, 3, true, a, null, false, false);
      });
      ["capture", "download"].forEach(function (a) {
        z[a] = new v$1(a, 4, false, a, null, false, false);
      });
      ["cols", "rows", "size", "span"].forEach(function (a) {
        z[a] = new v$1(a, 6, false, a, null, false, false);
      });
      ["rowSpan", "start"].forEach(function (a) {
        z[a] = new v$1(a, 5, false, a.toLowerCase(), null, false, false);
      });
      var ra = /[\-:]([a-z])/g;
      function sa(a) {
        return a[1].toUpperCase();
      }
      "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height"
        .split(" ")
        .forEach(function (a) {
          var b = a.replace(ra, sa);
          z[b] = new v$1(b, 1, false, a, null, false, false);
        });
      "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type"
        .split(" ")
        .forEach(function (a) {
          var b = a.replace(ra, sa);
          z[b] = new v$1(
            b,
            1,
            false,
            a,
            "http://www.w3.org/1999/xlink",
            false,
            false,
          );
        });
      ["xml:base", "xml:lang", "xml:space"].forEach(function (a) {
        var b = a.replace(ra, sa);
        z[b] = new v$1(
          b,
          1,
          false,
          a,
          "http://www.w3.org/XML/1998/namespace",
          false,
          false,
        );
      });
      ["tabIndex", "crossOrigin"].forEach(function (a) {
        z[a] = new v$1(a, 1, false, a.toLowerCase(), null, false, false);
      });
      z.xlinkHref = new v$1(
        "xlinkHref",
        1,
        false,
        "xlink:href",
        "http://www.w3.org/1999/xlink",
        true,
        false,
      );
      ["src", "href", "action", "formAction"].forEach(function (a) {
        z[a] = new v$1(a, 1, false, a.toLowerCase(), null, true, true);
      });
      function ta(a, b, c, d) {
        var e = z.hasOwnProperty(b) ? z[b] : null;
        if (
          null !== e
            ? 0 !== e.type
            : d ||
              !(2 < b.length) ||
              ("o" !== b[0] && "O" !== b[0]) ||
              ("n" !== b[1] && "N" !== b[1])
        )
          (qa(b, c, e, d) && (c = null),
            d || null === e
              ? oa(b) &&
                (null === c ? a.removeAttribute(b) : a.setAttribute(b, "" + c))
              : e.mustUseProperty
                ? (a[e.propertyName] =
                    null === c ? (3 === e.type ? false : "") : c)
                : ((b = e.attributeName),
                  (d = e.attributeNamespace),
                  null === c
                    ? a.removeAttribute(b)
                    : ((e = e.type),
                      (c = 3 === e || (4 === e && true === c) ? "" : "" + c),
                      d ? a.setAttributeNS(d, b, c) : a.setAttribute(b, c))));
      }
      var ua = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
        va = Symbol.for("react.element"),
        wa = Symbol.for("react.portal"),
        ya = Symbol.for("react.fragment"),
        za = Symbol.for("react.strict_mode"),
        Aa = Symbol.for("react.profiler"),
        Ba = Symbol.for("react.provider"),
        Ca = Symbol.for("react.context"),
        Da = Symbol.for("react.forward_ref"),
        Ea = Symbol.for("react.suspense"),
        Fa = Symbol.for("react.suspense_list"),
        Ga = Symbol.for("react.memo"),
        Ha = Symbol.for("react.lazy");
      var Ia = Symbol.for("react.offscreen");
      var Ja = Symbol.iterator;
      function Ka(a) {
        if (null === a || "object" !== typeof a) return null;
        a = (Ja && a[Ja]) || a["@@iterator"];
        return "function" === typeof a ? a : null;
      }
      var A = Object.assign,
        La;
      function Ma(a) {
        if (void 0 === La)
          try {
            throw Error();
          } catch (c) {
            var b = c.stack.trim().match(/\n( *(at )?)/);
            La = (b && b[1]) || "";
          }
        return "\n" + La + a;
      }
      var Na = false;
      function Oa(a, b) {
        if (!a || Na) return "";
        Na = true;
        var c = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        try {
          if (b)
            if (
              ((b = function () {
                throw Error();
              }),
              Object.defineProperty(b.prototype, "props", {
                set: function () {
                  throw Error();
                },
              }),
              "object" === typeof Reflect && Reflect.construct)
            ) {
              try {
                Reflect.construct(b, []);
              } catch (l) {
                var d = l;
              }
              Reflect.construct(a, [], b);
            } else {
              try {
                b.call();
              } catch (l) {
                d = l;
              }
              a.call(b.prototype);
            }
          else {
            try {
              throw Error();
            } catch (l) {
              d = l;
            }
            a();
          }
        } catch (l) {
          if (l && d && "string" === typeof l.stack) {
            for (
              var e = l.stack.split("\n"),
                f = d.stack.split("\n"),
                g = e.length - 1,
                h = f.length - 1;
              1 <= g && 0 <= h && e[g] !== f[h];
            )
              h--;
            for (; 1 <= g && 0 <= h; g--, h--)
              if (e[g] !== f[h]) {
                if (1 !== g || 1 !== h) {
                  do
                    if ((g--, h--, 0 > h || e[g] !== f[h])) {
                      var k = "\n" + e[g].replace(" at new ", " at ");
                      a.displayName &&
                        k.includes("<anonymous>") &&
                        (k = k.replace("<anonymous>", a.displayName));
                      return k;
                    }
                  while (1 <= g && 0 <= h);
                }
                break;
              }
          }
        } finally {
          ((Na = false), (Error.prepareStackTrace = c));
        }
        return (a = a ? a.displayName || a.name : "") ? Ma(a) : "";
      }
      function Pa(a) {
        switch (a.tag) {
          case 5:
            return Ma(a.type);
          case 16:
            return Ma("Lazy");
          case 13:
            return Ma("Suspense");
          case 19:
            return Ma("SuspenseList");
          case 0:
          case 2:
          case 15:
            return ((a = Oa(a.type, false)), a);
          case 11:
            return ((a = Oa(a.type.render, false)), a);
          case 1:
            return ((a = Oa(a.type, true)), a);
          default:
            return "";
        }
      }
      function Qa(a) {
        if (null == a) return null;
        if ("function" === typeof a) return a.displayName || a.name || null;
        if ("string" === typeof a) return a;
        switch (a) {
          case ya:
            return "Fragment";
          case wa:
            return "Portal";
          case Aa:
            return "Profiler";
          case za:
            return "StrictMode";
          case Ea:
            return "Suspense";
          case Fa:
            return "SuspenseList";
        }
        if ("object" === typeof a)
          switch (a.$$typeof) {
            case Ca:
              return (a.displayName || "Context") + ".Consumer";
            case Ba:
              return (a._context.displayName || "Context") + ".Provider";
            case Da:
              var b = a.render;
              a = a.displayName;
              a ||
                ((a = b.displayName || b.name || ""),
                (a = "" !== a ? "ForwardRef(" + a + ")" : "ForwardRef"));
              return a;
            case Ga:
              return (
                (b = a.displayName || null),
                null !== b ? b : Qa(a.type) || "Memo"
              );
            case Ha:
              b = a._payload;
              a = a._init;
              try {
                return Qa(a(b));
              } catch (c) {}
          }
        return null;
      }
      function Ra(a) {
        var b = a.type;
        switch (a.tag) {
          case 24:
            return "Cache";
          case 9:
            return (b.displayName || "Context") + ".Consumer";
          case 10:
            return (b._context.displayName || "Context") + ".Provider";
          case 18:
            return "DehydratedFragment";
          case 11:
            return (
              (a = b.render),
              (a = a.displayName || a.name || ""),
              b.displayName ||
                ("" !== a ? "ForwardRef(" + a + ")" : "ForwardRef")
            );
          case 7:
            return "Fragment";
          case 5:
            return b;
          case 4:
            return "Portal";
          case 3:
            return "Root";
          case 6:
            return "Text";
          case 16:
            return Qa(b);
          case 8:
            return b === za ? "StrictMode" : "Mode";
          case 22:
            return "Offscreen";
          case 12:
            return "Profiler";
          case 21:
            return "Scope";
          case 13:
            return "Suspense";
          case 19:
            return "SuspenseList";
          case 25:
            return "TracingMarker";
          case 1:
          case 0:
          case 17:
          case 2:
          case 14:
          case 15:
            if ("function" === typeof b) return b.displayName || b.name || null;
            if ("string" === typeof b) return b;
        }
        return null;
      }
      function Sa(a) {
        switch (typeof a) {
          case "boolean":
          case "number":
          case "string":
          case "undefined":
            return a;
          case "object":
            return a;
          default:
            return "";
        }
      }
      function Ta(a) {
        var b = a.type;
        return (
          (a = a.nodeName) &&
          "input" === a.toLowerCase() &&
          ("checkbox" === b || "radio" === b)
        );
      }
      function Ua(a) {
        var b = Ta(a) ? "checked" : "value",
          c = Object.getOwnPropertyDescriptor(a.constructor.prototype, b),
          d = "" + a[b];
        if (
          !a.hasOwnProperty(b) &&
          "undefined" !== typeof c &&
          "function" === typeof c.get &&
          "function" === typeof c.set
        ) {
          var e = c.get,
            f = c.set;
          Object.defineProperty(a, b, {
            configurable: true,
            get: function () {
              return e.call(this);
            },
            set: function (a) {
              d = "" + a;
              f.call(this, a);
            },
          });
          Object.defineProperty(a, b, { enumerable: c.enumerable });
          return {
            getValue: function () {
              return d;
            },
            setValue: function (a) {
              d = "" + a;
            },
            stopTracking: function () {
              a._valueTracker = null;
              delete a[b];
            },
          };
        }
      }
      function Va(a) {
        a._valueTracker || (a._valueTracker = Ua(a));
      }
      function Wa(a) {
        if (!a) return false;
        var b = a._valueTracker;
        if (!b) return true;
        var c = b.getValue();
        var d = "";
        a && (d = Ta(a) ? (a.checked ? "true" : "false") : a.value);
        a = d;
        return a !== c ? (b.setValue(a), true) : false;
      }
      function Xa(a) {
        a = a || ("undefined" !== typeof document ? document : void 0);
        if ("undefined" === typeof a) return null;
        try {
          return a.activeElement || a.body;
        } catch (b) {
          return a.body;
        }
      }
      function Ya(a, b) {
        var c = b.checked;
        return A({}, b, {
          defaultChecked: void 0,
          defaultValue: void 0,
          value: void 0,
          checked: null != c ? c : a._wrapperState.initialChecked,
        });
      }
      function Za(a, b) {
        var c = null == b.defaultValue ? "" : b.defaultValue,
          d = null != b.checked ? b.checked : b.defaultChecked;
        c = Sa(null != b.value ? b.value : c);
        a._wrapperState = {
          initialChecked: d,
          initialValue: c,
          controlled:
            "checkbox" === b.type || "radio" === b.type
              ? null != b.checked
              : null != b.value,
        };
      }
      function ab(a, b) {
        b = b.checked;
        null != b && ta(a, "checked", b, false);
      }
      function bb(a, b) {
        ab(a, b);
        var c = Sa(b.value),
          d = b.type;
        if (null != c)
          if ("number" === d) {
            if ((0 === c && "" === a.value) || a.value != c) a.value = "" + c;
          } else a.value !== "" + c && (a.value = "" + c);
        else if ("submit" === d || "reset" === d) {
          a.removeAttribute("value");
          return;
        }
        b.hasOwnProperty("value")
          ? cb(a, b.type, c)
          : b.hasOwnProperty("defaultValue") &&
            cb(a, b.type, Sa(b.defaultValue));
        null == b.checked &&
          null != b.defaultChecked &&
          (a.defaultChecked = !!b.defaultChecked);
      }
      function db(a, b, c) {
        if (b.hasOwnProperty("value") || b.hasOwnProperty("defaultValue")) {
          var d = b.type;
          if (
            !(
              ("submit" !== d && "reset" !== d) ||
              (void 0 !== b.value && null !== b.value)
            )
          )
            return;
          b = "" + a._wrapperState.initialValue;
          c || b === a.value || (a.value = b);
          a.defaultValue = b;
        }
        c = a.name;
        "" !== c && (a.name = "");
        a.defaultChecked = !!a._wrapperState.initialChecked;
        "" !== c && (a.name = c);
      }
      function cb(a, b, c) {
        if ("number" !== b || Xa(a.ownerDocument) !== a)
          null == c
            ? (a.defaultValue = "" + a._wrapperState.initialValue)
            : a.defaultValue !== "" + c && (a.defaultValue = "" + c);
      }
      var eb = Array.isArray;
      function fb(a, b, c, d) {
        a = a.options;
        if (b) {
          b = {};
          for (var e = 0; e < c.length; e++) b["$" + c[e]] = true;
          for (c = 0; c < a.length; c++)
            ((e = b.hasOwnProperty("$" + a[c].value)),
              a[c].selected !== e && (a[c].selected = e),
              e && d && (a[c].defaultSelected = true));
        } else {
          c = "" + Sa(c);
          b = null;
          for (e = 0; e < a.length; e++) {
            if (a[e].value === c) {
              a[e].selected = true;
              d && (a[e].defaultSelected = true);
              return;
            }
            null !== b || a[e].disabled || (b = a[e]);
          }
          null !== b && (b.selected = true);
        }
      }
      function gb(a, b) {
        if (null != b.dangerouslySetInnerHTML) throw Error(p(91));
        return A({}, b, {
          value: void 0,
          defaultValue: void 0,
          children: "" + a._wrapperState.initialValue,
        });
      }
      function hb(a, b) {
        var c = b.value;
        if (null == c) {
          c = b.children;
          b = b.defaultValue;
          if (null != c) {
            if (null != b) throw Error(p(92));
            if (eb(c)) {
              if (1 < c.length) throw Error(p(93));
              c = c[0];
            }
            b = c;
          }
          null == b && (b = "");
          c = b;
        }
        a._wrapperState = { initialValue: Sa(c) };
      }
      function ib(a, b) {
        var c = Sa(b.value),
          d = Sa(b.defaultValue);
        null != c &&
          ((c = "" + c),
          c !== a.value && (a.value = c),
          null == b.defaultValue &&
            a.defaultValue !== c &&
            (a.defaultValue = c));
        null != d && (a.defaultValue = "" + d);
      }
      function jb(a) {
        var b = a.textContent;
        b === a._wrapperState.initialValue &&
          "" !== b &&
          null !== b &&
          (a.value = b);
      }
      function kb(a) {
        switch (a) {
          case "svg":
            return "http://www.w3.org/2000/svg";
          case "math":
            return "http://www.w3.org/1998/Math/MathML";
          default:
            return "http://www.w3.org/1999/xhtml";
        }
      }
      function lb(a, b) {
        return null == a || "http://www.w3.org/1999/xhtml" === a
          ? kb(b)
          : "http://www.w3.org/2000/svg" === a && "foreignObject" === b
            ? "http://www.w3.org/1999/xhtml"
            : a;
      }
      var mb,
        nb = (function (a) {
          return "undefined" !== typeof MSApp && MSApp.execUnsafeLocalFunction
            ? function (b, c, d, e) {
                MSApp.execUnsafeLocalFunction(function () {
                  return a(b, c, d, e);
                });
              }
            : a;
        })(function (a, b) {
          if (
            "http://www.w3.org/2000/svg" !== a.namespaceURI ||
            "innerHTML" in a
          )
            a.innerHTML = b;
          else {
            mb = mb || document.createElement("div");
            mb.innerHTML = "<svg>" + b.valueOf().toString() + "</svg>";
            for (b = mb.firstChild; a.firstChild; ) a.removeChild(a.firstChild);
            for (; b.firstChild; ) a.appendChild(b.firstChild);
          }
        });
      function ob(a, b) {
        if (b) {
          var c = a.firstChild;
          if (c && c === a.lastChild && 3 === c.nodeType) {
            c.nodeValue = b;
            return;
          }
        }
        a.textContent = b;
      }
      var pb = {
          animationIterationCount: true,
          aspectRatio: true,
          borderImageOutset: true,
          borderImageSlice: true,
          borderImageWidth: true,
          boxFlex: true,
          boxFlexGroup: true,
          boxOrdinalGroup: true,
          columnCount: true,
          columns: true,
          flex: true,
          flexGrow: true,
          flexPositive: true,
          flexShrink: true,
          flexNegative: true,
          flexOrder: true,
          gridArea: true,
          gridRow: true,
          gridRowEnd: true,
          gridRowSpan: true,
          gridRowStart: true,
          gridColumn: true,
          gridColumnEnd: true,
          gridColumnSpan: true,
          gridColumnStart: true,
          fontWeight: true,
          lineClamp: true,
          lineHeight: true,
          opacity: true,
          order: true,
          orphans: true,
          tabSize: true,
          widows: true,
          zIndex: true,
          zoom: true,
          fillOpacity: true,
          floodOpacity: true,
          stopOpacity: true,
          strokeDasharray: true,
          strokeDashoffset: true,
          strokeMiterlimit: true,
          strokeOpacity: true,
          strokeWidth: true,
        },
        qb = ["Webkit", "ms", "Moz", "O"];
      Object.keys(pb).forEach(function (a) {
        qb.forEach(function (b) {
          b = b + a.charAt(0).toUpperCase() + a.substring(1);
          pb[b] = pb[a];
        });
      });
      function rb(a, b, c) {
        return null == b || "boolean" === typeof b || "" === b
          ? ""
          : c ||
              "number" !== typeof b ||
              0 === b ||
              (pb.hasOwnProperty(a) && pb[a])
            ? ("" + b).trim()
            : b + "px";
      }
      function sb(a, b) {
        a = a.style;
        for (var c in b)
          if (b.hasOwnProperty(c)) {
            var d = 0 === c.indexOf("--"),
              e = rb(c, b[c], d);
            "float" === c && (c = "cssFloat");
            d ? a.setProperty(c, e) : (a[c] = e);
          }
      }
      var tb = A(
        { menuitem: true },
        {
          area: true,
          base: true,
          br: true,
          col: true,
          embed: true,
          hr: true,
          img: true,
          input: true,
          keygen: true,
          link: true,
          meta: true,
          param: true,
          source: true,
          track: true,
          wbr: true,
        },
      );
      function ub(a, b) {
        if (b) {
          if (
            tb[a] &&
            (null != b.children || null != b.dangerouslySetInnerHTML)
          )
            throw Error(p(137, a));
          if (null != b.dangerouslySetInnerHTML) {
            if (null != b.children) throw Error(p(60));
            if (
              "object" !== typeof b.dangerouslySetInnerHTML ||
              !("__html" in b.dangerouslySetInnerHTML)
            )
              throw Error(p(61));
          }
          if (null != b.style && "object" !== typeof b.style)
            throw Error(p(62));
        }
      }
      function vb(a, b) {
        if (-1 === a.indexOf("-")) return "string" === typeof b.is;
        switch (a) {
          case "annotation-xml":
          case "color-profile":
          case "font-face":
          case "font-face-src":
          case "font-face-uri":
          case "font-face-format":
          case "font-face-name":
          case "missing-glyph":
            return false;
          default:
            return true;
        }
      }
      var wb = null;
      function xb(a) {
        a = a.target || a.srcElement || window;
        a.correspondingUseElement && (a = a.correspondingUseElement);
        return 3 === a.nodeType ? a.parentNode : a;
      }
      var yb = null,
        zb = null,
        Ab = null;
      function Bb(a) {
        if ((a = Cb(a))) {
          if ("function" !== typeof yb) throw Error(p(280));
          var b = a.stateNode;
          b && ((b = Db(b)), yb(a.stateNode, a.type, b));
        }
      }
      function Eb(a) {
        zb ? (Ab ? Ab.push(a) : (Ab = [a])) : (zb = a);
      }
      function Fb() {
        if (zb) {
          var a = zb,
            b = Ab;
          Ab = zb = null;
          Bb(a);
          if (b) for (a = 0; a < b.length; a++) Bb(b[a]);
        }
      }
      function Gb(a, b) {
        return a(b);
      }
      function Hb() {}
      var Ib = false;
      function Jb(a, b, c) {
        if (Ib) return a(b, c);
        Ib = true;
        try {
          return Gb(a, b, c);
        } finally {
          if (((Ib = false), null !== zb || null !== Ab)) (Hb(), Fb());
        }
      }
      function Kb(a, b) {
        var c = a.stateNode;
        if (null === c) return null;
        var d = Db(c);
        if (null === d) return null;
        c = d[b];
        a: switch (b) {
          case "onClick":
          case "onClickCapture":
          case "onDoubleClick":
          case "onDoubleClickCapture":
          case "onMouseDown":
          case "onMouseDownCapture":
          case "onMouseMove":
          case "onMouseMoveCapture":
          case "onMouseUp":
          case "onMouseUpCapture":
          case "onMouseEnter":
            (d = !d.disabled) ||
              ((a = a.type),
              (d = !(
                "button" === a ||
                "input" === a ||
                "select" === a ||
                "textarea" === a
              )));
            a = !d;
            break a;
          default:
            a = false;
        }
        if (a) return null;
        if (c && "function" !== typeof c) throw Error(p(231, b, typeof c));
        return c;
      }
      var Lb = false;
      if (ia)
        try {
          var Mb = {};
          Object.defineProperty(Mb, "passive", {
            get: function () {
              Lb = !0;
            },
          });
          window.addEventListener("test", Mb, Mb);
          window.removeEventListener("test", Mb, Mb);
        } catch (a) {
          Lb = false;
        }
      function Nb(a, b, c, d, e, f, g, h, k) {
        var l = Array.prototype.slice.call(arguments, 3);
        try {
          b.apply(c, l);
        } catch (m) {
          this.onError(m);
        }
      }
      var Ob = false,
        Pb = null,
        Qb = false,
        Rb = null,
        Sb = {
          onError: function (a) {
            Ob = true;
            Pb = a;
          },
        };
      function Tb(a, b, c, d, e, f, g, h, k) {
        Ob = false;
        Pb = null;
        Nb.apply(Sb, arguments);
      }
      function Ub(a, b, c, d, e, f, g, h, k) {
        Tb.apply(this, arguments);
        if (Ob) {
          if (Ob) {
            var l = Pb;
            Ob = false;
            Pb = null;
          } else throw Error(p(198));
          Qb || ((Qb = true), (Rb = l));
        }
      }
      function Vb(a) {
        var b = a,
          c = a;
        if (a.alternate) for (; b.return; ) b = b.return;
        else {
          a = b;
          do
            ((b = a), 0 !== (b.flags & 4098) && (c = b.return), (a = b.return));
          while (a);
        }
        return 3 === b.tag ? c : null;
      }
      function Wb(a) {
        if (13 === a.tag) {
          var b = a.memoizedState;
          null === b &&
            ((a = a.alternate), null !== a && (b = a.memoizedState));
          if (null !== b) return b.dehydrated;
        }
        return null;
      }
      function Xb(a) {
        if (Vb(a) !== a) throw Error(p(188));
      }
      function Yb(a) {
        var b = a.alternate;
        if (!b) {
          b = Vb(a);
          if (null === b) throw Error(p(188));
          return b !== a ? null : a;
        }
        for (var c = a, d = b; ; ) {
          var e = c.return;
          if (null === e) break;
          var f = e.alternate;
          if (null === f) {
            d = e.return;
            if (null !== d) {
              c = d;
              continue;
            }
            break;
          }
          if (e.child === f.child) {
            for (f = e.child; f; ) {
              if (f === c) return (Xb(e), a);
              if (f === d) return (Xb(e), b);
              f = f.sibling;
            }
            throw Error(p(188));
          }
          if (c.return !== d.return) ((c = e), (d = f));
          else {
            for (var g = false, h = e.child; h; ) {
              if (h === c) {
                g = true;
                c = e;
                d = f;
                break;
              }
              if (h === d) {
                g = true;
                d = e;
                c = f;
                break;
              }
              h = h.sibling;
            }
            if (!g) {
              for (h = f.child; h; ) {
                if (h === c) {
                  g = true;
                  c = f;
                  d = e;
                  break;
                }
                if (h === d) {
                  g = true;
                  d = f;
                  c = e;
                  break;
                }
                h = h.sibling;
              }
              if (!g) throw Error(p(189));
            }
          }
          if (c.alternate !== d) throw Error(p(190));
        }
        if (3 !== c.tag) throw Error(p(188));
        return c.stateNode.current === c ? a : b;
      }
      function Zb(a) {
        a = Yb(a);
        return null !== a ? $b(a) : null;
      }
      function $b(a) {
        if (5 === a.tag || 6 === a.tag) return a;
        for (a = a.child; null !== a; ) {
          var b = $b(a);
          if (null !== b) return b;
          a = a.sibling;
        }
        return null;
      }
      var ac = ca.unstable_scheduleCallback,
        bc = ca.unstable_cancelCallback,
        cc = ca.unstable_shouldYield,
        dc = ca.unstable_requestPaint,
        B = ca.unstable_now,
        ec = ca.unstable_getCurrentPriorityLevel,
        fc = ca.unstable_ImmediatePriority,
        gc = ca.unstable_UserBlockingPriority,
        hc = ca.unstable_NormalPriority,
        ic = ca.unstable_LowPriority,
        jc = ca.unstable_IdlePriority,
        kc = null,
        lc = null;
      function mc(a) {
        if (lc && "function" === typeof lc.onCommitFiberRoot)
          try {
            lc.onCommitFiberRoot(
              kc,
              a,
              void 0,
              128 === (a.current.flags & 128),
            );
          } catch (b) {}
      }
      var oc = Math.clz32 ? Math.clz32 : nc,
        pc = Math.log,
        qc = Math.LN2;
      function nc(a) {
        a >>>= 0;
        return 0 === a ? 32 : (31 - ((pc(a) / qc) | 0)) | 0;
      }
      var rc = 64,
        sc = 4194304;
      function tc(a) {
        switch (a & -a) {
          case 1:
            return 1;
          case 2:
            return 2;
          case 4:
            return 4;
          case 8:
            return 8;
          case 16:
            return 16;
          case 32:
            return 32;
          case 64:
          case 128:
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
            return a & 4194240;
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
          case 67108864:
            return a & 130023424;
          case 134217728:
            return 134217728;
          case 268435456:
            return 268435456;
          case 536870912:
            return 536870912;
          case 1073741824:
            return 1073741824;
          default:
            return a;
        }
      }
      function uc(a, b) {
        var c = a.pendingLanes;
        if (0 === c) return 0;
        var d = 0,
          e = a.suspendedLanes,
          f = a.pingedLanes,
          g = c & 268435455;
        if (0 !== g) {
          var h = g & ~e;
          0 !== h ? (d = tc(h)) : ((f &= g), 0 !== f && (d = tc(f)));
        } else ((g = c & ~e), 0 !== g ? (d = tc(g)) : 0 !== f && (d = tc(f)));
        if (0 === d) return 0;
        if (
          0 !== b &&
          b !== d &&
          0 === (b & e) &&
          ((e = d & -d),
          (f = b & -b),
          e >= f || (16 === e && 0 !== (f & 4194240)))
        )
          return b;
        0 !== (d & 4) && (d |= c & 16);
        b = a.entangledLanes;
        if (0 !== b)
          for (a = a.entanglements, b &= d; 0 < b; )
            ((c = 31 - oc(b)), (e = 1 << c), (d |= a[c]), (b &= ~e));
        return d;
      }
      function vc(a, b) {
        switch (a) {
          case 1:
          case 2:
          case 4:
            return b + 250;
          case 8:
          case 16:
          case 32:
          case 64:
          case 128:
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
            return b + 5e3;
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
          case 67108864:
            return -1;
          case 134217728:
          case 268435456:
          case 536870912:
          case 1073741824:
            return -1;
          default:
            return -1;
        }
      }
      function wc(a, b) {
        for (
          var c = a.suspendedLanes,
            d = a.pingedLanes,
            e = a.expirationTimes,
            f = a.pendingLanes;
          0 < f;
        ) {
          var g = 31 - oc(f),
            h = 1 << g,
            k = e[g];
          if (-1 === k) {
            if (0 === (h & c) || 0 !== (h & d)) e[g] = vc(h, b);
          } else k <= b && (a.expiredLanes |= h);
          f &= ~h;
        }
      }
      function xc(a) {
        a = a.pendingLanes & -1073741825;
        return 0 !== a ? a : a & 1073741824 ? 1073741824 : 0;
      }
      function yc() {
        var a = rc;
        rc <<= 1;
        0 === (rc & 4194240) && (rc = 64);
        return a;
      }
      function zc(a) {
        for (var b = [], c = 0; 31 > c; c++) b.push(a);
        return b;
      }
      function Ac(a, b, c) {
        a.pendingLanes |= b;
        536870912 !== b && ((a.suspendedLanes = 0), (a.pingedLanes = 0));
        a = a.eventTimes;
        b = 31 - oc(b);
        a[b] = c;
      }
      function Bc(a, b) {
        var c = a.pendingLanes & ~b;
        a.pendingLanes = b;
        a.suspendedLanes = 0;
        a.pingedLanes = 0;
        a.expiredLanes &= b;
        a.mutableReadLanes &= b;
        a.entangledLanes &= b;
        b = a.entanglements;
        var d = a.eventTimes;
        for (a = a.expirationTimes; 0 < c; ) {
          var e = 31 - oc(c),
            f = 1 << e;
          b[e] = 0;
          d[e] = -1;
          a[e] = -1;
          c &= ~f;
        }
      }
      function Cc(a, b) {
        var c = (a.entangledLanes |= b);
        for (a = a.entanglements; c; ) {
          var d = 31 - oc(c),
            e = 1 << d;
          (e & b) | (a[d] & b) && (a[d] |= b);
          c &= ~e;
        }
      }
      var C = 0;
      function Dc(a) {
        a &= -a;
        return 1 < a
          ? 4 < a
            ? 0 !== (a & 268435455)
              ? 16
              : 536870912
            : 4
          : 1;
      }
      var Ec,
        Fc,
        Gc,
        Hc,
        Ic,
        Jc = false,
        Kc = [],
        Lc = null,
        Mc = null,
        Nc = null,
        Oc = new Map(),
        Pc = new Map(),
        Qc = [],
        Rc =
          "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(
            " ",
          );
      function Sc(a, b) {
        switch (a) {
          case "focusin":
          case "focusout":
            Lc = null;
            break;
          case "dragenter":
          case "dragleave":
            Mc = null;
            break;
          case "mouseover":
          case "mouseout":
            Nc = null;
            break;
          case "pointerover":
          case "pointerout":
            Oc.delete(b.pointerId);
            break;
          case "gotpointercapture":
          case "lostpointercapture":
            Pc.delete(b.pointerId);
        }
      }
      function Tc(a, b, c, d, e, f) {
        if (null === a || a.nativeEvent !== f)
          return (
            (a = {
              blockedOn: b,
              domEventName: c,
              eventSystemFlags: d,
              nativeEvent: f,
              targetContainers: [e],
            }),
            null !== b && ((b = Cb(b)), null !== b && Fc(b)),
            a
          );
        a.eventSystemFlags |= d;
        b = a.targetContainers;
        null !== e && -1 === b.indexOf(e) && b.push(e);
        return a;
      }
      function Uc(a, b, c, d, e) {
        switch (b) {
          case "focusin":
            return ((Lc = Tc(Lc, a, b, c, d, e)), true);
          case "dragenter":
            return ((Mc = Tc(Mc, a, b, c, d, e)), true);
          case "mouseover":
            return ((Nc = Tc(Nc, a, b, c, d, e)), true);
          case "pointerover":
            var f = e.pointerId;
            Oc.set(f, Tc(Oc.get(f) || null, a, b, c, d, e));
            return true;
          case "gotpointercapture":
            return (
              (f = e.pointerId),
              Pc.set(f, Tc(Pc.get(f) || null, a, b, c, d, e)),
              true
            );
        }
        return false;
      }
      function Vc(a) {
        var b = Wc(a.target);
        if (null !== b) {
          var c = Vb(b);
          if (null !== c)
            if (((b = c.tag), 13 === b)) {
              if (((b = Wb(c)), null !== b)) {
                a.blockedOn = b;
                Ic(a.priority, function () {
                  Gc(c);
                });
                return;
              }
            } else if (
              3 === b &&
              c.stateNode.current.memoizedState.isDehydrated
            ) {
              a.blockedOn = 3 === c.tag ? c.stateNode.containerInfo : null;
              return;
            }
        }
        a.blockedOn = null;
      }
      function Xc(a) {
        if (null !== a.blockedOn) return false;
        for (var b = a.targetContainers; 0 < b.length; ) {
          var c = Yc(a.domEventName, a.eventSystemFlags, b[0], a.nativeEvent);
          if (null === c) {
            c = a.nativeEvent;
            var d = new c.constructor(c.type, c);
            wb = d;
            c.target.dispatchEvent(d);
            wb = null;
          } else
            return ((b = Cb(c)), null !== b && Fc(b), (a.blockedOn = c), false);
          b.shift();
        }
        return true;
      }
      function Zc(a, b, c) {
        Xc(a) && c.delete(b);
      }
      function $c() {
        Jc = false;
        null !== Lc && Xc(Lc) && (Lc = null);
        null !== Mc && Xc(Mc) && (Mc = null);
        null !== Nc && Xc(Nc) && (Nc = null);
        Oc.forEach(Zc);
        Pc.forEach(Zc);
      }
      function ad(a, b) {
        a.blockedOn === b &&
          ((a.blockedOn = null),
          Jc ||
            ((Jc = true),
            ca.unstable_scheduleCallback(ca.unstable_NormalPriority, $c)));
      }
      function bd(a) {
        function b(b) {
          return ad(b, a);
        }
        if (0 < Kc.length) {
          ad(Kc[0], a);
          for (var c = 1; c < Kc.length; c++) {
            var d = Kc[c];
            d.blockedOn === a && (d.blockedOn = null);
          }
        }
        null !== Lc && ad(Lc, a);
        null !== Mc && ad(Mc, a);
        null !== Nc && ad(Nc, a);
        Oc.forEach(b);
        Pc.forEach(b);
        for (c = 0; c < Qc.length; c++)
          ((d = Qc[c]), d.blockedOn === a && (d.blockedOn = null));
        for (; 0 < Qc.length && ((c = Qc[0]), null === c.blockedOn); )
          (Vc(c), null === c.blockedOn && Qc.shift());
      }
      var cd = ua.ReactCurrentBatchConfig,
        dd = true;
      function ed(a, b, c, d) {
        var e = C,
          f = cd.transition;
        cd.transition = null;
        try {
          ((C = 1), fd(a, b, c, d));
        } finally {
          ((C = e), (cd.transition = f));
        }
      }
      function gd(a, b, c, d) {
        var e = C,
          f = cd.transition;
        cd.transition = null;
        try {
          ((C = 4), fd(a, b, c, d));
        } finally {
          ((C = e), (cd.transition = f));
        }
      }
      function fd(a, b, c, d) {
        if (dd) {
          var e = Yc(a, b, c, d);
          if (null === e) (hd(a, b, d, id$2, c), Sc(a, d));
          else if (Uc(e, a, b, c, d)) d.stopPropagation();
          else if ((Sc(a, d), b & 4 && -1 < Rc.indexOf(a))) {
            for (; null !== e; ) {
              var f = Cb(e);
              null !== f && Ec(f);
              f = Yc(a, b, c, d);
              null === f && hd(a, b, d, id$2, c);
              if (f === e) break;
              e = f;
            }
            null !== e && d.stopPropagation();
          } else hd(a, b, d, null, c);
        }
      }
      var id$2 = null;
      function Yc(a, b, c, d) {
        id$2 = null;
        a = xb(d);
        a = Wc(a);
        if (null !== a)
          if (((b = Vb(a)), null === b)) a = null;
          else if (((c = b.tag), 13 === c)) {
            a = Wb(b);
            if (null !== a) return a;
            a = null;
          } else if (3 === c) {
            if (b.stateNode.current.memoizedState.isDehydrated)
              return 3 === b.tag ? b.stateNode.containerInfo : null;
            a = null;
          } else b !== a && (a = null);
        id$2 = a;
        return null;
      }
      function jd(a) {
        switch (a) {
          case "cancel":
          case "click":
          case "close":
          case "contextmenu":
          case "copy":
          case "cut":
          case "auxclick":
          case "dblclick":
          case "dragend":
          case "dragstart":
          case "drop":
          case "focusin":
          case "focusout":
          case "input":
          case "invalid":
          case "keydown":
          case "keypress":
          case "keyup":
          case "mousedown":
          case "mouseup":
          case "paste":
          case "pause":
          case "play":
          case "pointercancel":
          case "pointerdown":
          case "pointerup":
          case "ratechange":
          case "reset":
          case "resize":
          case "seeked":
          case "submit":
          case "touchcancel":
          case "touchend":
          case "touchstart":
          case "volumechange":
          case "change":
          case "selectionchange":
          case "textInput":
          case "compositionstart":
          case "compositionend":
          case "compositionupdate":
          case "beforeblur":
          case "afterblur":
          case "beforeinput":
          case "blur":
          case "fullscreenchange":
          case "focus":
          case "hashchange":
          case "popstate":
          case "select":
          case "selectstart":
            return 1;
          case "drag":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "mousemove":
          case "mouseout":
          case "mouseover":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "scroll":
          case "toggle":
          case "touchmove":
          case "wheel":
          case "mouseenter":
          case "mouseleave":
          case "pointerenter":
          case "pointerleave":
            return 4;
          case "message":
            switch (ec()) {
              case fc:
                return 1;
              case gc:
                return 4;
              case hc:
              case ic:
                return 16;
              case jc:
                return 536870912;
              default:
                return 16;
            }
          default:
            return 16;
        }
      }
      var kd = null,
        ld = null,
        md = null;
      function nd() {
        if (md) return md;
        var a,
          b = ld,
          c = b.length,
          d,
          e = "value" in kd ? kd.value : kd.textContent,
          f = e.length;
        for (a = 0; a < c && b[a] === e[a]; a++);
        var g = c - a;
        for (d = 1; d <= g && b[c - d] === e[f - d]; d++);
        return (md = e.slice(a, 1 < d ? 1 - d : void 0));
      }
      function od(a) {
        var b = a.keyCode;
        "charCode" in a
          ? ((a = a.charCode), 0 === a && 13 === b && (a = 13))
          : (a = b);
        10 === a && (a = 13);
        return 32 <= a || 13 === a ? a : 0;
      }
      function pd() {
        return true;
      }
      function qd() {
        return false;
      }
      function rd(a) {
        function b(b, d, e, f, g) {
          this._reactName = b;
          this._targetInst = e;
          this.type = d;
          this.nativeEvent = f;
          this.target = g;
          this.currentTarget = null;
          for (var c in a)
            a.hasOwnProperty(c) && ((b = a[c]), (this[c] = b ? b(f) : f[c]));
          this.isDefaultPrevented = (
            null != f.defaultPrevented
              ? f.defaultPrevented
              : false === f.returnValue
          )
            ? pd
            : qd;
          this.isPropagationStopped = qd;
          return this;
        }
        A(b.prototype, {
          preventDefault: function () {
            this.defaultPrevented = true;
            var a = this.nativeEvent;
            a &&
              (a.preventDefault
                ? a.preventDefault()
                : "unknown" !== typeof a.returnValue && (a.returnValue = false),
              (this.isDefaultPrevented = pd));
          },
          stopPropagation: function () {
            var a = this.nativeEvent;
            a &&
              (a.stopPropagation
                ? a.stopPropagation()
                : "unknown" !== typeof a.cancelBubble &&
                  (a.cancelBubble = true),
              (this.isPropagationStopped = pd));
          },
          persist: function () {},
          isPersistent: pd,
        });
        return b;
      }
      var sd = {
          eventPhase: 0,
          bubbles: 0,
          cancelable: 0,
          timeStamp: function (a) {
            return a.timeStamp || Date.now();
          },
          defaultPrevented: 0,
          isTrusted: 0,
        },
        td = rd(sd),
        ud = A({}, sd, { view: 0, detail: 0 }),
        vd = rd(ud),
        wd,
        xd,
        yd,
        Ad = A({}, ud, {
          screenX: 0,
          screenY: 0,
          clientX: 0,
          clientY: 0,
          pageX: 0,
          pageY: 0,
          ctrlKey: 0,
          shiftKey: 0,
          altKey: 0,
          metaKey: 0,
          getModifierState: zd,
          button: 0,
          buttons: 0,
          relatedTarget: function (a) {
            return void 0 === a.relatedTarget
              ? a.fromElement === a.srcElement
                ? a.toElement
                : a.fromElement
              : a.relatedTarget;
          },
          movementX: function (a) {
            if ("movementX" in a) return a.movementX;
            a !== yd &&
              (yd && "mousemove" === a.type
                ? ((wd = a.screenX - yd.screenX), (xd = a.screenY - yd.screenY))
                : (xd = wd = 0),
              (yd = a));
            return wd;
          },
          movementY: function (a) {
            return "movementY" in a ? a.movementY : xd;
          },
        }),
        Bd = rd(Ad),
        Cd = A({}, Ad, { dataTransfer: 0 }),
        Dd = rd(Cd),
        Ed = A({}, ud, { relatedTarget: 0 }),
        Fd = rd(Ed),
        Gd = A({}, sd, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }),
        Hd = rd(Gd),
        Id = A({}, sd, {
          clipboardData: function (a) {
            return "clipboardData" in a
              ? a.clipboardData
              : window.clipboardData;
          },
        }),
        Jd = rd(Id),
        Kd = A({}, sd, { data: 0 }),
        Ld = rd(Kd),
        Md = {
          Esc: "Escape",
          Spacebar: " ",
          Left: "ArrowLeft",
          Up: "ArrowUp",
          Right: "ArrowRight",
          Down: "ArrowDown",
          Del: "Delete",
          Win: "OS",
          Menu: "ContextMenu",
          Apps: "ContextMenu",
          Scroll: "ScrollLock",
          MozPrintableKey: "Unidentified",
        },
        Nd = {
          8: "Backspace",
          9: "Tab",
          12: "Clear",
          13: "Enter",
          16: "Shift",
          17: "Control",
          18: "Alt",
          19: "Pause",
          20: "CapsLock",
          27: "Escape",
          32: " ",
          33: "PageUp",
          34: "PageDown",
          35: "End",
          36: "Home",
          37: "ArrowLeft",
          38: "ArrowUp",
          39: "ArrowRight",
          40: "ArrowDown",
          45: "Insert",
          46: "Delete",
          112: "F1",
          113: "F2",
          114: "F3",
          115: "F4",
          116: "F5",
          117: "F6",
          118: "F7",
          119: "F8",
          120: "F9",
          121: "F10",
          122: "F11",
          123: "F12",
          144: "NumLock",
          145: "ScrollLock",
          224: "Meta",
        },
        Od = {
          Alt: "altKey",
          Control: "ctrlKey",
          Meta: "metaKey",
          Shift: "shiftKey",
        };
      function Pd(a) {
        var b = this.nativeEvent;
        return b.getModifierState
          ? b.getModifierState(a)
          : (a = Od[a])
            ? !!b[a]
            : false;
      }
      function zd() {
        return Pd;
      }
      var Qd = A({}, ud, {
          key: function (a) {
            if (a.key) {
              var b = Md[a.key] || a.key;
              if ("Unidentified" !== b) return b;
            }
            return "keypress" === a.type
              ? ((a = od(a)), 13 === a ? "Enter" : String.fromCharCode(a))
              : "keydown" === a.type || "keyup" === a.type
                ? Nd[a.keyCode] || "Unidentified"
                : "";
          },
          code: 0,
          location: 0,
          ctrlKey: 0,
          shiftKey: 0,
          altKey: 0,
          metaKey: 0,
          repeat: 0,
          locale: 0,
          getModifierState: zd,
          charCode: function (a) {
            return "keypress" === a.type ? od(a) : 0;
          },
          keyCode: function (a) {
            return "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
          },
          which: function (a) {
            return "keypress" === a.type
              ? od(a)
              : "keydown" === a.type || "keyup" === a.type
                ? a.keyCode
                : 0;
          },
        }),
        Rd = rd(Qd),
        Sd = A({}, Ad, {
          pointerId: 0,
          width: 0,
          height: 0,
          pressure: 0,
          tangentialPressure: 0,
          tiltX: 0,
          tiltY: 0,
          twist: 0,
          pointerType: 0,
          isPrimary: 0,
        }),
        Td = rd(Sd),
        Ud = A({}, ud, {
          touches: 0,
          targetTouches: 0,
          changedTouches: 0,
          altKey: 0,
          metaKey: 0,
          ctrlKey: 0,
          shiftKey: 0,
          getModifierState: zd,
        }),
        Vd = rd(Ud),
        Wd = A({}, sd, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }),
        Xd = rd(Wd),
        Yd = A({}, Ad, {
          deltaX: function (a) {
            return "deltaX" in a
              ? a.deltaX
              : "wheelDeltaX" in a
                ? -a.wheelDeltaX
                : 0;
          },
          deltaY: function (a) {
            return "deltaY" in a
              ? a.deltaY
              : "wheelDeltaY" in a
                ? -a.wheelDeltaY
                : "wheelDelta" in a
                  ? -a.wheelDelta
                  : 0;
          },
          deltaZ: 0,
          deltaMode: 0,
        }),
        Zd = rd(Yd),
        $d = [9, 13, 27, 32],
        ae$1 = ia && "CompositionEvent" in window,
        be$1 = null;
      ia && "documentMode" in document && (be$1 = document.documentMode);
      var ce$1 = ia && "TextEvent" in window && !be$1,
        de$1 = ia && (!ae$1 || (be$1 && 8 < be$1 && 11 >= be$1)),
        ee$1 = String.fromCharCode(32),
        fe = false;
      function ge$1(a, b) {
        switch (a) {
          case "keyup":
            return -1 !== $d.indexOf(b.keyCode);
          case "keydown":
            return 229 !== b.keyCode;
          case "keypress":
          case "mousedown":
          case "focusout":
            return true;
          default:
            return false;
        }
      }
      function he$1(a) {
        a = a.detail;
        return "object" === typeof a && "data" in a ? a.data : null;
      }
      var ie$1 = false;
      function je(a, b) {
        switch (a) {
          case "compositionend":
            return he$1(b);
          case "keypress":
            if (32 !== b.which) return null;
            fe = true;
            return ee$1;
          case "textInput":
            return ((a = b.data), a === ee$1 && fe ? null : a);
          default:
            return null;
        }
      }
      function ke(a, b) {
        if (ie$1)
          return "compositionend" === a || (!ae$1 && ge$1(a, b))
            ? ((a = nd()), (md = ld = kd = null), (ie$1 = false), a)
            : null;
        switch (a) {
          case "paste":
            return null;
          case "keypress":
            if (
              !(b.ctrlKey || b.altKey || b.metaKey) ||
              (b.ctrlKey && b.altKey)
            ) {
              if (b.char && 1 < b.char.length) return b.char;
              if (b.which) return String.fromCharCode(b.which);
            }
            return null;
          case "compositionend":
            return de$1 && "ko" !== b.locale ? null : b.data;
          default:
            return null;
        }
      }
      var le$1 = {
        color: true,
        date: true,
        datetime: true,
        "datetime-local": true,
        email: true,
        month: true,
        number: true,
        password: true,
        range: true,
        search: true,
        tel: true,
        text: true,
        time: true,
        url: true,
        week: true,
      };
      function me$1(a) {
        var b = a && a.nodeName && a.nodeName.toLowerCase();
        return "input" === b ? !!le$1[a.type] : "textarea" === b ? true : false;
      }
      function ne$1(a, b, c, d) {
        Eb(d);
        b = oe$1(b, "onChange");
        0 < b.length &&
          ((c = new td("onChange", "change", null, c, d)),
          a.push({ event: c, listeners: b }));
      }
      var pe$1 = null,
        qe = null;
      function re(a) {
        se$1(a, 0);
      }
      function te$1(a) {
        var b = ue(a);
        if (Wa(b)) return a;
      }
      function ve$1(a, b) {
        if ("change" === a) return b;
      }
      var we$1 = false;
      if (ia) {
        var xe$1;
        if (ia) {
          var ye$1 = "oninput" in document;
          if (!ye$1) {
            var ze = document.createElement("div");
            ze.setAttribute("oninput", "return;");
            ye$1 = "function" === typeof ze.oninput;
          }
          xe$1 = ye$1;
        } else xe$1 = false;
        we$1 = xe$1 && (!document.documentMode || 9 < document.documentMode);
      }
      function Ae() {
        pe$1 && (pe$1.detachEvent("onpropertychange", Be), (qe = pe$1 = null));
      }
      function Be(a) {
        if ("value" === a.propertyName && te$1(qe)) {
          var b = [];
          ne$1(b, qe, a, xb(a));
          Jb(re, b);
        }
      }
      function Ce(a, b, c) {
        "focusin" === a
          ? (Ae(),
            (pe$1 = b),
            (qe = c),
            pe$1.attachEvent("onpropertychange", Be))
          : "focusout" === a && Ae();
      }
      function De(a) {
        if ("selectionchange" === a || "keyup" === a || "keydown" === a)
          return te$1(qe);
      }
      function Ee(a, b) {
        if ("click" === a) return te$1(b);
      }
      function Fe(a, b) {
        if ("input" === a || "change" === a) return te$1(b);
      }
      function Ge(a, b) {
        return (
          (a === b && (0 !== a || 1 / a === 1 / b)) || (a !== a && b !== b)
        );
      }
      var He = "function" === typeof Object.is ? Object.is : Ge;
      function Ie(a, b) {
        if (He(a, b)) return true;
        if (
          "object" !== typeof a ||
          null === a ||
          "object" !== typeof b ||
          null === b
        )
          return false;
        var c = Object.keys(a),
          d = Object.keys(b);
        if (c.length !== d.length) return false;
        for (d = 0; d < c.length; d++) {
          var e = c[d];
          if (!ja.call(b, e) || !He(a[e], b[e])) return false;
        }
        return true;
      }
      function Je(a) {
        for (; a && a.firstChild; ) a = a.firstChild;
        return a;
      }
      function Ke(a, b) {
        var c = Je(a);
        a = 0;
        for (var d; c; ) {
          if (3 === c.nodeType) {
            d = a + c.textContent.length;
            if (a <= b && d >= b) return { node: c, offset: b - a };
            a = d;
          }
          a: {
            for (; c; ) {
              if (c.nextSibling) {
                c = c.nextSibling;
                break a;
              }
              c = c.parentNode;
            }
            c = void 0;
          }
          c = Je(c);
        }
      }
      function Le(a, b) {
        return a && b
          ? a === b
            ? true
            : a && 3 === a.nodeType
              ? false
              : b && 3 === b.nodeType
                ? Le(a, b.parentNode)
                : "contains" in a
                  ? a.contains(b)
                  : a.compareDocumentPosition
                    ? !!(a.compareDocumentPosition(b) & 16)
                    : false
          : false;
      }
      function Me() {
        for (var a = window, b = Xa(); b instanceof a.HTMLIFrameElement; ) {
          try {
            var c = "string" === typeof b.contentWindow.location.href;
          } catch (d) {
            c = false;
          }
          if (c) a = b.contentWindow;
          else break;
          b = Xa(a.document);
        }
        return b;
      }
      function Ne(a) {
        var b = a && a.nodeName && a.nodeName.toLowerCase();
        return (
          b &&
          (("input" === b &&
            ("text" === a.type ||
              "search" === a.type ||
              "tel" === a.type ||
              "url" === a.type ||
              "password" === a.type)) ||
            "textarea" === b ||
            "true" === a.contentEditable)
        );
      }
      function Oe(a) {
        var b = Me(),
          c = a.focusedElem,
          d = a.selectionRange;
        if (
          b !== c &&
          c &&
          c.ownerDocument &&
          Le(c.ownerDocument.documentElement, c)
        ) {
          if (null !== d && Ne(c))
            if (
              ((b = d.start),
              (a = d.end),
              void 0 === a && (a = b),
              "selectionStart" in c)
            )
              ((c.selectionStart = b),
                (c.selectionEnd = Math.min(a, c.value.length)));
            else if (
              ((a =
                ((b = c.ownerDocument || document) && b.defaultView) || window),
              a.getSelection)
            ) {
              a = a.getSelection();
              var e = c.textContent.length,
                f = Math.min(d.start, e);
              d = void 0 === d.end ? f : Math.min(d.end, e);
              !a.extend && f > d && ((e = d), (d = f), (f = e));
              e = Ke(c, f);
              var g = Ke(c, d);
              e &&
                g &&
                (1 !== a.rangeCount ||
                  a.anchorNode !== e.node ||
                  a.anchorOffset !== e.offset ||
                  a.focusNode !== g.node ||
                  a.focusOffset !== g.offset) &&
                ((b = b.createRange()),
                b.setStart(e.node, e.offset),
                a.removeAllRanges(),
                f > d
                  ? (a.addRange(b), a.extend(g.node, g.offset))
                  : (b.setEnd(g.node, g.offset), a.addRange(b)));
            }
          b = [];
          for (a = c; (a = a.parentNode); )
            1 === a.nodeType &&
              b.push({ element: a, left: a.scrollLeft, top: a.scrollTop });
          "function" === typeof c.focus && c.focus();
          for (c = 0; c < b.length; c++)
            ((a = b[c]),
              (a.element.scrollLeft = a.left),
              (a.element.scrollTop = a.top));
        }
      }
      var Pe = ia && "documentMode" in document && 11 >= document.documentMode,
        Qe = null,
        Re = null,
        Se = null,
        Te$1 = false;
      function Ue(a, b, c) {
        var d =
          c.window === c ? c.document : 9 === c.nodeType ? c : c.ownerDocument;
        Te$1 ||
          null == Qe ||
          Qe !== Xa(d) ||
          ((d = Qe),
          "selectionStart" in d && Ne(d)
            ? (d = { start: d.selectionStart, end: d.selectionEnd })
            : ((d = (
                (d.ownerDocument && d.ownerDocument.defaultView) ||
                window
              ).getSelection()),
              (d = {
                anchorNode: d.anchorNode,
                anchorOffset: d.anchorOffset,
                focusNode: d.focusNode,
                focusOffset: d.focusOffset,
              })),
          (Se && Ie(Se, d)) ||
            ((Se = d),
            (d = oe$1(Re, "onSelect")),
            0 < d.length &&
              ((b = new td("onSelect", "select", null, b, c)),
              a.push({ event: b, listeners: d }),
              (b.target = Qe))));
      }
      function Ve(a, b) {
        var c = {};
        c[a.toLowerCase()] = b.toLowerCase();
        c["Webkit" + a] = "webkit" + b;
        c["Moz" + a] = "moz" + b;
        return c;
      }
      var We = {
          animationend: Ve("Animation", "AnimationEnd"),
          animationiteration: Ve("Animation", "AnimationIteration"),
          animationstart: Ve("Animation", "AnimationStart"),
          transitionend: Ve("Transition", "TransitionEnd"),
        },
        Xe = {},
        Ye = {};
      ia &&
        ((Ye = document.createElement("div").style),
        "AnimationEvent" in window ||
          (delete We.animationend.animation,
          delete We.animationiteration.animation,
          delete We.animationstart.animation),
        "TransitionEvent" in window || delete We.transitionend.transition);
      function Ze(a) {
        if (Xe[a]) return Xe[a];
        if (!We[a]) return a;
        var b = We[a],
          c;
        for (c in b) if (b.hasOwnProperty(c) && c in Ye) return (Xe[a] = b[c]);
        return a;
      }
      var $e$1 = Ze("animationend"),
        af = Ze("animationiteration"),
        bf = Ze("animationstart"),
        cf = Ze("transitionend"),
        df = new Map(),
        ef =
          "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(
            " ",
          );
      function ff(a, b) {
        df.set(a, b);
        fa(b, [a]);
      }
      for (var gf = 0; gf < ef.length; gf++) {
        var hf = ef[gf],
          jf = hf.toLowerCase(),
          kf = hf[0].toUpperCase() + hf.slice(1);
        ff(jf, "on" + kf);
      }
      ff($e$1, "onAnimationEnd");
      ff(af, "onAnimationIteration");
      ff(bf, "onAnimationStart");
      ff("dblclick", "onDoubleClick");
      ff("focusin", "onFocus");
      ff("focusout", "onBlur");
      ff(cf, "onTransitionEnd");
      ha("onMouseEnter", ["mouseout", "mouseover"]);
      ha("onMouseLeave", ["mouseout", "mouseover"]);
      ha("onPointerEnter", ["pointerout", "pointerover"]);
      ha("onPointerLeave", ["pointerout", "pointerover"]);
      fa(
        "onChange",
        "change click focusin focusout input keydown keyup selectionchange".split(
          " ",
        ),
      );
      fa(
        "onSelect",
        "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(
          " ",
        ),
      );
      fa("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
      fa(
        "onCompositionEnd",
        "compositionend focusout keydown keypress keyup mousedown".split(" "),
      );
      fa(
        "onCompositionStart",
        "compositionstart focusout keydown keypress keyup mousedown".split(" "),
      );
      fa(
        "onCompositionUpdate",
        "compositionupdate focusout keydown keypress keyup mousedown".split(
          " ",
        ),
      );
      var lf =
          "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(
            " ",
          ),
        mf = new Set(
          "cancel close invalid load scroll toggle".split(" ").concat(lf),
        );
      function nf(a, b, c) {
        var d = a.type || "unknown-event";
        a.currentTarget = c;
        Ub(d, b, void 0, a);
        a.currentTarget = null;
      }
      function se$1(a, b) {
        b = 0 !== (b & 4);
        for (var c = 0; c < a.length; c++) {
          var d = a[c],
            e = d.event;
          d = d.listeners;
          a: {
            var f = void 0;
            if (b)
              for (var g = d.length - 1; 0 <= g; g--) {
                var h = d[g],
                  k = h.instance,
                  l = h.currentTarget;
                h = h.listener;
                if (k !== f && e.isPropagationStopped()) break a;
                nf(e, h, l);
                f = k;
              }
            else
              for (g = 0; g < d.length; g++) {
                h = d[g];
                k = h.instance;
                l = h.currentTarget;
                h = h.listener;
                if (k !== f && e.isPropagationStopped()) break a;
                nf(e, h, l);
                f = k;
              }
          }
        }
        if (Qb) throw ((a = Rb), (Qb = false), (Rb = null), a);
      }
      function D$1(a, b) {
        var c = b[of];
        void 0 === c && (c = b[of] = new Set());
        var d = a + "__bubble";
        c.has(d) || (pf(b, a, 2, false), c.add(d));
      }
      function qf(a, b, c) {
        var d = 0;
        b && (d |= 4);
        pf(c, a, d, b);
      }
      var rf = "_reactListening" + Math.random().toString(36).slice(2);
      function sf(a) {
        if (!a[rf]) {
          a[rf] = true;
          da.forEach(function (b) {
            "selectionchange" !== b &&
              (mf.has(b) || qf(b, false, a), qf(b, true, a));
          });
          var b = 9 === a.nodeType ? a : a.ownerDocument;
          null === b ||
            b[rf] ||
            ((b[rf] = true), qf("selectionchange", false, b));
        }
      }
      function pf(a, b, c, d) {
        switch (jd(b)) {
          case 1:
            var e = ed;
            break;
          case 4:
            e = gd;
            break;
          default:
            e = fd;
        }
        c = e.bind(null, b, c, a);
        e = void 0;
        !Lb ||
          ("touchstart" !== b && "touchmove" !== b && "wheel" !== b) ||
          (e = true);
        d
          ? void 0 !== e
            ? a.addEventListener(b, c, { capture: true, passive: e })
            : a.addEventListener(b, c, true)
          : void 0 !== e
            ? a.addEventListener(b, c, { passive: e })
            : a.addEventListener(b, c, false);
      }
      function hd(a, b, c, d, e) {
        var f = d;
        if (0 === (b & 1) && 0 === (b & 2) && null !== d)
          a: for (;;) {
            if (null === d) return;
            var g = d.tag;
            if (3 === g || 4 === g) {
              var h = d.stateNode.containerInfo;
              if (h === e || (8 === h.nodeType && h.parentNode === e)) break;
              if (4 === g)
                for (g = d.return; null !== g; ) {
                  var k = g.tag;
                  if (3 === k || 4 === k)
                    if (
                      ((k = g.stateNode.containerInfo),
                      k === e || (8 === k.nodeType && k.parentNode === e))
                    )
                      return;
                  g = g.return;
                }
              for (; null !== h; ) {
                g = Wc(h);
                if (null === g) return;
                k = g.tag;
                if (5 === k || 6 === k) {
                  d = f = g;
                  continue a;
                }
                h = h.parentNode;
              }
            }
            d = d.return;
          }
        Jb(function () {
          var d = f,
            e = xb(c),
            g = [];
          a: {
            var h = df.get(a);
            if (void 0 !== h) {
              var k = td,
                n = a;
              switch (a) {
                case "keypress":
                  if (0 === od(c)) break a;
                case "keydown":
                case "keyup":
                  k = Rd;
                  break;
                case "focusin":
                  n = "focus";
                  k = Fd;
                  break;
                case "focusout":
                  n = "blur";
                  k = Fd;
                  break;
                case "beforeblur":
                case "afterblur":
                  k = Fd;
                  break;
                case "click":
                  if (2 === c.button) break a;
                case "auxclick":
                case "dblclick":
                case "mousedown":
                case "mousemove":
                case "mouseup":
                case "mouseout":
                case "mouseover":
                case "contextmenu":
                  k = Bd;
                  break;
                case "drag":
                case "dragend":
                case "dragenter":
                case "dragexit":
                case "dragleave":
                case "dragover":
                case "dragstart":
                case "drop":
                  k = Dd;
                  break;
                case "touchcancel":
                case "touchend":
                case "touchmove":
                case "touchstart":
                  k = Vd;
                  break;
                case $e$1:
                case af:
                case bf:
                  k = Hd;
                  break;
                case cf:
                  k = Xd;
                  break;
                case "scroll":
                  k = vd;
                  break;
                case "wheel":
                  k = Zd;
                  break;
                case "copy":
                case "cut":
                case "paste":
                  k = Jd;
                  break;
                case "gotpointercapture":
                case "lostpointercapture":
                case "pointercancel":
                case "pointerdown":
                case "pointermove":
                case "pointerout":
                case "pointerover":
                case "pointerup":
                  k = Td;
              }
              var t = 0 !== (b & 4),
                J = !t && "scroll" === a,
                x = t ? (null !== h ? h + "Capture" : null) : h;
              t = [];
              for (var w = d, u; null !== w; ) {
                u = w;
                var F = u.stateNode;
                5 === u.tag &&
                  null !== F &&
                  ((u = F),
                  null !== x &&
                    ((F = Kb(w, x)), null != F && t.push(tf(w, F, u))));
                if (J) break;
                w = w.return;
              }
              0 < t.length &&
                ((h = new k(h, n, null, c, e)),
                g.push({ event: h, listeners: t }));
            }
          }
          if (0 === (b & 7)) {
            a: {
              h = "mouseover" === a || "pointerover" === a;
              k = "mouseout" === a || "pointerout" === a;
              if (
                h &&
                c !== wb &&
                (n = c.relatedTarget || c.fromElement) &&
                (Wc(n) || n[uf])
              )
                break a;
              if (k || h) {
                h =
                  e.window === e
                    ? e
                    : (h = e.ownerDocument)
                      ? h.defaultView || h.parentWindow
                      : window;
                if (k) {
                  if (
                    ((n = c.relatedTarget || c.toElement),
                    (k = d),
                    (n = n ? Wc(n) : null),
                    null !== n &&
                      ((J = Vb(n)), n !== J || (5 !== n.tag && 6 !== n.tag)))
                  )
                    n = null;
                } else ((k = null), (n = d));
                if (k !== n) {
                  t = Bd;
                  F = "onMouseLeave";
                  x = "onMouseEnter";
                  w = "mouse";
                  if ("pointerout" === a || "pointerover" === a)
                    ((t = Td),
                      (F = "onPointerLeave"),
                      (x = "onPointerEnter"),
                      (w = "pointer"));
                  J = null == k ? h : ue(k);
                  u = null == n ? h : ue(n);
                  h = new t(F, w + "leave", k, c, e);
                  h.target = J;
                  h.relatedTarget = u;
                  F = null;
                  Wc(e) === d &&
                    ((t = new t(x, w + "enter", n, c, e)),
                    (t.target = u),
                    (t.relatedTarget = J),
                    (F = t));
                  J = F;
                  if (k && n)
                    b: {
                      t = k;
                      x = n;
                      w = 0;
                      for (u = t; u; u = vf(u)) w++;
                      u = 0;
                      for (F = x; F; F = vf(F)) u++;
                      for (; 0 < w - u; ) ((t = vf(t)), w--);
                      for (; 0 < u - w; ) ((x = vf(x)), u--);
                      for (; w--; ) {
                        if (t === x || (null !== x && t === x.alternate))
                          break b;
                        t = vf(t);
                        x = vf(x);
                      }
                      t = null;
                    }
                  else t = null;
                  null !== k && wf(g, h, k, t, false);
                  null !== n && null !== J && wf(g, J, n, t, true);
                }
              }
            }
            a: {
              h = d ? ue(d) : window;
              k = h.nodeName && h.nodeName.toLowerCase();
              if ("select" === k || ("input" === k && "file" === h.type))
                var na = ve$1;
              else if (me$1(h))
                if (we$1) na = Fe;
                else {
                  na = De;
                  var xa = Ce;
                }
              else
                (k = h.nodeName) &&
                  "input" === k.toLowerCase() &&
                  ("checkbox" === h.type || "radio" === h.type) &&
                  (na = Ee);
              if (na && (na = na(a, d))) {
                ne$1(g, na, c, e);
                break a;
              }
              xa && xa(a, h, d);
              "focusout" === a &&
                (xa = h._wrapperState) &&
                xa.controlled &&
                "number" === h.type &&
                cb(h, "number", h.value);
            }
            xa = d ? ue(d) : window;
            switch (a) {
              case "focusin":
                if (me$1(xa) || "true" === xa.contentEditable)
                  ((Qe = xa), (Re = d), (Se = null));
                break;
              case "focusout":
                Se = Re = Qe = null;
                break;
              case "mousedown":
                Te$1 = true;
                break;
              case "contextmenu":
              case "mouseup":
              case "dragend":
                Te$1 = false;
                Ue(g, c, e);
                break;
              case "selectionchange":
                if (Pe) break;
              case "keydown":
              case "keyup":
                Ue(g, c, e);
            }
            var $a;
            if (ae$1)
              b: {
                switch (a) {
                  case "compositionstart":
                    var ba = "onCompositionStart";
                    break b;
                  case "compositionend":
                    ba = "onCompositionEnd";
                    break b;
                  case "compositionupdate":
                    ba = "onCompositionUpdate";
                    break b;
                }
                ba = void 0;
              }
            else
              ie$1
                ? ge$1(a, c) && (ba = "onCompositionEnd")
                : "keydown" === a &&
                  229 === c.keyCode &&
                  (ba = "onCompositionStart");
            ba &&
              (de$1 &&
                "ko" !== c.locale &&
                (ie$1 || "onCompositionStart" !== ba
                  ? "onCompositionEnd" === ba && ie$1 && ($a = nd())
                  : ((kd = e),
                    (ld = "value" in kd ? kd.value : kd.textContent),
                    (ie$1 = true))),
              (xa = oe$1(d, ba)),
              0 < xa.length &&
                ((ba = new Ld(ba, a, null, c, e)),
                g.push({ event: ba, listeners: xa }),
                $a
                  ? (ba.data = $a)
                  : (($a = he$1(c)), null !== $a && (ba.data = $a))));
            if (($a = ce$1 ? je(a, c) : ke(a, c)))
              ((d = oe$1(d, "onBeforeInput")),
                0 < d.length &&
                  ((e = new Ld("onBeforeInput", "beforeinput", null, c, e)),
                  g.push({ event: e, listeners: d }),
                  (e.data = $a)));
          }
          se$1(g, b);
        });
      }
      function tf(a, b, c) {
        return { instance: a, listener: b, currentTarget: c };
      }
      function oe$1(a, b) {
        for (var c = b + "Capture", d = []; null !== a; ) {
          var e = a,
            f = e.stateNode;
          5 === e.tag &&
            null !== f &&
            ((e = f),
            (f = Kb(a, c)),
            null != f && d.unshift(tf(a, f, e)),
            (f = Kb(a, b)),
            null != f && d.push(tf(a, f, e)));
          a = a.return;
        }
        return d;
      }
      function vf(a) {
        if (null === a) return null;
        do a = a.return;
        while (a && 5 !== a.tag);
        return a ? a : null;
      }
      function wf(a, b, c, d, e) {
        for (var f = b._reactName, g = []; null !== c && c !== d; ) {
          var h = c,
            k = h.alternate,
            l = h.stateNode;
          if (null !== k && k === d) break;
          5 === h.tag &&
            null !== l &&
            ((h = l),
            e
              ? ((k = Kb(c, f)), null != k && g.unshift(tf(c, k, h)))
              : e || ((k = Kb(c, f)), null != k && g.push(tf(c, k, h))));
          c = c.return;
        }
        0 !== g.length && a.push({ event: b, listeners: g });
      }
      var xf = /\r\n?/g,
        yf = /\u0000|\uFFFD/g;
      function zf(a) {
        return ("string" === typeof a ? a : "" + a)
          .replace(xf, "\n")
          .replace(yf, "");
      }
      function Af(a, b, c) {
        b = zf(b);
        if (zf(a) !== b && c) throw Error(p(425));
      }
      function Bf() {}
      var Cf = null,
        Df = null;
      function Ef(a, b) {
        return (
          "textarea" === a ||
          "noscript" === a ||
          "string" === typeof b.children ||
          "number" === typeof b.children ||
          ("object" === typeof b.dangerouslySetInnerHTML &&
            null !== b.dangerouslySetInnerHTML &&
            null != b.dangerouslySetInnerHTML.__html)
        );
      }
      var Ff = "function" === typeof setTimeout ? setTimeout : void 0,
        Gf = "function" === typeof clearTimeout ? clearTimeout : void 0,
        Hf = "function" === typeof Promise ? Promise : void 0,
        Jf =
          "function" === typeof queueMicrotask
            ? queueMicrotask
            : "undefined" !== typeof Hf
              ? function (a) {
                  return Hf.resolve(null).then(a).catch(If);
                }
              : Ff;
      function If(a) {
        setTimeout(function () {
          throw a;
        });
      }
      function Kf(a, b) {
        var c = b,
          d = 0;
        do {
          var e = c.nextSibling;
          a.removeChild(c);
          if (e && 8 === e.nodeType)
            if (((c = e.data), "/$" === c)) {
              if (0 === d) {
                a.removeChild(e);
                bd(b);
                return;
              }
              d--;
            } else ("$" !== c && "$?" !== c && "$!" !== c) || d++;
          c = e;
        } while (c);
        bd(b);
      }
      function Lf(a) {
        for (; null != a; a = a.nextSibling) {
          var b = a.nodeType;
          if (1 === b || 3 === b) break;
          if (8 === b) {
            b = a.data;
            if ("$" === b || "$!" === b || "$?" === b) break;
            if ("/$" === b) return null;
          }
        }
        return a;
      }
      function Mf(a) {
        a = a.previousSibling;
        for (var b = 0; a; ) {
          if (8 === a.nodeType) {
            var c = a.data;
            if ("$" === c || "$!" === c || "$?" === c) {
              if (0 === b) return a;
              b--;
            } else "/$" === c && b++;
          }
          a = a.previousSibling;
        }
        return null;
      }
      var Nf = Math.random().toString(36).slice(2),
        Of = "__reactFiber$" + Nf,
        Pf = "__reactProps$" + Nf,
        uf = "__reactContainer$" + Nf,
        of = "__reactEvents$" + Nf,
        Qf = "__reactListeners$" + Nf,
        Rf = "__reactHandles$" + Nf;
      function Wc(a) {
        var b = a[Of];
        if (b) return b;
        for (var c = a.parentNode; c; ) {
          if ((b = c[uf] || c[Of])) {
            c = b.alternate;
            if (null !== b.child || (null !== c && null !== c.child))
              for (a = Mf(a); null !== a; ) {
                if ((c = a[Of])) return c;
                a = Mf(a);
              }
            return b;
          }
          a = c;
          c = a.parentNode;
        }
        return null;
      }
      function Cb(a) {
        a = a[Of] || a[uf];
        return !a || (5 !== a.tag && 6 !== a.tag && 13 !== a.tag && 3 !== a.tag)
          ? null
          : a;
      }
      function ue(a) {
        if (5 === a.tag || 6 === a.tag) return a.stateNode;
        throw Error(p(33));
      }
      function Db(a) {
        return a[Pf] || null;
      }
      var Sf = [],
        Tf = -1;
      function Uf(a) {
        return { current: a };
      }
      function E$1(a) {
        0 > Tf || ((a.current = Sf[Tf]), (Sf[Tf] = null), Tf--);
      }
      function G(a, b) {
        Tf++;
        Sf[Tf] = a.current;
        a.current = b;
      }
      var Vf = {},
        H = Uf(Vf),
        Wf = Uf(false),
        Xf = Vf;
      function Yf(a, b) {
        var c = a.type.contextTypes;
        if (!c) return Vf;
        var d = a.stateNode;
        if (d && d.__reactInternalMemoizedUnmaskedChildContext === b)
          return d.__reactInternalMemoizedMaskedChildContext;
        var e = {},
          f;
        for (f in c) e[f] = b[f];
        d &&
          ((a = a.stateNode),
          (a.__reactInternalMemoizedUnmaskedChildContext = b),
          (a.__reactInternalMemoizedMaskedChildContext = e));
        return e;
      }
      function Zf(a) {
        a = a.childContextTypes;
        return null !== a && void 0 !== a;
      }
      function $f() {
        E$1(Wf);
        E$1(H);
      }
      function ag(a, b, c) {
        if (H.current !== Vf) throw Error(p(168));
        G(H, b);
        G(Wf, c);
      }
      function bg(a, b, c) {
        var d = a.stateNode;
        b = b.childContextTypes;
        if ("function" !== typeof d.getChildContext) return c;
        d = d.getChildContext();
        for (var e in d)
          if (!(e in b)) throw Error(p(108, Ra(a) || "Unknown", e));
        return A({}, c, d);
      }
      function cg(a) {
        a =
          ((a = a.stateNode) && a.__reactInternalMemoizedMergedChildContext) ||
          Vf;
        Xf = H.current;
        G(H, a);
        G(Wf, Wf.current);
        return true;
      }
      function dg(a, b, c) {
        var d = a.stateNode;
        if (!d) throw Error(p(169));
        c
          ? ((a = bg(a, b, Xf)),
            (d.__reactInternalMemoizedMergedChildContext = a),
            E$1(Wf),
            E$1(H),
            G(H, a))
          : E$1(Wf);
        G(Wf, c);
      }
      var eg = null,
        fg = false,
        gg = false;
      function hg(a) {
        null === eg ? (eg = [a]) : eg.push(a);
      }
      function ig(a) {
        fg = true;
        hg(a);
      }
      function jg() {
        if (!gg && null !== eg) {
          gg = true;
          var a = 0,
            b = C;
          try {
            var c = eg;
            for (C = 1; a < c.length; a++) {
              var d = c[a];
              do d = d(!0);
              while (null !== d);
            }
            eg = null;
            fg = !1;
          } catch (e) {
            throw (null !== eg && (eg = eg.slice(a + 1)), ac(fc, jg), e);
          } finally {
            ((C = b), (gg = false));
          }
        }
        return null;
      }
      var kg = [],
        lg = 0,
        mg = null,
        ng = 0,
        og = [],
        pg = 0,
        qg = null,
        rg = 1,
        sg = "";
      function tg(a, b) {
        kg[lg++] = ng;
        kg[lg++] = mg;
        mg = a;
        ng = b;
      }
      function ug(a, b, c) {
        og[pg++] = rg;
        og[pg++] = sg;
        og[pg++] = qg;
        qg = a;
        var d = rg;
        a = sg;
        var e = 32 - oc(d) - 1;
        d &= ~(1 << e);
        c += 1;
        var f = 32 - oc(b) + e;
        if (30 < f) {
          var g = e - (e % 5);
          f = (d & ((1 << g) - 1)).toString(32);
          d >>= g;
          e -= g;
          rg = (1 << (32 - oc(b) + e)) | (c << e) | d;
          sg = f + a;
        } else ((rg = (1 << f) | (c << e) | d), (sg = a));
      }
      function vg(a) {
        null !== a.return && (tg(a, 1), ug(a, 1, 0));
      }
      function wg(a) {
        for (; a === mg; )
          ((mg = kg[--lg]), (kg[lg] = null), (ng = kg[--lg]), (kg[lg] = null));
        for (; a === qg; )
          ((qg = og[--pg]),
            (og[pg] = null),
            (sg = og[--pg]),
            (og[pg] = null),
            (rg = og[--pg]),
            (og[pg] = null));
      }
      var xg = null,
        yg = null,
        I = false,
        zg = null;
      function Ag(a, b) {
        var c = Bg(5, null, null, 0);
        c.elementType = "DELETED";
        c.stateNode = b;
        c.return = a;
        b = a.deletions;
        null === b ? ((a.deletions = [c]), (a.flags |= 16)) : b.push(c);
      }
      function Cg(a, b) {
        switch (a.tag) {
          case 5:
            var c = a.type;
            b =
              1 !== b.nodeType || c.toLowerCase() !== b.nodeName.toLowerCase()
                ? null
                : b;
            return null !== b
              ? ((a.stateNode = b), (xg = a), (yg = Lf(b.firstChild)), true)
              : false;
          case 6:
            return (
              (b = "" === a.pendingProps || 3 !== b.nodeType ? null : b),
              null !== b
                ? ((a.stateNode = b), (xg = a), (yg = null), true)
                : false
            );
          case 13:
            return (
              (b = 8 !== b.nodeType ? null : b),
              null !== b
                ? ((c = null !== qg ? { id: rg, overflow: sg } : null),
                  (a.memoizedState = {
                    dehydrated: b,
                    treeContext: c,
                    retryLane: 1073741824,
                  }),
                  (c = Bg(18, null, null, 0)),
                  (c.stateNode = b),
                  (c.return = a),
                  (a.child = c),
                  (xg = a),
                  (yg = null),
                  true)
                : false
            );
          default:
            return false;
        }
      }
      function Dg(a) {
        return 0 !== (a.mode & 1) && 0 === (a.flags & 128);
      }
      function Eg(a) {
        if (I) {
          var b = yg;
          if (b) {
            var c = b;
            if (!Cg(a, b)) {
              if (Dg(a)) throw Error(p(418));
              b = Lf(c.nextSibling);
              var d = xg;
              b && Cg(a, b)
                ? Ag(d, c)
                : ((a.flags = (a.flags & -4097) | 2), (I = false), (xg = a));
            }
          } else {
            if (Dg(a)) throw Error(p(418));
            a.flags = (a.flags & -4097) | 2;
            I = false;
            xg = a;
          }
        }
      }
      function Fg(a) {
        for (
          a = a.return;
          null !== a && 5 !== a.tag && 3 !== a.tag && 13 !== a.tag;
        )
          a = a.return;
        xg = a;
      }
      function Gg(a) {
        if (a !== xg) return false;
        if (!I) return (Fg(a), (I = true), false);
        var b;
        (b = 3 !== a.tag) &&
          !(b = 5 !== a.tag) &&
          ((b = a.type),
          (b = "head" !== b && "body" !== b && !Ef(a.type, a.memoizedProps)));
        if (b && (b = yg)) {
          if (Dg(a)) throw (Hg(), Error(p(418)));
          for (; b; ) (Ag(a, b), (b = Lf(b.nextSibling)));
        }
        Fg(a);
        if (13 === a.tag) {
          a = a.memoizedState;
          a = null !== a ? a.dehydrated : null;
          if (!a) throw Error(p(317));
          a: {
            a = a.nextSibling;
            for (b = 0; a; ) {
              if (8 === a.nodeType) {
                var c = a.data;
                if ("/$" === c) {
                  if (0 === b) {
                    yg = Lf(a.nextSibling);
                    break a;
                  }
                  b--;
                } else ("$" !== c && "$!" !== c && "$?" !== c) || b++;
              }
              a = a.nextSibling;
            }
            yg = null;
          }
        } else yg = xg ? Lf(a.stateNode.nextSibling) : null;
        return true;
      }
      function Hg() {
        for (var a = yg; a; ) a = Lf(a.nextSibling);
      }
      function Ig() {
        yg = xg = null;
        I = false;
      }
      function Jg(a) {
        null === zg ? (zg = [a]) : zg.push(a);
      }
      var Kg = ua.ReactCurrentBatchConfig;
      function Lg(a, b, c) {
        a = c.ref;
        if (null !== a && "function" !== typeof a && "object" !== typeof a) {
          if (c._owner) {
            c = c._owner;
            if (c) {
              if (1 !== c.tag) throw Error(p(309));
              var d = c.stateNode;
            }
            if (!d) throw Error(p(147, a));
            var e = d,
              f = "" + a;
            if (
              null !== b &&
              null !== b.ref &&
              "function" === typeof b.ref &&
              b.ref._stringRef === f
            )
              return b.ref;
            b = function (a) {
              var b = e.refs;
              null === a ? delete b[f] : (b[f] = a);
            };
            b._stringRef = f;
            return b;
          }
          if ("string" !== typeof a) throw Error(p(284));
          if (!c._owner) throw Error(p(290, a));
        }
        return a;
      }
      function Mg(a, b) {
        a = Object.prototype.toString.call(b);
        throw Error(
          p(
            31,
            "[object Object]" === a
              ? "object with keys {" + Object.keys(b).join(", ") + "}"
              : a,
          ),
        );
      }
      function Ng(a) {
        var b = a._init;
        return b(a._payload);
      }
      function Og(a) {
        function b(b, c) {
          if (a) {
            var d = b.deletions;
            null === d ? ((b.deletions = [c]), (b.flags |= 16)) : d.push(c);
          }
        }
        function c(c, d) {
          if (!a) return null;
          for (; null !== d; ) (b(c, d), (d = d.sibling));
          return null;
        }
        function d(a, b) {
          for (a = new Map(); null !== b; )
            (null !== b.key ? a.set(b.key, b) : a.set(b.index, b),
              (b = b.sibling));
          return a;
        }
        function e(a, b) {
          a = Pg(a, b);
          a.index = 0;
          a.sibling = null;
          return a;
        }
        function f(b, c, d) {
          b.index = d;
          if (!a) return ((b.flags |= 1048576), c);
          d = b.alternate;
          if (null !== d)
            return ((d = d.index), d < c ? ((b.flags |= 2), c) : d);
          b.flags |= 2;
          return c;
        }
        function g(b) {
          a && null === b.alternate && (b.flags |= 2);
          return b;
        }
        function h(a, b, c, d) {
          if (null === b || 6 !== b.tag)
            return ((b = Qg(c, a.mode, d)), (b.return = a), b);
          b = e(b, c);
          b.return = a;
          return b;
        }
        function k(a, b, c, d) {
          var f = c.type;
          if (f === ya) return m(a, b, c.props.children, d, c.key);
          if (
            null !== b &&
            (b.elementType === f ||
              ("object" === typeof f &&
                null !== f &&
                f.$$typeof === Ha &&
                Ng(f) === b.type))
          )
            return (
              (d = e(b, c.props)),
              (d.ref = Lg(a, b, c)),
              (d.return = a),
              d
            );
          d = Rg(c.type, c.key, c.props, null, a.mode, d);
          d.ref = Lg(a, b, c);
          d.return = a;
          return d;
        }
        function l(a, b, c, d) {
          if (
            null === b ||
            4 !== b.tag ||
            b.stateNode.containerInfo !== c.containerInfo ||
            b.stateNode.implementation !== c.implementation
          )
            return ((b = Sg(c, a.mode, d)), (b.return = a), b);
          b = e(b, c.children || []);
          b.return = a;
          return b;
        }
        function m(a, b, c, d, f) {
          if (null === b || 7 !== b.tag)
            return ((b = Tg(c, a.mode, d, f)), (b.return = a), b);
          b = e(b, c);
          b.return = a;
          return b;
        }
        function q(a, b, c) {
          if (("string" === typeof b && "" !== b) || "number" === typeof b)
            return ((b = Qg("" + b, a.mode, c)), (b.return = a), b);
          if ("object" === typeof b && null !== b) {
            switch (b.$$typeof) {
              case va:
                return (
                  (c = Rg(b.type, b.key, b.props, null, a.mode, c)),
                  (c.ref = Lg(a, null, b)),
                  (c.return = a),
                  c
                );
              case wa:
                return ((b = Sg(b, a.mode, c)), (b.return = a), b);
              case Ha:
                var d = b._init;
                return q(a, d(b._payload), c);
            }
            if (eb(b) || Ka(b))
              return ((b = Tg(b, a.mode, c, null)), (b.return = a), b);
            Mg(a, b);
          }
          return null;
        }
        function r(a, b, c, d) {
          var e = null !== b ? b.key : null;
          if (("string" === typeof c && "" !== c) || "number" === typeof c)
            return null !== e ? null : h(a, b, "" + c, d);
          if ("object" === typeof c && null !== c) {
            switch (c.$$typeof) {
              case va:
                return c.key === e ? k(a, b, c, d) : null;
              case wa:
                return c.key === e ? l(a, b, c, d) : null;
              case Ha:
                return ((e = c._init), r(a, b, e(c._payload), d));
            }
            if (eb(c) || Ka(c)) return null !== e ? null : m(a, b, c, d, null);
            Mg(a, c);
          }
          return null;
        }
        function y(a, b, c, d, e) {
          if (("string" === typeof d && "" !== d) || "number" === typeof d)
            return ((a = a.get(c) || null), h(b, a, "" + d, e));
          if ("object" === typeof d && null !== d) {
            switch (d.$$typeof) {
              case va:
                return (
                  (a = a.get(null === d.key ? c : d.key) || null),
                  k(b, a, d, e)
                );
              case wa:
                return (
                  (a = a.get(null === d.key ? c : d.key) || null),
                  l(b, a, d, e)
                );
              case Ha:
                var f = d._init;
                return y(a, b, c, f(d._payload), e);
            }
            if (eb(d) || Ka(d))
              return ((a = a.get(c) || null), m(b, a, d, e, null));
            Mg(b, d);
          }
          return null;
        }
        function n(e, g, h, k) {
          for (
            var l = null, m = null, u = g, w = (g = 0), x = null;
            null !== u && w < h.length;
            w++
          ) {
            u.index > w ? ((x = u), (u = null)) : (x = u.sibling);
            var n = r(e, u, h[w], k);
            if (null === n) {
              null === u && (u = x);
              break;
            }
            a && u && null === n.alternate && b(e, u);
            g = f(n, g, w);
            null === m ? (l = n) : (m.sibling = n);
            m = n;
            u = x;
          }
          if (w === h.length) return (c(e, u), I && tg(e, w), l);
          if (null === u) {
            for (; w < h.length; w++)
              ((u = q(e, h[w], k)),
                null !== u &&
                  ((g = f(u, g, w)),
                  null === m ? (l = u) : (m.sibling = u),
                  (m = u)));
            I && tg(e, w);
            return l;
          }
          for (u = d(e, u); w < h.length; w++)
            ((x = y(u, e, w, h[w], k)),
              null !== x &&
                (a &&
                  null !== x.alternate &&
                  u.delete(null === x.key ? w : x.key),
                (g = f(x, g, w)),
                null === m ? (l = x) : (m.sibling = x),
                (m = x)));
          a &&
            u.forEach(function (a) {
              return b(e, a);
            });
          I && tg(e, w);
          return l;
        }
        function t(e, g, h, k) {
          var l = Ka(h);
          if ("function" !== typeof l) throw Error(p(150));
          h = l.call(h);
          if (null == h) throw Error(p(151));
          for (
            var u = (l = null), m = g, w = (g = 0), x = null, n = h.next();
            null !== m && !n.done;
            w++, n = h.next()
          ) {
            m.index > w ? ((x = m), (m = null)) : (x = m.sibling);
            var t = r(e, m, n.value, k);
            if (null === t) {
              null === m && (m = x);
              break;
            }
            a && m && null === t.alternate && b(e, m);
            g = f(t, g, w);
            null === u ? (l = t) : (u.sibling = t);
            u = t;
            m = x;
          }
          if (n.done) return (c(e, m), I && tg(e, w), l);
          if (null === m) {
            for (; !n.done; w++, n = h.next())
              ((n = q(e, n.value, k)),
                null !== n &&
                  ((g = f(n, g, w)),
                  null === u ? (l = n) : (u.sibling = n),
                  (u = n)));
            I && tg(e, w);
            return l;
          }
          for (m = d(e, m); !n.done; w++, n = h.next())
            ((n = y(m, e, w, n.value, k)),
              null !== n &&
                (a &&
                  null !== n.alternate &&
                  m.delete(null === n.key ? w : n.key),
                (g = f(n, g, w)),
                null === u ? (l = n) : (u.sibling = n),
                (u = n)));
          a &&
            m.forEach(function (a) {
              return b(e, a);
            });
          I && tg(e, w);
          return l;
        }
        function J(a, d, f, h) {
          "object" === typeof f &&
            null !== f &&
            f.type === ya &&
            null === f.key &&
            (f = f.props.children);
          if ("object" === typeof f && null !== f) {
            switch (f.$$typeof) {
              case va:
                a: {
                  for (var k = f.key, l = d; null !== l; ) {
                    if (l.key === k) {
                      k = f.type;
                      if (k === ya) {
                        if (7 === l.tag) {
                          c(a, l.sibling);
                          d = e(l, f.props.children);
                          d.return = a;
                          a = d;
                          break a;
                        }
                      } else if (
                        l.elementType === k ||
                        ("object" === typeof k &&
                          null !== k &&
                          k.$$typeof === Ha &&
                          Ng(k) === l.type)
                      ) {
                        c(a, l.sibling);
                        d = e(l, f.props);
                        d.ref = Lg(a, l, f);
                        d.return = a;
                        a = d;
                        break a;
                      }
                      c(a, l);
                      break;
                    } else b(a, l);
                    l = l.sibling;
                  }
                  f.type === ya
                    ? ((d = Tg(f.props.children, a.mode, h, f.key)),
                      (d.return = a),
                      (a = d))
                    : ((h = Rg(f.type, f.key, f.props, null, a.mode, h)),
                      (h.ref = Lg(a, d, f)),
                      (h.return = a),
                      (a = h));
                }
                return g(a);
              case wa:
                a: {
                  for (l = f.key; null !== d; ) {
                    if (d.key === l)
                      if (
                        4 === d.tag &&
                        d.stateNode.containerInfo === f.containerInfo &&
                        d.stateNode.implementation === f.implementation
                      ) {
                        c(a, d.sibling);
                        d = e(d, f.children || []);
                        d.return = a;
                        a = d;
                        break a;
                      } else {
                        c(a, d);
                        break;
                      }
                    else b(a, d);
                    d = d.sibling;
                  }
                  d = Sg(f, a.mode, h);
                  d.return = a;
                  a = d;
                }
                return g(a);
              case Ha:
                return ((l = f._init), J(a, d, l(f._payload), h));
            }
            if (eb(f)) return n(a, d, f, h);
            if (Ka(f)) return t(a, d, f, h);
            Mg(a, f);
          }
          return ("string" === typeof f && "" !== f) || "number" === typeof f
            ? ((f = "" + f),
              null !== d && 6 === d.tag
                ? (c(a, d.sibling), (d = e(d, f)), (d.return = a), (a = d))
                : (c(a, d), (d = Qg(f, a.mode, h)), (d.return = a), (a = d)),
              g(a))
            : c(a, d);
        }
        return J;
      }
      var Ug = Og(true),
        Vg = Og(false),
        Wg = Uf(null),
        Xg = null,
        Yg = null,
        Zg = null;
      function $g() {
        Zg = Yg = Xg = null;
      }
      function ah(a) {
        var b = Wg.current;
        E$1(Wg);
        a._currentValue = b;
      }
      function bh(a, b, c) {
        for (; null !== a; ) {
          var d = a.alternate;
          (a.childLanes & b) !== b
            ? ((a.childLanes |= b), null !== d && (d.childLanes |= b))
            : null !== d && (d.childLanes & b) !== b && (d.childLanes |= b);
          if (a === c) break;
          a = a.return;
        }
      }
      function ch(a, b) {
        Xg = a;
        Zg = Yg = null;
        a = a.dependencies;
        null !== a &&
          null !== a.firstContext &&
          (0 !== (a.lanes & b) && (dh = true), (a.firstContext = null));
      }
      function eh(a) {
        var b = a._currentValue;
        if (Zg !== a)
          if (
            ((a = { context: a, memoizedValue: b, next: null }), null === Yg)
          ) {
            if (null === Xg) throw Error(p(308));
            Yg = a;
            Xg.dependencies = { lanes: 0, firstContext: a };
          } else Yg = Yg.next = a;
        return b;
      }
      var fh = null;
      function gh(a) {
        null === fh ? (fh = [a]) : fh.push(a);
      }
      function hh(a, b, c, d) {
        var e = b.interleaved;
        null === e ? ((c.next = c), gh(b)) : ((c.next = e.next), (e.next = c));
        b.interleaved = c;
        return ih(a, d);
      }
      function ih(a, b) {
        a.lanes |= b;
        var c = a.alternate;
        null !== c && (c.lanes |= b);
        c = a;
        for (a = a.return; null !== a; )
          ((a.childLanes |= b),
            (c = a.alternate),
            null !== c && (c.childLanes |= b),
            (c = a),
            (a = a.return));
        return 3 === c.tag ? c.stateNode : null;
      }
      var jh = false;
      function kh(a) {
        a.updateQueue = {
          baseState: a.memoizedState,
          firstBaseUpdate: null,
          lastBaseUpdate: null,
          shared: { pending: null, interleaved: null, lanes: 0 },
          effects: null,
        };
      }
      function lh(a, b) {
        a = a.updateQueue;
        b.updateQueue === a &&
          (b.updateQueue = {
            baseState: a.baseState,
            firstBaseUpdate: a.firstBaseUpdate,
            lastBaseUpdate: a.lastBaseUpdate,
            shared: a.shared,
            effects: a.effects,
          });
      }
      function mh(a, b) {
        return {
          eventTime: a,
          lane: b,
          tag: 0,
          payload: null,
          callback: null,
          next: null,
        };
      }
      function nh(a, b, c) {
        var d = a.updateQueue;
        if (null === d) return null;
        d = d.shared;
        if (0 !== (K & 2)) {
          var e = d.pending;
          null === e ? (b.next = b) : ((b.next = e.next), (e.next = b));
          d.pending = b;
          return ih(a, c);
        }
        e = d.interleaved;
        null === e ? ((b.next = b), gh(d)) : ((b.next = e.next), (e.next = b));
        d.interleaved = b;
        return ih(a, c);
      }
      function oh(a, b, c) {
        b = b.updateQueue;
        if (null !== b && ((b = b.shared), 0 !== (c & 4194240))) {
          var d = b.lanes;
          d &= a.pendingLanes;
          c |= d;
          b.lanes = c;
          Cc(a, c);
        }
      }
      function ph(a, b) {
        var c = a.updateQueue,
          d = a.alternate;
        if (null !== d && ((d = d.updateQueue), c === d)) {
          var e = null,
            f = null;
          c = c.firstBaseUpdate;
          if (null !== c) {
            do {
              var g = {
                eventTime: c.eventTime,
                lane: c.lane,
                tag: c.tag,
                payload: c.payload,
                callback: c.callback,
                next: null,
              };
              null === f ? (e = f = g) : (f = f.next = g);
              c = c.next;
            } while (null !== c);
            null === f ? (e = f = b) : (f = f.next = b);
          } else e = f = b;
          c = {
            baseState: d.baseState,
            firstBaseUpdate: e,
            lastBaseUpdate: f,
            shared: d.shared,
            effects: d.effects,
          };
          a.updateQueue = c;
          return;
        }
        a = c.lastBaseUpdate;
        null === a ? (c.firstBaseUpdate = b) : (a.next = b);
        c.lastBaseUpdate = b;
      }
      function qh(a, b, c, d) {
        var e = a.updateQueue;
        jh = false;
        var f = e.firstBaseUpdate,
          g = e.lastBaseUpdate,
          h = e.shared.pending;
        if (null !== h) {
          e.shared.pending = null;
          var k = h,
            l = k.next;
          k.next = null;
          null === g ? (f = l) : (g.next = l);
          g = k;
          var m = a.alternate;
          null !== m &&
            ((m = m.updateQueue),
            (h = m.lastBaseUpdate),
            h !== g &&
              (null === h ? (m.firstBaseUpdate = l) : (h.next = l),
              (m.lastBaseUpdate = k)));
        }
        if (null !== f) {
          var q = e.baseState;
          g = 0;
          m = l = k = null;
          h = f;
          do {
            var r = h.lane,
              y = h.eventTime;
            if ((d & r) === r) {
              null !== m &&
                (m = m.next =
                  {
                    eventTime: y,
                    lane: 0,
                    tag: h.tag,
                    payload: h.payload,
                    callback: h.callback,
                    next: null,
                  });
              a: {
                var n = a,
                  t = h;
                r = b;
                y = c;
                switch (t.tag) {
                  case 1:
                    n = t.payload;
                    if ("function" === typeof n) {
                      q = n.call(y, q, r);
                      break a;
                    }
                    q = n;
                    break a;
                  case 3:
                    n.flags = (n.flags & -65537) | 128;
                  case 0:
                    n = t.payload;
                    r = "function" === typeof n ? n.call(y, q, r) : n;
                    if (null === r || void 0 === r) break a;
                    q = A({}, q, r);
                    break a;
                  case 2:
                    jh = true;
                }
              }
              null !== h.callback &&
                0 !== h.lane &&
                ((a.flags |= 64),
                (r = e.effects),
                null === r ? (e.effects = [h]) : r.push(h));
            } else
              ((y = {
                eventTime: y,
                lane: r,
                tag: h.tag,
                payload: h.payload,
                callback: h.callback,
                next: null,
              }),
                null === m ? ((l = m = y), (k = q)) : (m = m.next = y),
                (g |= r));
            h = h.next;
            if (null === h)
              if (((h = e.shared.pending), null === h)) break;
              else
                ((r = h),
                  (h = r.next),
                  (r.next = null),
                  (e.lastBaseUpdate = r),
                  (e.shared.pending = null));
          } while (1);
          null === m && (k = q);
          e.baseState = k;
          e.firstBaseUpdate = l;
          e.lastBaseUpdate = m;
          b = e.shared.interleaved;
          if (null !== b) {
            e = b;
            do ((g |= e.lane), (e = e.next));
            while (e !== b);
          } else null === f && (e.shared.lanes = 0);
          rh |= g;
          a.lanes = g;
          a.memoizedState = q;
        }
      }
      function sh(a, b, c) {
        a = b.effects;
        b.effects = null;
        if (null !== a)
          for (b = 0; b < a.length; b++) {
            var d = a[b],
              e = d.callback;
            if (null !== e) {
              d.callback = null;
              d = c;
              if ("function" !== typeof e) throw Error(p(191, e));
              e.call(d);
            }
          }
      }
      var th = {},
        uh = Uf(th),
        vh$1 = Uf(th),
        wh = Uf(th);
      function xh(a) {
        if (a === th) throw Error(p(174));
        return a;
      }
      function yh(a, b) {
        G(wh, b);
        G(vh$1, a);
        G(uh, th);
        a = b.nodeType;
        switch (a) {
          case 9:
          case 11:
            b = (b = b.documentElement) ? b.namespaceURI : lb(null, "");
            break;
          default:
            ((a = 8 === a ? b.parentNode : b),
              (b = a.namespaceURI || null),
              (a = a.tagName),
              (b = lb(b, a)));
        }
        E$1(uh);
        G(uh, b);
      }
      function zh() {
        E$1(uh);
        E$1(vh$1);
        E$1(wh);
      }
      function Ah(a) {
        xh(wh.current);
        var b = xh(uh.current);
        var c = lb(b, a.type);
        b !== c && (G(vh$1, a), G(uh, c));
      }
      function Bh(a) {
        vh$1.current === a && (E$1(uh), E$1(vh$1));
      }
      var L$1 = Uf(0);
      function Ch(a) {
        for (var b = a; null !== b; ) {
          if (13 === b.tag) {
            var c = b.memoizedState;
            if (
              null !== c &&
              ((c = c.dehydrated),
              null === c || "$?" === c.data || "$!" === c.data)
            )
              return b;
          } else if (19 === b.tag && void 0 !== b.memoizedProps.revealOrder) {
            if (0 !== (b.flags & 128)) return b;
          } else if (null !== b.child) {
            b.child.return = b;
            b = b.child;
            continue;
          }
          if (b === a) break;
          for (; null === b.sibling; ) {
            if (null === b.return || b.return === a) return null;
            b = b.return;
          }
          b.sibling.return = b.return;
          b = b.sibling;
        }
        return null;
      }
      var Dh = [];
      function Eh() {
        for (var a = 0; a < Dh.length; a++)
          Dh[a]._workInProgressVersionPrimary = null;
        Dh.length = 0;
      }
      var Fh = ua.ReactCurrentDispatcher,
        Gh = ua.ReactCurrentBatchConfig,
        Hh = 0,
        M$1 = null,
        N = null,
        O = null,
        Ih = false,
        Jh = false,
        Kh = 0,
        Lh = 0;
      function P$1() {
        throw Error(p(321));
      }
      function Mh(a, b) {
        if (null === b) return false;
        for (var c = 0; c < b.length && c < a.length; c++)
          if (!He(a[c], b[c])) return false;
        return true;
      }
      function Nh(a, b, c, d, e, f) {
        Hh = f;
        M$1 = b;
        b.memoizedState = null;
        b.updateQueue = null;
        b.lanes = 0;
        Fh.current = null === a || null === a.memoizedState ? Oh : Ph;
        a = c(d, e);
        if (Jh) {
          f = 0;
          do {
            Jh = false;
            Kh = 0;
            if (25 <= f) throw Error(p(301));
            f += 1;
            O = N = null;
            b.updateQueue = null;
            Fh.current = Qh;
            a = c(d, e);
          } while (Jh);
        }
        Fh.current = Rh;
        b = null !== N && null !== N.next;
        Hh = 0;
        O = N = M$1 = null;
        Ih = false;
        if (b) throw Error(p(300));
        return a;
      }
      function Sh() {
        var a = 0 !== Kh;
        Kh = 0;
        return a;
      }
      function Th() {
        var a = {
          memoizedState: null,
          baseState: null,
          baseQueue: null,
          queue: null,
          next: null,
        };
        null === O ? (M$1.memoizedState = O = a) : (O = O.next = a);
        return O;
      }
      function Uh() {
        if (null === N) {
          var a = M$1.alternate;
          a = null !== a ? a.memoizedState : null;
        } else a = N.next;
        var b = null === O ? M$1.memoizedState : O.next;
        if (null !== b) ((O = b), (N = a));
        else {
          if (null === a) throw Error(p(310));
          N = a;
          a = {
            memoizedState: N.memoizedState,
            baseState: N.baseState,
            baseQueue: N.baseQueue,
            queue: N.queue,
            next: null,
          };
          null === O ? (M$1.memoizedState = O = a) : (O = O.next = a);
        }
        return O;
      }
      function Vh(a, b) {
        return "function" === typeof b ? b(a) : b;
      }
      function Wh(a) {
        var b = Uh(),
          c = b.queue;
        if (null === c) throw Error(p(311));
        c.lastRenderedReducer = a;
        var d = N,
          e = d.baseQueue,
          f = c.pending;
        if (null !== f) {
          if (null !== e) {
            var g = e.next;
            e.next = f.next;
            f.next = g;
          }
          d.baseQueue = e = f;
          c.pending = null;
        }
        if (null !== e) {
          f = e.next;
          d = d.baseState;
          var h = (g = null),
            k = null,
            l = f;
          do {
            var m = l.lane;
            if ((Hh & m) === m)
              (null !== k &&
                (k = k.next =
                  {
                    lane: 0,
                    action: l.action,
                    hasEagerState: l.hasEagerState,
                    eagerState: l.eagerState,
                    next: null,
                  }),
                (d = l.hasEagerState ? l.eagerState : a(d, l.action)));
            else {
              var q = {
                lane: m,
                action: l.action,
                hasEagerState: l.hasEagerState,
                eagerState: l.eagerState,
                next: null,
              };
              null === k ? ((h = k = q), (g = d)) : (k = k.next = q);
              M$1.lanes |= m;
              rh |= m;
            }
            l = l.next;
          } while (null !== l && l !== f);
          null === k ? (g = d) : (k.next = h);
          He(d, b.memoizedState) || (dh = true);
          b.memoizedState = d;
          b.baseState = g;
          b.baseQueue = k;
          c.lastRenderedState = d;
        }
        a = c.interleaved;
        if (null !== a) {
          e = a;
          do ((f = e.lane), (M$1.lanes |= f), (rh |= f), (e = e.next));
          while (e !== a);
        } else null === e && (c.lanes = 0);
        return [b.memoizedState, c.dispatch];
      }
      function Xh(a) {
        var b = Uh(),
          c = b.queue;
        if (null === c) throw Error(p(311));
        c.lastRenderedReducer = a;
        var d = c.dispatch,
          e = c.pending,
          f = b.memoizedState;
        if (null !== e) {
          c.pending = null;
          var g = (e = e.next);
          do ((f = a(f, g.action)), (g = g.next));
          while (g !== e);
          He(f, b.memoizedState) || (dh = true);
          b.memoizedState = f;
          null === b.baseQueue && (b.baseState = f);
          c.lastRenderedState = f;
        }
        return [f, d];
      }
      function Yh() {}
      function Zh(a, b) {
        var c = M$1,
          d = Uh(),
          e = b(),
          f = !He(d.memoizedState, e);
        f && ((d.memoizedState = e), (dh = true));
        d = d.queue;
        $h(ai.bind(null, c, d, a), [a]);
        if (
          d.getSnapshot !== b ||
          f ||
          (null !== O && O.memoizedState.tag & 1)
        ) {
          c.flags |= 2048;
          bi(9, ci.bind(null, c, d, e, b), void 0, null);
          if (null === Q) throw Error(p(349));
          0 !== (Hh & 30) || di(c, b, e);
        }
        return e;
      }
      function di(a, b, c) {
        a.flags |= 16384;
        a = { getSnapshot: b, value: c };
        b = M$1.updateQueue;
        null === b
          ? ((b = { lastEffect: null, stores: null }),
            (M$1.updateQueue = b),
            (b.stores = [a]))
          : ((c = b.stores), null === c ? (b.stores = [a]) : c.push(a));
      }
      function ci(a, b, c, d) {
        b.value = c;
        b.getSnapshot = d;
        ei(b) && fi(a);
      }
      function ai(a, b, c) {
        return c(function () {
          ei(b) && fi(a);
        });
      }
      function ei(a) {
        var b = a.getSnapshot;
        a = a.value;
        try {
          var c = b();
          return !He(a, c);
        } catch (d) {
          return true;
        }
      }
      function fi(a) {
        var b = ih(a, 1);
        null !== b && gi(b, a, 1, -1);
      }
      function hi(a) {
        var b = Th();
        "function" === typeof a && (a = a());
        b.memoizedState = b.baseState = a;
        a = {
          pending: null,
          interleaved: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: Vh,
          lastRenderedState: a,
        };
        b.queue = a;
        a = a.dispatch = ii.bind(null, M$1, a);
        return [b.memoizedState, a];
      }
      function bi(a, b, c, d) {
        a = { tag: a, create: b, destroy: c, deps: d, next: null };
        b = M$1.updateQueue;
        null === b
          ? ((b = { lastEffect: null, stores: null }),
            (M$1.updateQueue = b),
            (b.lastEffect = a.next = a))
          : ((c = b.lastEffect),
            null === c
              ? (b.lastEffect = a.next = a)
              : ((d = c.next), (c.next = a), (a.next = d), (b.lastEffect = a)));
        return a;
      }
      function ji() {
        return Uh().memoizedState;
      }
      function ki(a, b, c, d) {
        var e = Th();
        M$1.flags |= a;
        e.memoizedState = bi(1 | b, c, void 0, void 0 === d ? null : d);
      }
      function li(a, b, c, d) {
        var e = Uh();
        d = void 0 === d ? null : d;
        var f = void 0;
        if (null !== N) {
          var g = N.memoizedState;
          f = g.destroy;
          if (null !== d && Mh(d, g.deps)) {
            e.memoizedState = bi(b, c, f, d);
            return;
          }
        }
        M$1.flags |= a;
        e.memoizedState = bi(1 | b, c, f, d);
      }
      function mi(a, b) {
        return ki(8390656, 8, a, b);
      }
      function $h(a, b) {
        return li(2048, 8, a, b);
      }
      function ni(a, b) {
        return li(4, 2, a, b);
      }
      function oi(a, b) {
        return li(4, 4, a, b);
      }
      function pi(a, b) {
        if ("function" === typeof b)
          return (
            (a = a()),
            b(a),
            function () {
              b(null);
            }
          );
        if (null !== b && void 0 !== b)
          return (
            (a = a()),
            (b.current = a),
            function () {
              b.current = null;
            }
          );
      }
      function qi(a, b, c) {
        c = null !== c && void 0 !== c ? c.concat([a]) : null;
        return li(4, 4, pi.bind(null, b, a), c);
      }
      function ri() {}
      function si(a, b) {
        var c = Uh();
        b = void 0 === b ? null : b;
        var d = c.memoizedState;
        if (null !== d && null !== b && Mh(b, d[1])) return d[0];
        c.memoizedState = [a, b];
        return a;
      }
      function ti(a, b) {
        var c = Uh();
        b = void 0 === b ? null : b;
        var d = c.memoizedState;
        if (null !== d && null !== b && Mh(b, d[1])) return d[0];
        a = a();
        c.memoizedState = [a, b];
        return a;
      }
      function ui(a, b, c) {
        if (0 === (Hh & 21))
          return (
            a.baseState && ((a.baseState = false), (dh = true)),
            (a.memoizedState = c)
          );
        He(c, b) ||
          ((c = yc()), (M$1.lanes |= c), (rh |= c), (a.baseState = true));
        return b;
      }
      function vi(a, b) {
        var c = C;
        C = 0 !== c && 4 > c ? c : 4;
        a(true);
        var d = Gh.transition;
        Gh.transition = {};
        try {
          (a(!1), b());
        } finally {
          ((C = c), (Gh.transition = d));
        }
      }
      function wi() {
        return Uh().memoizedState;
      }
      function xi(a, b, c) {
        var d = yi(a);
        c = {
          lane: d,
          action: c,
          hasEagerState: false,
          eagerState: null,
          next: null,
        };
        if (zi(a)) Ai(b, c);
        else if (((c = hh(a, b, c, d)), null !== c)) {
          var e = R();
          gi(c, a, d, e);
          Bi(c, b, d);
        }
      }
      function ii(a, b, c) {
        var d = yi(a),
          e = {
            lane: d,
            action: c,
            hasEagerState: false,
            eagerState: null,
            next: null,
          };
        if (zi(a)) Ai(b, e);
        else {
          var f = a.alternate;
          if (
            0 === a.lanes &&
            (null === f || 0 === f.lanes) &&
            ((f = b.lastRenderedReducer), null !== f)
          )
            try {
              var g = b.lastRenderedState,
                h = f(g, c);
              e.hasEagerState = !0;
              e.eagerState = h;
              if (He(h, g)) {
                var k = b.interleaved;
                null === k
                  ? ((e.next = e), gh(b))
                  : ((e.next = k.next), (k.next = e));
                b.interleaved = e;
                return;
              }
            } catch (l) {
            } finally {
            }
          c = hh(a, b, e, d);
          null !== c && ((e = R()), gi(c, a, d, e), Bi(c, b, d));
        }
      }
      function zi(a) {
        var b = a.alternate;
        return a === M$1 || (null !== b && b === M$1);
      }
      function Ai(a, b) {
        Jh = Ih = true;
        var c = a.pending;
        null === c ? (b.next = b) : ((b.next = c.next), (c.next = b));
        a.pending = b;
      }
      function Bi(a, b, c) {
        if (0 !== (c & 4194240)) {
          var d = b.lanes;
          d &= a.pendingLanes;
          c |= d;
          b.lanes = c;
          Cc(a, c);
        }
      }
      var Rh = {
          readContext: eh,
          useCallback: P$1,
          useContext: P$1,
          useEffect: P$1,
          useImperativeHandle: P$1,
          useInsertionEffect: P$1,
          useLayoutEffect: P$1,
          useMemo: P$1,
          useReducer: P$1,
          useRef: P$1,
          useState: P$1,
          useDebugValue: P$1,
          useDeferredValue: P$1,
          useTransition: P$1,
          useMutableSource: P$1,
          useSyncExternalStore: P$1,
          useId: P$1,
          unstable_isNewReconciler: false,
        },
        Oh = {
          readContext: eh,
          useCallback: function (a, b) {
            Th().memoizedState = [a, void 0 === b ? null : b];
            return a;
          },
          useContext: eh,
          useEffect: mi,
          useImperativeHandle: function (a, b, c) {
            c = null !== c && void 0 !== c ? c.concat([a]) : null;
            return ki(4194308, 4, pi.bind(null, b, a), c);
          },
          useLayoutEffect: function (a, b) {
            return ki(4194308, 4, a, b);
          },
          useInsertionEffect: function (a, b) {
            return ki(4, 2, a, b);
          },
          useMemo: function (a, b) {
            var c = Th();
            b = void 0 === b ? null : b;
            a = a();
            c.memoizedState = [a, b];
            return a;
          },
          useReducer: function (a, b, c) {
            var d = Th();
            b = void 0 !== c ? c(b) : b;
            d.memoizedState = d.baseState = b;
            a = {
              pending: null,
              interleaved: null,
              lanes: 0,
              dispatch: null,
              lastRenderedReducer: a,
              lastRenderedState: b,
            };
            d.queue = a;
            a = a.dispatch = xi.bind(null, M$1, a);
            return [d.memoizedState, a];
          },
          useRef: function (a) {
            var b = Th();
            a = { current: a };
            return (b.memoizedState = a);
          },
          useState: hi,
          useDebugValue: ri,
          useDeferredValue: function (a) {
            return (Th().memoizedState = a);
          },
          useTransition: function () {
            var a = hi(false),
              b = a[0];
            a = vi.bind(null, a[1]);
            Th().memoizedState = a;
            return [b, a];
          },
          useMutableSource: function () {},
          useSyncExternalStore: function (a, b, c) {
            var d = M$1,
              e = Th();
            if (I) {
              if (void 0 === c) throw Error(p(407));
              c = c();
            } else {
              c = b();
              if (null === Q) throw Error(p(349));
              0 !== (Hh & 30) || di(d, b, c);
            }
            e.memoizedState = c;
            var f = { value: c, getSnapshot: b };
            e.queue = f;
            mi(ai.bind(null, d, f, a), [a]);
            d.flags |= 2048;
            bi(9, ci.bind(null, d, f, c, b), void 0, null);
            return c;
          },
          useId: function () {
            var a = Th(),
              b = Q.identifierPrefix;
            if (I) {
              var c = sg;
              var d = rg;
              c = (d & ~(1 << (32 - oc(d) - 1))).toString(32) + c;
              b = ":" + b + "R" + c;
              c = Kh++;
              0 < c && (b += "H" + c.toString(32));
              b += ":";
            } else ((c = Lh++), (b = ":" + b + "r" + c.toString(32) + ":"));
            return (a.memoizedState = b);
          },
          unstable_isNewReconciler: false,
        },
        Ph = {
          readContext: eh,
          useCallback: si,
          useContext: eh,
          useEffect: $h,
          useImperativeHandle: qi,
          useInsertionEffect: ni,
          useLayoutEffect: oi,
          useMemo: ti,
          useReducer: Wh,
          useRef: ji,
          useState: function () {
            return Wh(Vh);
          },
          useDebugValue: ri,
          useDeferredValue: function (a) {
            var b = Uh();
            return ui(b, N.memoizedState, a);
          },
          useTransition: function () {
            var a = Wh(Vh)[0],
              b = Uh().memoizedState;
            return [a, b];
          },
          useMutableSource: Yh,
          useSyncExternalStore: Zh,
          useId: wi,
          unstable_isNewReconciler: false,
        },
        Qh = {
          readContext: eh,
          useCallback: si,
          useContext: eh,
          useEffect: $h,
          useImperativeHandle: qi,
          useInsertionEffect: ni,
          useLayoutEffect: oi,
          useMemo: ti,
          useReducer: Xh,
          useRef: ji,
          useState: function () {
            return Xh(Vh);
          },
          useDebugValue: ri,
          useDeferredValue: function (a) {
            var b = Uh();
            return null === N
              ? (b.memoizedState = a)
              : ui(b, N.memoizedState, a);
          },
          useTransition: function () {
            var a = Xh(Vh)[0],
              b = Uh().memoizedState;
            return [a, b];
          },
          useMutableSource: Yh,
          useSyncExternalStore: Zh,
          useId: wi,
          unstable_isNewReconciler: false,
        };
      function Ci(a, b) {
        if (a && a.defaultProps) {
          b = A({}, b);
          a = a.defaultProps;
          for (var c in a) void 0 === b[c] && (b[c] = a[c]);
          return b;
        }
        return b;
      }
      function Di(a, b, c, d) {
        b = a.memoizedState;
        c = c(d, b);
        c = null === c || void 0 === c ? b : A({}, b, c);
        a.memoizedState = c;
        0 === a.lanes && (a.updateQueue.baseState = c);
      }
      var Ei = {
        isMounted: function (a) {
          return (a = a._reactInternals) ? Vb(a) === a : false;
        },
        enqueueSetState: function (a, b, c) {
          a = a._reactInternals;
          var d = R(),
            e = yi(a),
            f = mh(d, e);
          f.payload = b;
          void 0 !== c && null !== c && (f.callback = c);
          b = nh(a, f, e);
          null !== b && (gi(b, a, e, d), oh(b, a, e));
        },
        enqueueReplaceState: function (a, b, c) {
          a = a._reactInternals;
          var d = R(),
            e = yi(a),
            f = mh(d, e);
          f.tag = 1;
          f.payload = b;
          void 0 !== c && null !== c && (f.callback = c);
          b = nh(a, f, e);
          null !== b && (gi(b, a, e, d), oh(b, a, e));
        },
        enqueueForceUpdate: function (a, b) {
          a = a._reactInternals;
          var c = R(),
            d = yi(a),
            e = mh(c, d);
          e.tag = 2;
          void 0 !== b && null !== b && (e.callback = b);
          b = nh(a, e, d);
          null !== b && (gi(b, a, d, c), oh(b, a, d));
        },
      };
      function Fi(a, b, c, d, e, f, g) {
        a = a.stateNode;
        return "function" === typeof a.shouldComponentUpdate
          ? a.shouldComponentUpdate(d, f, g)
          : b.prototype && b.prototype.isPureReactComponent
            ? !Ie(c, d) || !Ie(e, f)
            : true;
      }
      function Gi(a, b, c) {
        var d = false,
          e = Vf;
        var f = b.contextType;
        "object" === typeof f && null !== f
          ? (f = eh(f))
          : ((e = Zf(b) ? Xf : H.current),
            (d = b.contextTypes),
            (f = (d = null !== d && void 0 !== d) ? Yf(a, e) : Vf));
        b = new b(c, f);
        a.memoizedState =
          null !== b.state && void 0 !== b.state ? b.state : null;
        b.updater = Ei;
        a.stateNode = b;
        b._reactInternals = a;
        d &&
          ((a = a.stateNode),
          (a.__reactInternalMemoizedUnmaskedChildContext = e),
          (a.__reactInternalMemoizedMaskedChildContext = f));
        return b;
      }
      function Hi(a, b, c, d) {
        a = b.state;
        "function" === typeof b.componentWillReceiveProps &&
          b.componentWillReceiveProps(c, d);
        "function" === typeof b.UNSAFE_componentWillReceiveProps &&
          b.UNSAFE_componentWillReceiveProps(c, d);
        b.state !== a && Ei.enqueueReplaceState(b, b.state, null);
      }
      function Ii(a, b, c, d) {
        var e = a.stateNode;
        e.props = c;
        e.state = a.memoizedState;
        e.refs = {};
        kh(a);
        var f = b.contextType;
        "object" === typeof f && null !== f
          ? (e.context = eh(f))
          : ((f = Zf(b) ? Xf : H.current), (e.context = Yf(a, f)));
        e.state = a.memoizedState;
        f = b.getDerivedStateFromProps;
        "function" === typeof f &&
          (Di(a, b, f, c), (e.state = a.memoizedState));
        "function" === typeof b.getDerivedStateFromProps ||
          "function" === typeof e.getSnapshotBeforeUpdate ||
          ("function" !== typeof e.UNSAFE_componentWillMount &&
            "function" !== typeof e.componentWillMount) ||
          ((b = e.state),
          "function" === typeof e.componentWillMount && e.componentWillMount(),
          "function" === typeof e.UNSAFE_componentWillMount &&
            e.UNSAFE_componentWillMount(),
          b !== e.state && Ei.enqueueReplaceState(e, e.state, null),
          qh(a, c, e, d),
          (e.state = a.memoizedState));
        "function" === typeof e.componentDidMount && (a.flags |= 4194308);
      }
      function Ji(a, b) {
        try {
          var c = "",
            d = b;
          do ((c += Pa(d)), (d = d.return));
          while (d);
          var e = c;
        } catch (f) {
          e = "\nError generating stack: " + f.message + "\n" + f.stack;
        }
        return { value: a, source: b, stack: e, digest: null };
      }
      function Ki(a, b, c) {
        return {
          value: a,
          source: null,
          stack: null != c ? c : null,
          digest: null != b ? b : null,
        };
      }
      function Li(a, b) {
        try {
          console.error(b.value);
        } catch (c) {
          setTimeout(function () {
            throw c;
          });
        }
      }
      var Mi = "function" === typeof WeakMap ? WeakMap : Map;
      function Ni(a, b, c) {
        c = mh(-1, c);
        c.tag = 3;
        c.payload = { element: null };
        var d = b.value;
        c.callback = function () {
          Oi || ((Oi = true), (Pi = d));
          Li(a, b);
        };
        return c;
      }
      function Qi(a, b, c) {
        c = mh(-1, c);
        c.tag = 3;
        var d = a.type.getDerivedStateFromError;
        if ("function" === typeof d) {
          var e = b.value;
          c.payload = function () {
            return d(e);
          };
          c.callback = function () {
            Li(a, b);
          };
        }
        var f = a.stateNode;
        null !== f &&
          "function" === typeof f.componentDidCatch &&
          (c.callback = function () {
            Li(a, b);
            "function" !== typeof d &&
              (null === Ri ? (Ri = new Set([this])) : Ri.add(this));
            var c = b.stack;
            this.componentDidCatch(b.value, {
              componentStack: null !== c ? c : "",
            });
          });
        return c;
      }
      function Si(a, b, c) {
        var d = a.pingCache;
        if (null === d) {
          d = a.pingCache = new Mi();
          var e = new Set();
          d.set(b, e);
        } else ((e = d.get(b)), void 0 === e && ((e = new Set()), d.set(b, e)));
        e.has(c) || (e.add(c), (a = Ti.bind(null, a, b, c)), b.then(a, a));
      }
      function Ui(a) {
        do {
          var b;
          if ((b = 13 === a.tag))
            ((b = a.memoizedState),
              (b = null !== b ? (null !== b.dehydrated ? true : false) : true));
          if (b) return a;
          a = a.return;
        } while (null !== a);
        return null;
      }
      function Vi(a, b, c, d, e) {
        if (0 === (a.mode & 1))
          return (
            a === b
              ? (a.flags |= 65536)
              : ((a.flags |= 128),
                (c.flags |= 131072),
                (c.flags &= -52805),
                1 === c.tag &&
                  (null === c.alternate
                    ? (c.tag = 17)
                    : ((b = mh(-1, 1)), (b.tag = 2), nh(c, b, 1))),
                (c.lanes |= 1)),
            a
          );
        a.flags |= 65536;
        a.lanes = e;
        return a;
      }
      var Wi = ua.ReactCurrentOwner,
        dh = false;
      function Xi(a, b, c, d) {
        b.child = null === a ? Vg(b, null, c, d) : Ug(b, a.child, c, d);
      }
      function Yi(a, b, c, d, e) {
        c = c.render;
        var f = b.ref;
        ch(b, e);
        d = Nh(a, b, c, d, f, e);
        c = Sh();
        if (null !== a && !dh)
          return (
            (b.updateQueue = a.updateQueue),
            (b.flags &= -2053),
            (a.lanes &= ~e),
            Zi(a, b, e)
          );
        I && c && vg(b);
        b.flags |= 1;
        Xi(a, b, d, e);
        return b.child;
      }
      function $i(a, b, c, d, e) {
        if (null === a) {
          var f = c.type;
          if (
            "function" === typeof f &&
            !aj(f) &&
            void 0 === f.defaultProps &&
            null === c.compare &&
            void 0 === c.defaultProps
          )
            return ((b.tag = 15), (b.type = f), bj(a, b, f, d, e));
          a = Rg(c.type, null, d, b, b.mode, e);
          a.ref = b.ref;
          a.return = b;
          return (b.child = a);
        }
        f = a.child;
        if (0 === (a.lanes & e)) {
          var g = f.memoizedProps;
          c = c.compare;
          c = null !== c ? c : Ie;
          if (c(g, d) && a.ref === b.ref) return Zi(a, b, e);
        }
        b.flags |= 1;
        a = Pg(f, d);
        a.ref = b.ref;
        a.return = b;
        return (b.child = a);
      }
      function bj(a, b, c, d, e) {
        if (null !== a) {
          var f = a.memoizedProps;
          if (Ie(f, d) && a.ref === b.ref)
            if (((dh = false), (b.pendingProps = d = f), 0 !== (a.lanes & e)))
              0 !== (a.flags & 131072) && (dh = true);
            else return ((b.lanes = a.lanes), Zi(a, b, e));
        }
        return cj(a, b, c, d, e);
      }
      function dj(a, b, c) {
        var d = b.pendingProps,
          e = d.children,
          f = null !== a ? a.memoizedState : null;
        if ("hidden" === d.mode)
          if (0 === (b.mode & 1))
            ((b.memoizedState = {
              baseLanes: 0,
              cachePool: null,
              transitions: null,
            }),
              G(ej, fj),
              (fj |= c));
          else {
            if (0 === (c & 1073741824))
              return (
                (a = null !== f ? f.baseLanes | c : c),
                (b.lanes = b.childLanes = 1073741824),
                (b.memoizedState = {
                  baseLanes: a,
                  cachePool: null,
                  transitions: null,
                }),
                (b.updateQueue = null),
                G(ej, fj),
                (fj |= a),
                null
              );
            b.memoizedState = {
              baseLanes: 0,
              cachePool: null,
              transitions: null,
            };
            d = null !== f ? f.baseLanes : c;
            G(ej, fj);
            fj |= d;
          }
        else
          (null !== f
            ? ((d = f.baseLanes | c), (b.memoizedState = null))
            : (d = c),
            G(ej, fj),
            (fj |= d));
        Xi(a, b, e, c);
        return b.child;
      }
      function gj(a, b) {
        var c = b.ref;
        if ((null === a && null !== c) || (null !== a && a.ref !== c))
          ((b.flags |= 512), (b.flags |= 2097152));
      }
      function cj(a, b, c, d, e) {
        var f = Zf(c) ? Xf : H.current;
        f = Yf(b, f);
        ch(b, e);
        c = Nh(a, b, c, d, f, e);
        d = Sh();
        if (null !== a && !dh)
          return (
            (b.updateQueue = a.updateQueue),
            (b.flags &= -2053),
            (a.lanes &= ~e),
            Zi(a, b, e)
          );
        I && d && vg(b);
        b.flags |= 1;
        Xi(a, b, c, e);
        return b.child;
      }
      function hj(a, b, c, d, e) {
        if (Zf(c)) {
          var f = true;
          cg(b);
        } else f = false;
        ch(b, e);
        if (null === b.stateNode)
          (ij(a, b), Gi(b, c, d), Ii(b, c, d, e), (d = true));
        else if (null === a) {
          var g = b.stateNode,
            h = b.memoizedProps;
          g.props = h;
          var k = g.context,
            l = c.contextType;
          "object" === typeof l && null !== l
            ? (l = eh(l))
            : ((l = Zf(c) ? Xf : H.current), (l = Yf(b, l)));
          var m = c.getDerivedStateFromProps,
            q =
              "function" === typeof m ||
              "function" === typeof g.getSnapshotBeforeUpdate;
          q ||
            ("function" !== typeof g.UNSAFE_componentWillReceiveProps &&
              "function" !== typeof g.componentWillReceiveProps) ||
            ((h !== d || k !== l) && Hi(b, g, d, l));
          jh = false;
          var r = b.memoizedState;
          g.state = r;
          qh(b, d, g, e);
          k = b.memoizedState;
          h !== d || r !== k || Wf.current || jh
            ? ("function" === typeof m &&
                (Di(b, c, m, d), (k = b.memoizedState)),
              (h = jh || Fi(b, c, h, d, r, k, l))
                ? (q ||
                    ("function" !== typeof g.UNSAFE_componentWillMount &&
                      "function" !== typeof g.componentWillMount) ||
                    ("function" === typeof g.componentWillMount &&
                      g.componentWillMount(),
                    "function" === typeof g.UNSAFE_componentWillMount &&
                      g.UNSAFE_componentWillMount()),
                  "function" === typeof g.componentDidMount &&
                    (b.flags |= 4194308))
                : ("function" === typeof g.componentDidMount &&
                    (b.flags |= 4194308),
                  (b.memoizedProps = d),
                  (b.memoizedState = k)),
              (g.props = d),
              (g.state = k),
              (g.context = l),
              (d = h))
            : ("function" === typeof g.componentDidMount &&
                (b.flags |= 4194308),
              (d = false));
        } else {
          g = b.stateNode;
          lh(a, b);
          h = b.memoizedProps;
          l = b.type === b.elementType ? h : Ci(b.type, h);
          g.props = l;
          q = b.pendingProps;
          r = g.context;
          k = c.contextType;
          "object" === typeof k && null !== k
            ? (k = eh(k))
            : ((k = Zf(c) ? Xf : H.current), (k = Yf(b, k)));
          var y = c.getDerivedStateFromProps;
          (m =
            "function" === typeof y ||
            "function" === typeof g.getSnapshotBeforeUpdate) ||
            ("function" !== typeof g.UNSAFE_componentWillReceiveProps &&
              "function" !== typeof g.componentWillReceiveProps) ||
            ((h !== q || r !== k) && Hi(b, g, d, k));
          jh = false;
          r = b.memoizedState;
          g.state = r;
          qh(b, d, g, e);
          var n = b.memoizedState;
          h !== q || r !== n || Wf.current || jh
            ? ("function" === typeof y &&
                (Di(b, c, y, d), (n = b.memoizedState)),
              (l = jh || Fi(b, c, l, d, r, n, k) || false)
                ? (m ||
                    ("function" !== typeof g.UNSAFE_componentWillUpdate &&
                      "function" !== typeof g.componentWillUpdate) ||
                    ("function" === typeof g.componentWillUpdate &&
                      g.componentWillUpdate(d, n, k),
                    "function" === typeof g.UNSAFE_componentWillUpdate &&
                      g.UNSAFE_componentWillUpdate(d, n, k)),
                  "function" === typeof g.componentDidUpdate && (b.flags |= 4),
                  "function" === typeof g.getSnapshotBeforeUpdate &&
                    (b.flags |= 1024))
                : ("function" !== typeof g.componentDidUpdate ||
                    (h === a.memoizedProps && r === a.memoizedState) ||
                    (b.flags |= 4),
                  "function" !== typeof g.getSnapshotBeforeUpdate ||
                    (h === a.memoizedProps && r === a.memoizedState) ||
                    (b.flags |= 1024),
                  (b.memoizedProps = d),
                  (b.memoizedState = n)),
              (g.props = d),
              (g.state = n),
              (g.context = k),
              (d = l))
            : ("function" !== typeof g.componentDidUpdate ||
                (h === a.memoizedProps && r === a.memoizedState) ||
                (b.flags |= 4),
              "function" !== typeof g.getSnapshotBeforeUpdate ||
                (h === a.memoizedProps && r === a.memoizedState) ||
                (b.flags |= 1024),
              (d = false));
        }
        return jj(a, b, c, d, f, e);
      }
      function jj(a, b, c, d, e, f) {
        gj(a, b);
        var g = 0 !== (b.flags & 128);
        if (!d && !g) return (e && dg(b, c, false), Zi(a, b, f));
        d = b.stateNode;
        Wi.current = b;
        var h =
          g && "function" !== typeof c.getDerivedStateFromError
            ? null
            : d.render();
        b.flags |= 1;
        null !== a && g
          ? ((b.child = Ug(b, a.child, null, f)), (b.child = Ug(b, null, h, f)))
          : Xi(a, b, h, f);
        b.memoizedState = d.state;
        e && dg(b, c, true);
        return b.child;
      }
      function kj(a) {
        var b = a.stateNode;
        b.pendingContext
          ? ag(a, b.pendingContext, b.pendingContext !== b.context)
          : b.context && ag(a, b.context, false);
        yh(a, b.containerInfo);
      }
      function lj(a, b, c, d, e) {
        Ig();
        Jg(e);
        b.flags |= 256;
        Xi(a, b, c, d);
        return b.child;
      }
      var mj = { dehydrated: null, treeContext: null, retryLane: 0 };
      function nj(a) {
        return { baseLanes: a, cachePool: null, transitions: null };
      }
      function oj(a, b, c) {
        var d = b.pendingProps,
          e = L$1.current,
          f = false,
          g = 0 !== (b.flags & 128),
          h;
        (h = g) ||
          (h = null !== a && null === a.memoizedState ? false : 0 !== (e & 2));
        if (h) ((f = true), (b.flags &= -129));
        else if (null === a || null !== a.memoizedState) e |= 1;
        G(L$1, e & 1);
        if (null === a) {
          Eg(b);
          a = b.memoizedState;
          if (null !== a && ((a = a.dehydrated), null !== a))
            return (
              0 === (b.mode & 1)
                ? (b.lanes = 1)
                : "$!" === a.data
                  ? (b.lanes = 8)
                  : (b.lanes = 1073741824),
              null
            );
          g = d.children;
          a = d.fallback;
          return f
            ? ((d = b.mode),
              (f = b.child),
              (g = { mode: "hidden", children: g }),
              0 === (d & 1) && null !== f
                ? ((f.childLanes = 0), (f.pendingProps = g))
                : (f = pj(g, d, 0, null)),
              (a = Tg(a, d, c, null)),
              (f.return = b),
              (a.return = b),
              (f.sibling = a),
              (b.child = f),
              (b.child.memoizedState = nj(c)),
              (b.memoizedState = mj),
              a)
            : qj(b, g);
        }
        e = a.memoizedState;
        if (null !== e && ((h = e.dehydrated), null !== h))
          return rj(a, b, g, d, h, e, c);
        if (f) {
          f = d.fallback;
          g = b.mode;
          e = a.child;
          h = e.sibling;
          var k = { mode: "hidden", children: d.children };
          0 === (g & 1) && b.child !== e
            ? ((d = b.child),
              (d.childLanes = 0),
              (d.pendingProps = k),
              (b.deletions = null))
            : ((d = Pg(e, k)), (d.subtreeFlags = e.subtreeFlags & 14680064));
          null !== h
            ? (f = Pg(h, f))
            : ((f = Tg(f, g, c, null)), (f.flags |= 2));
          f.return = b;
          d.return = b;
          d.sibling = f;
          b.child = d;
          d = f;
          f = b.child;
          g = a.child.memoizedState;
          g =
            null === g
              ? nj(c)
              : {
                  baseLanes: g.baseLanes | c,
                  cachePool: null,
                  transitions: g.transitions,
                };
          f.memoizedState = g;
          f.childLanes = a.childLanes & ~c;
          b.memoizedState = mj;
          return d;
        }
        f = a.child;
        a = f.sibling;
        d = Pg(f, { mode: "visible", children: d.children });
        0 === (b.mode & 1) && (d.lanes = c);
        d.return = b;
        d.sibling = null;
        null !== a &&
          ((c = b.deletions),
          null === c ? ((b.deletions = [a]), (b.flags |= 16)) : c.push(a));
        b.child = d;
        b.memoizedState = null;
        return d;
      }
      function qj(a, b) {
        b = pj({ mode: "visible", children: b }, a.mode, 0, null);
        b.return = a;
        return (a.child = b);
      }
      function sj(a, b, c, d) {
        null !== d && Jg(d);
        Ug(b, a.child, null, c);
        a = qj(b, b.pendingProps.children);
        a.flags |= 2;
        b.memoizedState = null;
        return a;
      }
      function rj(a, b, c, d, e, f, g) {
        if (c) {
          if (b.flags & 256)
            return ((b.flags &= -257), (d = Ki(Error(p(422)))), sj(a, b, g, d));
          if (null !== b.memoizedState)
            return ((b.child = a.child), (b.flags |= 128), null);
          f = d.fallback;
          e = b.mode;
          d = pj({ mode: "visible", children: d.children }, e, 0, null);
          f = Tg(f, e, g, null);
          f.flags |= 2;
          d.return = b;
          f.return = b;
          d.sibling = f;
          b.child = d;
          0 !== (b.mode & 1) && Ug(b, a.child, null, g);
          b.child.memoizedState = nj(g);
          b.memoizedState = mj;
          return f;
        }
        if (0 === (b.mode & 1)) return sj(a, b, g, null);
        if ("$!" === e.data) {
          d = e.nextSibling && e.nextSibling.dataset;
          if (d) var h = d.dgst;
          d = h;
          f = Error(p(419));
          d = Ki(f, d, void 0);
          return sj(a, b, g, d);
        }
        h = 0 !== (g & a.childLanes);
        if (dh || h) {
          d = Q;
          if (null !== d) {
            switch (g & -g) {
              case 4:
                e = 2;
                break;
              case 16:
                e = 8;
                break;
              case 64:
              case 128:
              case 256:
              case 512:
              case 1024:
              case 2048:
              case 4096:
              case 8192:
              case 16384:
              case 32768:
              case 65536:
              case 131072:
              case 262144:
              case 524288:
              case 1048576:
              case 2097152:
              case 4194304:
              case 8388608:
              case 16777216:
              case 33554432:
              case 67108864:
                e = 32;
                break;
              case 536870912:
                e = 268435456;
                break;
              default:
                e = 0;
            }
            e = 0 !== (e & (d.suspendedLanes | g)) ? 0 : e;
            0 !== e &&
              e !== f.retryLane &&
              ((f.retryLane = e), ih(a, e), gi(d, a, e, -1));
          }
          tj();
          d = Ki(Error(p(421)));
          return sj(a, b, g, d);
        }
        if ("$?" === e.data)
          return (
            (b.flags |= 128),
            (b.child = a.child),
            (b = uj.bind(null, a)),
            (e._reactRetry = b),
            null
          );
        a = f.treeContext;
        yg = Lf(e.nextSibling);
        xg = b;
        I = true;
        zg = null;
        null !== a &&
          ((og[pg++] = rg),
          (og[pg++] = sg),
          (og[pg++] = qg),
          (rg = a.id),
          (sg = a.overflow),
          (qg = b));
        b = qj(b, d.children);
        b.flags |= 4096;
        return b;
      }
      function vj(a, b, c) {
        a.lanes |= b;
        var d = a.alternate;
        null !== d && (d.lanes |= b);
        bh(a.return, b, c);
      }
      function wj(a, b, c, d, e) {
        var f = a.memoizedState;
        null === f
          ? (a.memoizedState = {
              isBackwards: b,
              rendering: null,
              renderingStartTime: 0,
              last: d,
              tail: c,
              tailMode: e,
            })
          : ((f.isBackwards = b),
            (f.rendering = null),
            (f.renderingStartTime = 0),
            (f.last = d),
            (f.tail = c),
            (f.tailMode = e));
      }
      function xj(a, b, c) {
        var d = b.pendingProps,
          e = d.revealOrder,
          f = d.tail;
        Xi(a, b, d.children, c);
        d = L$1.current;
        if (0 !== (d & 2)) ((d = (d & 1) | 2), (b.flags |= 128));
        else {
          if (null !== a && 0 !== (a.flags & 128))
            a: for (a = b.child; null !== a; ) {
              if (13 === a.tag) null !== a.memoizedState && vj(a, c, b);
              else if (19 === a.tag) vj(a, c, b);
              else if (null !== a.child) {
                a.child.return = a;
                a = a.child;
                continue;
              }
              if (a === b) break a;
              for (; null === a.sibling; ) {
                if (null === a.return || a.return === b) break a;
                a = a.return;
              }
              a.sibling.return = a.return;
              a = a.sibling;
            }
          d &= 1;
        }
        G(L$1, d);
        if (0 === (b.mode & 1)) b.memoizedState = null;
        else
          switch (e) {
            case "forwards":
              c = b.child;
              for (e = null; null !== c; )
                ((a = c.alternate),
                  null !== a && null === Ch(a) && (e = c),
                  (c = c.sibling));
              c = e;
              null === c
                ? ((e = b.child), (b.child = null))
                : ((e = c.sibling), (c.sibling = null));
              wj(b, false, e, c, f);
              break;
            case "backwards":
              c = null;
              e = b.child;
              for (b.child = null; null !== e; ) {
                a = e.alternate;
                if (null !== a && null === Ch(a)) {
                  b.child = e;
                  break;
                }
                a = e.sibling;
                e.sibling = c;
                c = e;
                e = a;
              }
              wj(b, true, c, null, f);
              break;
            case "together":
              wj(b, false, null, null, void 0);
              break;
            default:
              b.memoizedState = null;
          }
        return b.child;
      }
      function ij(a, b) {
        0 === (b.mode & 1) &&
          null !== a &&
          ((a.alternate = null), (b.alternate = null), (b.flags |= 2));
      }
      function Zi(a, b, c) {
        null !== a && (b.dependencies = a.dependencies);
        rh |= b.lanes;
        if (0 === (c & b.childLanes)) return null;
        if (null !== a && b.child !== a.child) throw Error(p(153));
        if (null !== b.child) {
          a = b.child;
          c = Pg(a, a.pendingProps);
          b.child = c;
          for (c.return = b; null !== a.sibling; )
            ((a = a.sibling),
              (c = c.sibling = Pg(a, a.pendingProps)),
              (c.return = b));
          c.sibling = null;
        }
        return b.child;
      }
      function yj(a, b, c) {
        switch (b.tag) {
          case 3:
            kj(b);
            Ig();
            break;
          case 5:
            Ah(b);
            break;
          case 1:
            Zf(b.type) && cg(b);
            break;
          case 4:
            yh(b, b.stateNode.containerInfo);
            break;
          case 10:
            var d = b.type._context,
              e = b.memoizedProps.value;
            G(Wg, d._currentValue);
            d._currentValue = e;
            break;
          case 13:
            d = b.memoizedState;
            if (null !== d) {
              if (null !== d.dehydrated)
                return (G(L$1, L$1.current & 1), (b.flags |= 128), null);
              if (0 !== (c & b.child.childLanes)) return oj(a, b, c);
              G(L$1, L$1.current & 1);
              a = Zi(a, b, c);
              return null !== a ? a.sibling : null;
            }
            G(L$1, L$1.current & 1);
            break;
          case 19:
            d = 0 !== (c & b.childLanes);
            if (0 !== (a.flags & 128)) {
              if (d) return xj(a, b, c);
              b.flags |= 128;
            }
            e = b.memoizedState;
            null !== e &&
              ((e.rendering = null), (e.tail = null), (e.lastEffect = null));
            G(L$1, L$1.current);
            if (d) break;
            else return null;
          case 22:
          case 23:
            return ((b.lanes = 0), dj(a, b, c));
        }
        return Zi(a, b, c);
      }
      var zj, Aj, Bj, Cj;
      zj = function (a, b) {
        for (var c = b.child; null !== c; ) {
          if (5 === c.tag || 6 === c.tag) a.appendChild(c.stateNode);
          else if (4 !== c.tag && null !== c.child) {
            c.child.return = c;
            c = c.child;
            continue;
          }
          if (c === b) break;
          for (; null === c.sibling; ) {
            if (null === c.return || c.return === b) return;
            c = c.return;
          }
          c.sibling.return = c.return;
          c = c.sibling;
        }
      };
      Aj = function () {};
      Bj = function (a, b, c, d) {
        var e = a.memoizedProps;
        if (e !== d) {
          a = b.stateNode;
          xh(uh.current);
          var f = null;
          switch (c) {
            case "input":
              e = Ya(a, e);
              d = Ya(a, d);
              f = [];
              break;
            case "select":
              e = A({}, e, { value: void 0 });
              d = A({}, d, { value: void 0 });
              f = [];
              break;
            case "textarea":
              e = gb(a, e);
              d = gb(a, d);
              f = [];
              break;
            default:
              "function" !== typeof e.onClick &&
                "function" === typeof d.onClick &&
                (a.onclick = Bf);
          }
          ub(c, d);
          var g;
          c = null;
          for (l in e)
            if (!d.hasOwnProperty(l) && e.hasOwnProperty(l) && null != e[l])
              if ("style" === l) {
                var h = e[l];
                for (g in h)
                  h.hasOwnProperty(g) && (c || (c = {}), (c[g] = ""));
              } else
                "dangerouslySetInnerHTML" !== l &&
                  "children" !== l &&
                  "suppressContentEditableWarning" !== l &&
                  "suppressHydrationWarning" !== l &&
                  "autoFocus" !== l &&
                  (ea.hasOwnProperty(l)
                    ? f || (f = [])
                    : (f = f || []).push(l, null));
          for (l in d) {
            var k = d[l];
            h = null != e ? e[l] : void 0;
            if (d.hasOwnProperty(l) && k !== h && (null != k || null != h))
              if ("style" === l)
                if (h) {
                  for (g in h)
                    !h.hasOwnProperty(g) ||
                      (k && k.hasOwnProperty(g)) ||
                      (c || (c = {}), (c[g] = ""));
                  for (g in k)
                    k.hasOwnProperty(g) &&
                      h[g] !== k[g] &&
                      (c || (c = {}), (c[g] = k[g]));
                } else (c || (f || (f = []), f.push(l, c)), (c = k));
              else
                "dangerouslySetInnerHTML" === l
                  ? ((k = k ? k.__html : void 0),
                    (h = h ? h.__html : void 0),
                    null != k && h !== k && (f = f || []).push(l, k))
                  : "children" === l
                    ? ("string" !== typeof k && "number" !== typeof k) ||
                      (f = f || []).push(l, "" + k)
                    : "suppressContentEditableWarning" !== l &&
                      "suppressHydrationWarning" !== l &&
                      (ea.hasOwnProperty(l)
                        ? (null != k && "onScroll" === l && D$1("scroll", a),
                          f || h === k || (f = []))
                        : (f = f || []).push(l, k));
          }
          c && (f = f || []).push("style", c);
          var l = f;
          if ((b.updateQueue = l)) b.flags |= 4;
        }
      };
      Cj = function (a, b, c, d) {
        c !== d && (b.flags |= 4);
      };
      function Dj(a, b) {
        if (!I)
          switch (a.tailMode) {
            case "hidden":
              b = a.tail;
              for (var c = null; null !== b; )
                (null !== b.alternate && (c = b), (b = b.sibling));
              null === c ? (a.tail = null) : (c.sibling = null);
              break;
            case "collapsed":
              c = a.tail;
              for (var d = null; null !== c; )
                (null !== c.alternate && (d = c), (c = c.sibling));
              null === d
                ? b || null === a.tail
                  ? (a.tail = null)
                  : (a.tail.sibling = null)
                : (d.sibling = null);
          }
      }
      function S(a) {
        var b = null !== a.alternate && a.alternate.child === a.child,
          c = 0,
          d = 0;
        if (b)
          for (var e = a.child; null !== e; )
            ((c |= e.lanes | e.childLanes),
              (d |= e.subtreeFlags & 14680064),
              (d |= e.flags & 14680064),
              (e.return = a),
              (e = e.sibling));
        else
          for (e = a.child; null !== e; )
            ((c |= e.lanes | e.childLanes),
              (d |= e.subtreeFlags),
              (d |= e.flags),
              (e.return = a),
              (e = e.sibling));
        a.subtreeFlags |= d;
        a.childLanes = c;
        return b;
      }
      function Ej(a, b, c) {
        var d = b.pendingProps;
        wg(b);
        switch (b.tag) {
          case 2:
          case 16:
          case 15:
          case 0:
          case 11:
          case 7:
          case 8:
          case 12:
          case 9:
          case 14:
            return (S(b), null);
          case 1:
            return (Zf(b.type) && $f(), S(b), null);
          case 3:
            d = b.stateNode;
            zh();
            E$1(Wf);
            E$1(H);
            Eh();
            d.pendingContext &&
              ((d.context = d.pendingContext), (d.pendingContext = null));
            if (null === a || null === a.child)
              Gg(b)
                ? (b.flags |= 4)
                : null === a ||
                  (a.memoizedState.isDehydrated && 0 === (b.flags & 256)) ||
                  ((b.flags |= 1024), null !== zg && (Fj(zg), (zg = null)));
            Aj(a, b);
            S(b);
            return null;
          case 5:
            Bh(b);
            var e = xh(wh.current);
            c = b.type;
            if (null !== a && null != b.stateNode)
              (Bj(a, b, c, d, e),
                a.ref !== b.ref && ((b.flags |= 512), (b.flags |= 2097152)));
            else {
              if (!d) {
                if (null === b.stateNode) throw Error(p(166));
                S(b);
                return null;
              }
              a = xh(uh.current);
              if (Gg(b)) {
                d = b.stateNode;
                c = b.type;
                var f = b.memoizedProps;
                d[Of] = b;
                d[Pf] = f;
                a = 0 !== (b.mode & 1);
                switch (c) {
                  case "dialog":
                    D$1("cancel", d);
                    D$1("close", d);
                    break;
                  case "iframe":
                  case "object":
                  case "embed":
                    D$1("load", d);
                    break;
                  case "video":
                  case "audio":
                    for (e = 0; e < lf.length; e++) D$1(lf[e], d);
                    break;
                  case "source":
                    D$1("error", d);
                    break;
                  case "img":
                  case "image":
                  case "link":
                    D$1("error", d);
                    D$1("load", d);
                    break;
                  case "details":
                    D$1("toggle", d);
                    break;
                  case "input":
                    Za(d, f);
                    D$1("invalid", d);
                    break;
                  case "select":
                    d._wrapperState = { wasMultiple: !!f.multiple };
                    D$1("invalid", d);
                    break;
                  case "textarea":
                    (hb(d, f), D$1("invalid", d));
                }
                ub(c, f);
                e = null;
                for (var g in f)
                  if (f.hasOwnProperty(g)) {
                    var h = f[g];
                    "children" === g
                      ? "string" === typeof h
                        ? d.textContent !== h &&
                          (true !== f.suppressHydrationWarning &&
                            Af(d.textContent, h, a),
                          (e = ["children", h]))
                        : "number" === typeof h &&
                          d.textContent !== "" + h &&
                          (true !== f.suppressHydrationWarning &&
                            Af(d.textContent, h, a),
                          (e = ["children", "" + h]))
                      : ea.hasOwnProperty(g) &&
                        null != h &&
                        "onScroll" === g &&
                        D$1("scroll", d);
                  }
                switch (c) {
                  case "input":
                    Va(d);
                    db(d, f, true);
                    break;
                  case "textarea":
                    Va(d);
                    jb(d);
                    break;
                  case "select":
                  case "option":
                    break;
                  default:
                    "function" === typeof f.onClick && (d.onclick = Bf);
                }
                d = e;
                b.updateQueue = d;
                null !== d && (b.flags |= 4);
              } else {
                g = 9 === e.nodeType ? e : e.ownerDocument;
                "http://www.w3.org/1999/xhtml" === a && (a = kb(c));
                "http://www.w3.org/1999/xhtml" === a
                  ? "script" === c
                    ? ((a = g.createElement("div")),
                      (a.innerHTML = "<script>\x3c/script>"),
                      (a = a.removeChild(a.firstChild)))
                    : "string" === typeof d.is
                      ? (a = g.createElement(c, { is: d.is }))
                      : ((a = g.createElement(c)),
                        "select" === c &&
                          ((g = a),
                          d.multiple
                            ? (g.multiple = true)
                            : d.size && (g.size = d.size)))
                  : (a = g.createElementNS(a, c));
                a[Of] = b;
                a[Pf] = d;
                zj(a, b, false, false);
                b.stateNode = a;
                a: {
                  g = vb(c, d);
                  switch (c) {
                    case "dialog":
                      D$1("cancel", a);
                      D$1("close", a);
                      e = d;
                      break;
                    case "iframe":
                    case "object":
                    case "embed":
                      D$1("load", a);
                      e = d;
                      break;
                    case "video":
                    case "audio":
                      for (e = 0; e < lf.length; e++) D$1(lf[e], a);
                      e = d;
                      break;
                    case "source":
                      D$1("error", a);
                      e = d;
                      break;
                    case "img":
                    case "image":
                    case "link":
                      D$1("error", a);
                      D$1("load", a);
                      e = d;
                      break;
                    case "details":
                      D$1("toggle", a);
                      e = d;
                      break;
                    case "input":
                      Za(a, d);
                      e = Ya(a, d);
                      D$1("invalid", a);
                      break;
                    case "option":
                      e = d;
                      break;
                    case "select":
                      a._wrapperState = { wasMultiple: !!d.multiple };
                      e = A({}, d, { value: void 0 });
                      D$1("invalid", a);
                      break;
                    case "textarea":
                      hb(a, d);
                      e = gb(a, d);
                      D$1("invalid", a);
                      break;
                    default:
                      e = d;
                  }
                  ub(c, e);
                  h = e;
                  for (f in h)
                    if (h.hasOwnProperty(f)) {
                      var k = h[f];
                      "style" === f
                        ? sb(a, k)
                        : "dangerouslySetInnerHTML" === f
                          ? ((k = k ? k.__html : void 0), null != k && nb(a, k))
                          : "children" === f
                            ? "string" === typeof k
                              ? ("textarea" !== c || "" !== k) && ob(a, k)
                              : "number" === typeof k && ob(a, "" + k)
                            : "suppressContentEditableWarning" !== f &&
                              "suppressHydrationWarning" !== f &&
                              "autoFocus" !== f &&
                              (ea.hasOwnProperty(f)
                                ? null != k &&
                                  "onScroll" === f &&
                                  D$1("scroll", a)
                                : null != k && ta(a, f, k, g));
                    }
                  switch (c) {
                    case "input":
                      Va(a);
                      db(a, d, false);
                      break;
                    case "textarea":
                      Va(a);
                      jb(a);
                      break;
                    case "option":
                      null != d.value &&
                        a.setAttribute("value", "" + Sa(d.value));
                      break;
                    case "select":
                      a.multiple = !!d.multiple;
                      f = d.value;
                      null != f
                        ? fb(a, !!d.multiple, f, false)
                        : null != d.defaultValue &&
                          fb(a, !!d.multiple, d.defaultValue, true);
                      break;
                    default:
                      "function" === typeof e.onClick && (a.onclick = Bf);
                  }
                  switch (c) {
                    case "button":
                    case "input":
                    case "select":
                    case "textarea":
                      d = !!d.autoFocus;
                      break a;
                    case "img":
                      d = true;
                      break a;
                    default:
                      d = false;
                  }
                }
                d && (b.flags |= 4);
              }
              null !== b.ref && ((b.flags |= 512), (b.flags |= 2097152));
            }
            S(b);
            return null;
          case 6:
            if (a && null != b.stateNode) Cj(a, b, a.memoizedProps, d);
            else {
              if ("string" !== typeof d && null === b.stateNode)
                throw Error(p(166));
              c = xh(wh.current);
              xh(uh.current);
              if (Gg(b)) {
                d = b.stateNode;
                c = b.memoizedProps;
                d[Of] = b;
                if ((f = d.nodeValue !== c))
                  if (((a = xg), null !== a))
                    switch (a.tag) {
                      case 3:
                        Af(d.nodeValue, c, 0 !== (a.mode & 1));
                        break;
                      case 5:
                        true !== a.memoizedProps.suppressHydrationWarning &&
                          Af(d.nodeValue, c, 0 !== (a.mode & 1));
                    }
                f && (b.flags |= 4);
              } else
                ((d = (9 === c.nodeType ? c : c.ownerDocument).createTextNode(
                  d,
                )),
                  (d[Of] = b),
                  (b.stateNode = d));
            }
            S(b);
            return null;
          case 13:
            E$1(L$1);
            d = b.memoizedState;
            if (
              null === a ||
              (null !== a.memoizedState && null !== a.memoizedState.dehydrated)
            ) {
              if (
                I &&
                null !== yg &&
                0 !== (b.mode & 1) &&
                0 === (b.flags & 128)
              )
                (Hg(), Ig(), (b.flags |= 98560), (f = false));
              else if (((f = Gg(b)), null !== d && null !== d.dehydrated)) {
                if (null === a) {
                  if (!f) throw Error(p(318));
                  f = b.memoizedState;
                  f = null !== f ? f.dehydrated : null;
                  if (!f) throw Error(p(317));
                  f[Of] = b;
                } else
                  (Ig(),
                    0 === (b.flags & 128) && (b.memoizedState = null),
                    (b.flags |= 4));
                S(b);
                f = false;
              } else (null !== zg && (Fj(zg), (zg = null)), (f = true));
              if (!f) return b.flags & 65536 ? b : null;
            }
            if (0 !== (b.flags & 128)) return ((b.lanes = c), b);
            d = null !== d;
            d !== (null !== a && null !== a.memoizedState) &&
              d &&
              ((b.child.flags |= 8192),
              0 !== (b.mode & 1) &&
                (null === a || 0 !== (L$1.current & 1)
                  ? 0 === T && (T = 3)
                  : tj()));
            null !== b.updateQueue && (b.flags |= 4);
            S(b);
            return null;
          case 4:
            return (
              zh(),
              Aj(a, b),
              null === a && sf(b.stateNode.containerInfo),
              S(b),
              null
            );
          case 10:
            return (ah(b.type._context), S(b), null);
          case 17:
            return (Zf(b.type) && $f(), S(b), null);
          case 19:
            E$1(L$1);
            f = b.memoizedState;
            if (null === f) return (S(b), null);
            d = 0 !== (b.flags & 128);
            g = f.rendering;
            if (null === g)
              if (d) Dj(f, false);
              else {
                if (0 !== T || (null !== a && 0 !== (a.flags & 128)))
                  for (a = b.child; null !== a; ) {
                    g = Ch(a);
                    if (null !== g) {
                      b.flags |= 128;
                      Dj(f, false);
                      d = g.updateQueue;
                      null !== d && ((b.updateQueue = d), (b.flags |= 4));
                      b.subtreeFlags = 0;
                      d = c;
                      for (c = b.child; null !== c; )
                        ((f = c),
                          (a = d),
                          (f.flags &= 14680066),
                          (g = f.alternate),
                          null === g
                            ? ((f.childLanes = 0),
                              (f.lanes = a),
                              (f.child = null),
                              (f.subtreeFlags = 0),
                              (f.memoizedProps = null),
                              (f.memoizedState = null),
                              (f.updateQueue = null),
                              (f.dependencies = null),
                              (f.stateNode = null))
                            : ((f.childLanes = g.childLanes),
                              (f.lanes = g.lanes),
                              (f.child = g.child),
                              (f.subtreeFlags = 0),
                              (f.deletions = null),
                              (f.memoizedProps = g.memoizedProps),
                              (f.memoizedState = g.memoizedState),
                              (f.updateQueue = g.updateQueue),
                              (f.type = g.type),
                              (a = g.dependencies),
                              (f.dependencies =
                                null === a
                                  ? null
                                  : {
                                      lanes: a.lanes,
                                      firstContext: a.firstContext,
                                    })),
                          (c = c.sibling));
                      G(L$1, (L$1.current & 1) | 2);
                      return b.child;
                    }
                    a = a.sibling;
                  }
                null !== f.tail &&
                  B() > Gj &&
                  ((b.flags |= 128),
                  (d = true),
                  Dj(f, false),
                  (b.lanes = 4194304));
              }
            else {
              if (!d)
                if (((a = Ch(g)), null !== a)) {
                  if (
                    ((b.flags |= 128),
                    (d = true),
                    (c = a.updateQueue),
                    null !== c && ((b.updateQueue = c), (b.flags |= 4)),
                    Dj(f, true),
                    null === f.tail &&
                      "hidden" === f.tailMode &&
                      !g.alternate &&
                      !I)
                  )
                    return (S(b), null);
                } else
                  2 * B() - f.renderingStartTime > Gj &&
                    1073741824 !== c &&
                    ((b.flags |= 128),
                    (d = true),
                    Dj(f, false),
                    (b.lanes = 4194304));
              f.isBackwards
                ? ((g.sibling = b.child), (b.child = g))
                : ((c = f.last),
                  null !== c ? (c.sibling = g) : (b.child = g),
                  (f.last = g));
            }
            if (null !== f.tail)
              return (
                (b = f.tail),
                (f.rendering = b),
                (f.tail = b.sibling),
                (f.renderingStartTime = B()),
                (b.sibling = null),
                (c = L$1.current),
                G(L$1, d ? (c & 1) | 2 : c & 1),
                b
              );
            S(b);
            return null;
          case 22:
          case 23:
            return (
              Hj(),
              (d = null !== b.memoizedState),
              null !== a &&
                (null !== a.memoizedState) !== d &&
                (b.flags |= 8192),
              d && 0 !== (b.mode & 1)
                ? 0 !== (fj & 1073741824) &&
                  (S(b), b.subtreeFlags & 6 && (b.flags |= 8192))
                : S(b),
              null
            );
          case 24:
            return null;
          case 25:
            return null;
        }
        throw Error(p(156, b.tag));
      }
      function Ij(a, b) {
        wg(b);
        switch (b.tag) {
          case 1:
            return (
              Zf(b.type) && $f(),
              (a = b.flags),
              a & 65536 ? ((b.flags = (a & -65537) | 128), b) : null
            );
          case 3:
            return (
              zh(),
              E$1(Wf),
              E$1(H),
              Eh(),
              (a = b.flags),
              0 !== (a & 65536) && 0 === (a & 128)
                ? ((b.flags = (a & -65537) | 128), b)
                : null
            );
          case 5:
            return (Bh(b), null);
          case 13:
            E$1(L$1);
            a = b.memoizedState;
            if (null !== a && null !== a.dehydrated) {
              if (null === b.alternate) throw Error(p(340));
              Ig();
            }
            a = b.flags;
            return a & 65536 ? ((b.flags = (a & -65537) | 128), b) : null;
          case 19:
            return (E$1(L$1), null);
          case 4:
            return (zh(), null);
          case 10:
            return (ah(b.type._context), null);
          case 22:
          case 23:
            return (Hj(), null);
          case 24:
            return null;
          default:
            return null;
        }
      }
      var Jj = false,
        U = false,
        Kj = "function" === typeof WeakSet ? WeakSet : Set,
        V = null;
      function Lj(a, b) {
        var c = a.ref;
        if (null !== c)
          if ("function" === typeof c)
            try {
              c(null);
            } catch (d) {
              W(a, b, d);
            }
          else c.current = null;
      }
      function Mj(a, b, c) {
        try {
          c();
        } catch (d) {
          W(a, b, d);
        }
      }
      var Nj = false;
      function Oj(a, b) {
        Cf = dd;
        a = Me();
        if (Ne(a)) {
          if ("selectionStart" in a)
            var c = { start: a.selectionStart, end: a.selectionEnd };
          else
            a: {
              c = ((c = a.ownerDocument) && c.defaultView) || window;
              var d = c.getSelection && c.getSelection();
              if (d && 0 !== d.rangeCount) {
                c = d.anchorNode;
                var e = d.anchorOffset,
                  f = d.focusNode;
                d = d.focusOffset;
                try {
                  (c.nodeType, f.nodeType);
                } catch (F) {
                  c = null;
                  break a;
                }
                var g = 0,
                  h = -1,
                  k = -1,
                  l = 0,
                  m = 0,
                  q = a,
                  r = null;
                b: for (;;) {
                  for (var y; ; ) {
                    q !== c || (0 !== e && 3 !== q.nodeType) || (h = g + e);
                    q !== f || (0 !== d && 3 !== q.nodeType) || (k = g + d);
                    3 === q.nodeType && (g += q.nodeValue.length);
                    if (null === (y = q.firstChild)) break;
                    r = q;
                    q = y;
                  }
                  for (;;) {
                    if (q === a) break b;
                    r === c && ++l === e && (h = g);
                    r === f && ++m === d && (k = g);
                    if (null !== (y = q.nextSibling)) break;
                    q = r;
                    r = q.parentNode;
                  }
                  q = y;
                }
                c = -1 === h || -1 === k ? null : { start: h, end: k };
              } else c = null;
            }
          c = c || { start: 0, end: 0 };
        } else c = null;
        Df = { focusedElem: a, selectionRange: c };
        dd = false;
        for (V = b; null !== V; )
          if (
            ((b = V),
            (a = b.child),
            0 !== (b.subtreeFlags & 1028) && null !== a)
          )
            ((a.return = b), (V = a));
          else
            for (; null !== V; ) {
              b = V;
              try {
                var n = b.alternate;
                if (0 !== (b.flags & 1024))
                  switch (b.tag) {
                    case 0:
                    case 11:
                    case 15:
                      break;
                    case 1:
                      if (null !== n) {
                        var t = n.memoizedProps,
                          J = n.memoizedState,
                          x = b.stateNode,
                          w = x.getSnapshotBeforeUpdate(
                            b.elementType === b.type ? t : Ci(b.type, t),
                            J,
                          );
                        x.__reactInternalSnapshotBeforeUpdate = w;
                      }
                      break;
                    case 3:
                      var u = b.stateNode.containerInfo;
                      1 === u.nodeType
                        ? (u.textContent = "")
                        : 9 === u.nodeType &&
                          u.documentElement &&
                          u.removeChild(u.documentElement);
                      break;
                    case 5:
                    case 6:
                    case 4:
                    case 17:
                      break;
                    default:
                      throw Error(p(163));
                  }
              } catch (F) {
                W(b, b.return, F);
              }
              a = b.sibling;
              if (null !== a) {
                a.return = b.return;
                V = a;
                break;
              }
              V = b.return;
            }
        n = Nj;
        Nj = false;
        return n;
      }
      function Pj(a, b, c) {
        var d = b.updateQueue;
        d = null !== d ? d.lastEffect : null;
        if (null !== d) {
          var e = (d = d.next);
          do {
            if ((e.tag & a) === a) {
              var f = e.destroy;
              e.destroy = void 0;
              void 0 !== f && Mj(b, c, f);
            }
            e = e.next;
          } while (e !== d);
        }
      }
      function Qj(a, b) {
        b = b.updateQueue;
        b = null !== b ? b.lastEffect : null;
        if (null !== b) {
          var c = (b = b.next);
          do {
            if ((c.tag & a) === a) {
              var d = c.create;
              c.destroy = d();
            }
            c = c.next;
          } while (c !== b);
        }
      }
      function Rj(a) {
        var b = a.ref;
        if (null !== b) {
          var c = a.stateNode;
          switch (a.tag) {
            case 5:
              a = c;
              break;
            default:
              a = c;
          }
          "function" === typeof b ? b(a) : (b.current = a);
        }
      }
      function Sj(a) {
        var b = a.alternate;
        null !== b && ((a.alternate = null), Sj(b));
        a.child = null;
        a.deletions = null;
        a.sibling = null;
        5 === a.tag &&
          ((b = a.stateNode),
          null !== b &&
            (delete b[Of],
            delete b[Pf],
            delete b[of],
            delete b[Qf],
            delete b[Rf]));
        a.stateNode = null;
        a.return = null;
        a.dependencies = null;
        a.memoizedProps = null;
        a.memoizedState = null;
        a.pendingProps = null;
        a.stateNode = null;
        a.updateQueue = null;
      }
      function Tj(a) {
        return 5 === a.tag || 3 === a.tag || 4 === a.tag;
      }
      function Uj(a) {
        a: for (;;) {
          for (; null === a.sibling; ) {
            if (null === a.return || Tj(a.return)) return null;
            a = a.return;
          }
          a.sibling.return = a.return;
          for (a = a.sibling; 5 !== a.tag && 6 !== a.tag && 18 !== a.tag; ) {
            if (a.flags & 2) continue a;
            if (null === a.child || 4 === a.tag) continue a;
            else ((a.child.return = a), (a = a.child));
          }
          if (!(a.flags & 2)) return a.stateNode;
        }
      }
      function Vj(a, b, c) {
        var d = a.tag;
        if (5 === d || 6 === d)
          ((a = a.stateNode),
            b
              ? 8 === c.nodeType
                ? c.parentNode.insertBefore(a, b)
                : c.insertBefore(a, b)
              : (8 === c.nodeType
                  ? ((b = c.parentNode), b.insertBefore(a, c))
                  : ((b = c), b.appendChild(a)),
                (c = c._reactRootContainer),
                (null !== c && void 0 !== c) ||
                  null !== b.onclick ||
                  (b.onclick = Bf)));
        else if (4 !== d && ((a = a.child), null !== a))
          for (Vj(a, b, c), a = a.sibling; null !== a; )
            (Vj(a, b, c), (a = a.sibling));
      }
      function Wj(a, b, c) {
        var d = a.tag;
        if (5 === d || 6 === d)
          ((a = a.stateNode), b ? c.insertBefore(a, b) : c.appendChild(a));
        else if (4 !== d && ((a = a.child), null !== a))
          for (Wj(a, b, c), a = a.sibling; null !== a; )
            (Wj(a, b, c), (a = a.sibling));
      }
      var X$1 = null,
        Xj = false;
      function Yj(a, b, c) {
        for (c = c.child; null !== c; ) (Zj(a, b, c), (c = c.sibling));
      }
      function Zj(a, b, c) {
        if (lc && "function" === typeof lc.onCommitFiberUnmount)
          try {
            lc.onCommitFiberUnmount(kc, c);
          } catch (h) {}
        switch (c.tag) {
          case 5:
            U || Lj(c, b);
          case 6:
            var d = X$1,
              e = Xj;
            X$1 = null;
            Yj(a, b, c);
            X$1 = d;
            Xj = e;
            null !== X$1 &&
              (Xj
                ? ((a = X$1),
                  (c = c.stateNode),
                  8 === a.nodeType
                    ? a.parentNode.removeChild(c)
                    : a.removeChild(c))
                : X$1.removeChild(c.stateNode));
            break;
          case 18:
            null !== X$1 &&
              (Xj
                ? ((a = X$1),
                  (c = c.stateNode),
                  8 === a.nodeType
                    ? Kf(a.parentNode, c)
                    : 1 === a.nodeType && Kf(a, c),
                  bd(a))
                : Kf(X$1, c.stateNode));
            break;
          case 4:
            d = X$1;
            e = Xj;
            X$1 = c.stateNode.containerInfo;
            Xj = true;
            Yj(a, b, c);
            X$1 = d;
            Xj = e;
            break;
          case 0:
          case 11:
          case 14:
          case 15:
            if (
              !U &&
              ((d = c.updateQueue),
              null !== d && ((d = d.lastEffect), null !== d))
            ) {
              e = d = d.next;
              do {
                var f = e,
                  g = f.destroy;
                f = f.tag;
                void 0 !== g &&
                  (0 !== (f & 2) ? Mj(c, b, g) : 0 !== (f & 4) && Mj(c, b, g));
                e = e.next;
              } while (e !== d);
            }
            Yj(a, b, c);
            break;
          case 1:
            if (
              !U &&
              (Lj(c, b),
              (d = c.stateNode),
              "function" === typeof d.componentWillUnmount)
            )
              try {
                ((d.props = c.memoizedProps),
                  (d.state = c.memoizedState),
                  d.componentWillUnmount());
              } catch (h) {
                W(c, b, h);
              }
            Yj(a, b, c);
            break;
          case 21:
            Yj(a, b, c);
            break;
          case 22:
            c.mode & 1
              ? ((U = (d = U) || null !== c.memoizedState),
                Yj(a, b, c),
                (U = d))
              : Yj(a, b, c);
            break;
          default:
            Yj(a, b, c);
        }
      }
      function ak(a) {
        var b = a.updateQueue;
        if (null !== b) {
          a.updateQueue = null;
          var c = a.stateNode;
          null === c && (c = a.stateNode = new Kj());
          b.forEach(function (b) {
            var d = bk.bind(null, a, b);
            c.has(b) || (c.add(b), b.then(d, d));
          });
        }
      }
      function ck(a, b) {
        var c = b.deletions;
        if (null !== c)
          for (var d = 0; d < c.length; d++) {
            var e = c[d];
            try {
              var f = a,
                g = b,
                h = g;
              a: for (; null !== h; ) {
                switch (h.tag) {
                  case 5:
                    X$1 = h.stateNode;
                    Xj = !1;
                    break a;
                  case 3:
                    X$1 = h.stateNode.containerInfo;
                    Xj = !0;
                    break a;
                  case 4:
                    X$1 = h.stateNode.containerInfo;
                    Xj = !0;
                    break a;
                }
                h = h.return;
              }
              if (null === X$1) throw Error(p(160));
              Zj(f, g, e);
              X$1 = null;
              Xj = !1;
              var k = e.alternate;
              null !== k && (k.return = null);
              e.return = null;
            } catch (l) {
              W(e, b, l);
            }
          }
        if (b.subtreeFlags & 12854)
          for (b = b.child; null !== b; ) (dk(b, a), (b = b.sibling));
      }
      function dk(a, b) {
        var c = a.alternate,
          d = a.flags;
        switch (a.tag) {
          case 0:
          case 11:
          case 14:
          case 15:
            ck(b, a);
            ek(a);
            if (d & 4) {
              try {
                (Pj(3, a, a.return), Qj(3, a));
              } catch (t) {
                W(a, a.return, t);
              }
              try {
                Pj(5, a, a.return);
              } catch (t) {
                W(a, a.return, t);
              }
            }
            break;
          case 1:
            ck(b, a);
            ek(a);
            d & 512 && null !== c && Lj(c, c.return);
            break;
          case 5:
            ck(b, a);
            ek(a);
            d & 512 && null !== c && Lj(c, c.return);
            if (a.flags & 32) {
              var e = a.stateNode;
              try {
                ob(e, "");
              } catch (t) {
                W(a, a.return, t);
              }
            }
            if (d & 4 && ((e = a.stateNode), null != e)) {
              var f = a.memoizedProps,
                g = null !== c ? c.memoizedProps : f,
                h = a.type,
                k = a.updateQueue;
              a.updateQueue = null;
              if (null !== k)
                try {
                  "input" === h &&
                    "radio" === f.type &&
                    null != f.name &&
                    ab(e, f);
                  vb(h, g);
                  var l = vb(h, f);
                  for (g = 0; g < k.length; g += 2) {
                    var m = k[g],
                      q = k[g + 1];
                    "style" === m
                      ? sb(e, q)
                      : "dangerouslySetInnerHTML" === m
                        ? nb(e, q)
                        : "children" === m
                          ? ob(e, q)
                          : ta(e, m, q, l);
                  }
                  switch (h) {
                    case "input":
                      bb(e, f);
                      break;
                    case "textarea":
                      ib(e, f);
                      break;
                    case "select":
                      var r = e._wrapperState.wasMultiple;
                      e._wrapperState.wasMultiple = !!f.multiple;
                      var y = f.value;
                      null != y
                        ? fb(e, !!f.multiple, y, !1)
                        : r !== !!f.multiple &&
                          (null != f.defaultValue
                            ? fb(e, !!f.multiple, f.defaultValue, !0)
                            : fb(e, !!f.multiple, f.multiple ? [] : "", !1));
                  }
                  e[Pf] = f;
                } catch (t) {
                  W(a, a.return, t);
                }
            }
            break;
          case 6:
            ck(b, a);
            ek(a);
            if (d & 4) {
              if (null === a.stateNode) throw Error(p(162));
              e = a.stateNode;
              f = a.memoizedProps;
              try {
                e.nodeValue = f;
              } catch (t) {
                W(a, a.return, t);
              }
            }
            break;
          case 3:
            ck(b, a);
            ek(a);
            if (d & 4 && null !== c && c.memoizedState.isDehydrated)
              try {
                bd(b.containerInfo);
              } catch (t) {
                W(a, a.return, t);
              }
            break;
          case 4:
            ck(b, a);
            ek(a);
            break;
          case 13:
            ck(b, a);
            ek(a);
            e = a.child;
            e.flags & 8192 &&
              ((f = null !== e.memoizedState),
              (e.stateNode.isHidden = f),
              !f ||
                (null !== e.alternate && null !== e.alternate.memoizedState) ||
                (fk = B()));
            d & 4 && ak(a);
            break;
          case 22:
            m = null !== c && null !== c.memoizedState;
            a.mode & 1 ? ((U = (l = U) || m), ck(b, a), (U = l)) : ck(b, a);
            ek(a);
            if (d & 8192) {
              l = null !== a.memoizedState;
              if ((a.stateNode.isHidden = l) && !m && 0 !== (a.mode & 1))
                for (V = a, m = a.child; null !== m; ) {
                  for (q = V = m; null !== V; ) {
                    r = V;
                    y = r.child;
                    switch (r.tag) {
                      case 0:
                      case 11:
                      case 14:
                      case 15:
                        Pj(4, r, r.return);
                        break;
                      case 1:
                        Lj(r, r.return);
                        var n = r.stateNode;
                        if ("function" === typeof n.componentWillUnmount) {
                          d = r;
                          c = r.return;
                          try {
                            ((b = d),
                              (n.props = b.memoizedProps),
                              (n.state = b.memoizedState),
                              n.componentWillUnmount());
                          } catch (t) {
                            W(d, c, t);
                          }
                        }
                        break;
                      case 5:
                        Lj(r, r.return);
                        break;
                      case 22:
                        if (null !== r.memoizedState) {
                          gk(q);
                          continue;
                        }
                    }
                    null !== y ? ((y.return = r), (V = y)) : gk(q);
                  }
                  m = m.sibling;
                }
              a: for (m = null, q = a; ; ) {
                if (5 === q.tag) {
                  if (null === m) {
                    m = q;
                    try {
                      ((e = q.stateNode),
                        l
                          ? ((f = e.style),
                            "function" === typeof f.setProperty
                              ? f.setProperty("display", "none", "important")
                              : (f.display = "none"))
                          : ((h = q.stateNode),
                            (k = q.memoizedProps.style),
                            (g =
                              void 0 !== k &&
                              null !== k &&
                              k.hasOwnProperty("display")
                                ? k.display
                                : null),
                            (h.style.display = rb("display", g))));
                    } catch (t) {
                      W(a, a.return, t);
                    }
                  }
                } else if (6 === q.tag) {
                  if (null === m)
                    try {
                      q.stateNode.nodeValue = l ? "" : q.memoizedProps;
                    } catch (t) {
                      W(a, a.return, t);
                    }
                } else if (
                  ((22 !== q.tag && 23 !== q.tag) ||
                    null === q.memoizedState ||
                    q === a) &&
                  null !== q.child
                ) {
                  q.child.return = q;
                  q = q.child;
                  continue;
                }
                if (q === a) break a;
                for (; null === q.sibling; ) {
                  if (null === q.return || q.return === a) break a;
                  m === q && (m = null);
                  q = q.return;
                }
                m === q && (m = null);
                q.sibling.return = q.return;
                q = q.sibling;
              }
            }
            break;
          case 19:
            ck(b, a);
            ek(a);
            d & 4 && ak(a);
            break;
          case 21:
            break;
          default:
            (ck(b, a), ek(a));
        }
      }
      function ek(a) {
        var b = a.flags;
        if (b & 2) {
          try {
            a: {
              for (var c = a.return; null !== c; ) {
                if (Tj(c)) {
                  var d = c;
                  break a;
                }
                c = c.return;
              }
              throw Error(p(160));
            }
            switch (d.tag) {
              case 5:
                var e = d.stateNode;
                d.flags & 32 && (ob(e, ""), (d.flags &= -33));
                var f = Uj(a);
                Wj(a, f, e);
                break;
              case 3:
              case 4:
                var g = d.stateNode.containerInfo,
                  h = Uj(a);
                Vj(a, h, g);
                break;
              default:
                throw Error(p(161));
            }
          } catch (k) {
            W(a, a.return, k);
          }
          a.flags &= -3;
        }
        b & 4096 && (a.flags &= -4097);
      }
      function hk(a, b, c) {
        V = a;
        ik(a);
      }
      function ik(a, b, c) {
        for (var d = 0 !== (a.mode & 1); null !== V; ) {
          var e = V,
            f = e.child;
          if (22 === e.tag && d) {
            var g = null !== e.memoizedState || Jj;
            if (!g) {
              var h = e.alternate,
                k = (null !== h && null !== h.memoizedState) || U;
              h = Jj;
              var l = U;
              Jj = g;
              if ((U = k) && !l)
                for (V = e; null !== V; )
                  ((g = V),
                    (k = g.child),
                    22 === g.tag && null !== g.memoizedState
                      ? jk(e)
                      : null !== k
                        ? ((k.return = g), (V = k))
                        : jk(e));
              for (; null !== f; ) ((V = f), ik(f), (f = f.sibling));
              V = e;
              Jj = h;
              U = l;
            }
            kk(a);
          } else
            0 !== (e.subtreeFlags & 8772) && null !== f
              ? ((f.return = e), (V = f))
              : kk(a);
        }
      }
      function kk(a) {
        for (; null !== V; ) {
          var b = V;
          if (0 !== (b.flags & 8772)) {
            var c = b.alternate;
            try {
              if (0 !== (b.flags & 8772))
                switch (b.tag) {
                  case 0:
                  case 11:
                  case 15:
                    U || Qj(5, b);
                    break;
                  case 1:
                    var d = b.stateNode;
                    if (b.flags & 4 && !U)
                      if (null === c) d.componentDidMount();
                      else {
                        var e =
                          b.elementType === b.type
                            ? c.memoizedProps
                            : Ci(b.type, c.memoizedProps);
                        d.componentDidUpdate(
                          e,
                          c.memoizedState,
                          d.__reactInternalSnapshotBeforeUpdate,
                        );
                      }
                    var f = b.updateQueue;
                    null !== f && sh(b, f, d);
                    break;
                  case 3:
                    var g = b.updateQueue;
                    if (null !== g) {
                      c = null;
                      if (null !== b.child)
                        switch (b.child.tag) {
                          case 5:
                            c = b.child.stateNode;
                            break;
                          case 1:
                            c = b.child.stateNode;
                        }
                      sh(b, g, c);
                    }
                    break;
                  case 5:
                    var h = b.stateNode;
                    if (null === c && b.flags & 4) {
                      c = h;
                      var k = b.memoizedProps;
                      switch (b.type) {
                        case "button":
                        case "input":
                        case "select":
                        case "textarea":
                          k.autoFocus && c.focus();
                          break;
                        case "img":
                          k.src && (c.src = k.src);
                      }
                    }
                    break;
                  case 6:
                    break;
                  case 4:
                    break;
                  case 12:
                    break;
                  case 13:
                    if (null === b.memoizedState) {
                      var l = b.alternate;
                      if (null !== l) {
                        var m = l.memoizedState;
                        if (null !== m) {
                          var q = m.dehydrated;
                          null !== q && bd(q);
                        }
                      }
                    }
                    break;
                  case 19:
                  case 17:
                  case 21:
                  case 22:
                  case 23:
                  case 25:
                    break;
                  default:
                    throw Error(p(163));
                }
              U || (b.flags & 512 && Rj(b));
            } catch (r) {
              W(b, b.return, r);
            }
          }
          if (b === a) {
            V = null;
            break;
          }
          c = b.sibling;
          if (null !== c) {
            c.return = b.return;
            V = c;
            break;
          }
          V = b.return;
        }
      }
      function gk(a) {
        for (; null !== V; ) {
          var b = V;
          if (b === a) {
            V = null;
            break;
          }
          var c = b.sibling;
          if (null !== c) {
            c.return = b.return;
            V = c;
            break;
          }
          V = b.return;
        }
      }
      function jk(a) {
        for (; null !== V; ) {
          var b = V;
          try {
            switch (b.tag) {
              case 0:
              case 11:
              case 15:
                var c = b.return;
                try {
                  Qj(4, b);
                } catch (k) {
                  W(b, c, k);
                }
                break;
              case 1:
                var d = b.stateNode;
                if ("function" === typeof d.componentDidMount) {
                  var e = b.return;
                  try {
                    d.componentDidMount();
                  } catch (k) {
                    W(b, e, k);
                  }
                }
                var f = b.return;
                try {
                  Rj(b);
                } catch (k) {
                  W(b, f, k);
                }
                break;
              case 5:
                var g = b.return;
                try {
                  Rj(b);
                } catch (k) {
                  W(b, g, k);
                }
            }
          } catch (k) {
            W(b, b.return, k);
          }
          if (b === a) {
            V = null;
            break;
          }
          var h = b.sibling;
          if (null !== h) {
            h.return = b.return;
            V = h;
            break;
          }
          V = b.return;
        }
      }
      var lk = Math.ceil,
        mk = ua.ReactCurrentDispatcher,
        nk = ua.ReactCurrentOwner,
        ok = ua.ReactCurrentBatchConfig,
        K = 0,
        Q = null,
        Y = null,
        Z = 0,
        fj = 0,
        ej = Uf(0),
        T = 0,
        pk = null,
        rh = 0,
        qk = 0,
        rk = 0,
        sk = null,
        tk = null,
        fk = 0,
        Gj = Infinity,
        uk = null,
        Oi = false,
        Pi = null,
        Ri = null,
        vk = false,
        wk = null,
        xk = 0,
        yk = 0,
        zk = null,
        Ak = -1,
        Bk = 0;
      function R() {
        return 0 !== (K & 6) ? B() : -1 !== Ak ? Ak : (Ak = B());
      }
      function yi(a) {
        if (0 === (a.mode & 1)) return 1;
        if (0 !== (K & 2) && 0 !== Z) return Z & -Z;
        if (null !== Kg.transition) return (0 === Bk && (Bk = yc()), Bk);
        a = C;
        if (0 !== a) return a;
        a = window.event;
        a = void 0 === a ? 16 : jd(a.type);
        return a;
      }
      function gi(a, b, c, d) {
        if (50 < yk) throw ((yk = 0), (zk = null), Error(p(185)));
        Ac(a, c, d);
        if (0 === (K & 2) || a !== Q)
          (a === Q && (0 === (K & 2) && (qk |= c), 4 === T && Ck(a, Z)),
            Dk(a, d),
            1 === c &&
              0 === K &&
              0 === (b.mode & 1) &&
              ((Gj = B() + 500), fg && jg()));
      }
      function Dk(a, b) {
        var c = a.callbackNode;
        wc(a, b);
        var d = uc(a, a === Q ? Z : 0);
        if (0 === d)
          (null !== c && bc(c),
            (a.callbackNode = null),
            (a.callbackPriority = 0));
        else if (((b = d & -d), a.callbackPriority !== b)) {
          null != c && bc(c);
          if (1 === b)
            (0 === a.tag ? ig(Ek.bind(null, a)) : hg(Ek.bind(null, a)),
              Jf(function () {
                0 === (K & 6) && jg();
              }),
              (c = null));
          else {
            switch (Dc(d)) {
              case 1:
                c = fc;
                break;
              case 4:
                c = gc;
                break;
              case 16:
                c = hc;
                break;
              case 536870912:
                c = jc;
                break;
              default:
                c = hc;
            }
            c = Fk(c, Gk.bind(null, a));
          }
          a.callbackPriority = b;
          a.callbackNode = c;
        }
      }
      function Gk(a, b) {
        Ak = -1;
        Bk = 0;
        if (0 !== (K & 6)) throw Error(p(327));
        var c = a.callbackNode;
        if (Hk() && a.callbackNode !== c) return null;
        var d = uc(a, a === Q ? Z : 0);
        if (0 === d) return null;
        if (0 !== (d & 30) || 0 !== (d & a.expiredLanes) || b) b = Ik(a, d);
        else {
          b = d;
          var e = K;
          K |= 2;
          var f = Jk();
          if (Q !== a || Z !== b) ((uk = null), (Gj = B() + 500), Kk(a, b));
          do
            try {
              Lk();
              break;
            } catch (h) {
              Mk(a, h);
            }
          while (1);
          $g();
          mk.current = f;
          K = e;
          null !== Y ? (b = 0) : ((Q = null), (Z = 0), (b = T));
        }
        if (0 !== b) {
          2 === b && ((e = xc(a)), 0 !== e && ((d = e), (b = Nk(a, e))));
          if (1 === b) throw ((c = pk), Kk(a, 0), Ck(a, d), Dk(a, B()), c);
          if (6 === b) Ck(a, d);
          else {
            e = a.current.alternate;
            if (
              0 === (d & 30) &&
              !Ok(e) &&
              ((b = Ik(a, d)),
              2 === b && ((f = xc(a)), 0 !== f && ((d = f), (b = Nk(a, f)))),
              1 === b)
            )
              throw ((c = pk), Kk(a, 0), Ck(a, d), Dk(a, B()), c);
            a.finishedWork = e;
            a.finishedLanes = d;
            switch (b) {
              case 0:
              case 1:
                throw Error(p(345));
              case 2:
                Pk(a, tk, uk);
                break;
              case 3:
                Ck(a, d);
                if ((d & 130023424) === d && ((b = fk + 500 - B()), 10 < b)) {
                  if (0 !== uc(a, 0)) break;
                  e = a.suspendedLanes;
                  if ((e & d) !== d) {
                    R();
                    a.pingedLanes |= a.suspendedLanes & e;
                    break;
                  }
                  a.timeoutHandle = Ff(Pk.bind(null, a, tk, uk), b);
                  break;
                }
                Pk(a, tk, uk);
                break;
              case 4:
                Ck(a, d);
                if ((d & 4194240) === d) break;
                b = a.eventTimes;
                for (e = -1; 0 < d; ) {
                  var g = 31 - oc(d);
                  f = 1 << g;
                  g = b[g];
                  g > e && (e = g);
                  d &= ~f;
                }
                d = e;
                d = B() - d;
                d =
                  (120 > d
                    ? 120
                    : 480 > d
                      ? 480
                      : 1080 > d
                        ? 1080
                        : 1920 > d
                          ? 1920
                          : 3e3 > d
                            ? 3e3
                            : 4320 > d
                              ? 4320
                              : 1960 * lk(d / 1960)) - d;
                if (10 < d) {
                  a.timeoutHandle = Ff(Pk.bind(null, a, tk, uk), d);
                  break;
                }
                Pk(a, tk, uk);
                break;
              case 5:
                Pk(a, tk, uk);
                break;
              default:
                throw Error(p(329));
            }
          }
        }
        Dk(a, B());
        return a.callbackNode === c ? Gk.bind(null, a) : null;
      }
      function Nk(a, b) {
        var c = sk;
        a.current.memoizedState.isDehydrated && (Kk(a, b).flags |= 256);
        a = Ik(a, b);
        2 !== a && ((b = tk), (tk = c), null !== b && Fj(b));
        return a;
      }
      function Fj(a) {
        null === tk ? (tk = a) : tk.push.apply(tk, a);
      }
      function Ok(a) {
        for (var b = a; ; ) {
          if (b.flags & 16384) {
            var c = b.updateQueue;
            if (null !== c && ((c = c.stores), null !== c))
              for (var d = 0; d < c.length; d++) {
                var e = c[d],
                  f = e.getSnapshot;
                e = e.value;
                try {
                  if (!He(f(), e)) return !1;
                } catch (g) {
                  return false;
                }
              }
          }
          c = b.child;
          if (b.subtreeFlags & 16384 && null !== c) ((c.return = b), (b = c));
          else {
            if (b === a) break;
            for (; null === b.sibling; ) {
              if (null === b.return || b.return === a) return true;
              b = b.return;
            }
            b.sibling.return = b.return;
            b = b.sibling;
          }
        }
        return true;
      }
      function Ck(a, b) {
        b &= ~rk;
        b &= ~qk;
        a.suspendedLanes |= b;
        a.pingedLanes &= ~b;
        for (a = a.expirationTimes; 0 < b; ) {
          var c = 31 - oc(b),
            d = 1 << c;
          a[c] = -1;
          b &= ~d;
        }
      }
      function Ek(a) {
        if (0 !== (K & 6)) throw Error(p(327));
        Hk();
        var b = uc(a, 0);
        if (0 === (b & 1)) return (Dk(a, B()), null);
        var c = Ik(a, b);
        if (0 !== a.tag && 2 === c) {
          var d = xc(a);
          0 !== d && ((b = d), (c = Nk(a, d)));
        }
        if (1 === c) throw ((c = pk), Kk(a, 0), Ck(a, b), Dk(a, B()), c);
        if (6 === c) throw Error(p(345));
        a.finishedWork = a.current.alternate;
        a.finishedLanes = b;
        Pk(a, tk, uk);
        Dk(a, B());
        return null;
      }
      function Qk(a, b) {
        var c = K;
        K |= 1;
        try {
          return a(b);
        } finally {
          ((K = c), 0 === K && ((Gj = B() + 500), fg && jg()));
        }
      }
      function Rk(a) {
        null !== wk && 0 === wk.tag && 0 === (K & 6) && Hk();
        var b = K;
        K |= 1;
        var c = ok.transition,
          d = C;
        try {
          if (((ok.transition = null), (C = 1), a)) return a();
        } finally {
          ((C = d), (ok.transition = c), (K = b), 0 === (K & 6) && jg());
        }
      }
      function Hj() {
        fj = ej.current;
        E$1(ej);
      }
      function Kk(a, b) {
        a.finishedWork = null;
        a.finishedLanes = 0;
        var c = a.timeoutHandle;
        -1 !== c && ((a.timeoutHandle = -1), Gf(c));
        if (null !== Y)
          for (c = Y.return; null !== c; ) {
            var d = c;
            wg(d);
            switch (d.tag) {
              case 1:
                d = d.type.childContextTypes;
                null !== d && void 0 !== d && $f();
                break;
              case 3:
                zh();
                E$1(Wf);
                E$1(H);
                Eh();
                break;
              case 5:
                Bh(d);
                break;
              case 4:
                zh();
                break;
              case 13:
                E$1(L$1);
                break;
              case 19:
                E$1(L$1);
                break;
              case 10:
                ah(d.type._context);
                break;
              case 22:
              case 23:
                Hj();
            }
            c = c.return;
          }
        Q = a;
        Y = a = Pg(a.current, null);
        Z = fj = b;
        T = 0;
        pk = null;
        rk = qk = rh = 0;
        tk = sk = null;
        if (null !== fh) {
          for (b = 0; b < fh.length; b++)
            if (((c = fh[b]), (d = c.interleaved), null !== d)) {
              c.interleaved = null;
              var e = d.next,
                f = c.pending;
              if (null !== f) {
                var g = f.next;
                f.next = e;
                d.next = g;
              }
              c.pending = d;
            }
          fh = null;
        }
        return a;
      }
      function Mk(a, b) {
        do {
          var c = Y;
          try {
            $g();
            Fh.current = Rh;
            if (Ih) {
              for (var d = M$1.memoizedState; null !== d; ) {
                var e = d.queue;
                null !== e && (e.pending = null);
                d = d.next;
              }
              Ih = !1;
            }
            Hh = 0;
            O = N = M$1 = null;
            Jh = !1;
            Kh = 0;
            nk.current = null;
            if (null === c || null === c.return) {
              T = 1;
              pk = b;
              Y = null;
              break;
            }
            a: {
              var f = a,
                g = c.return,
                h = c,
                k = b;
              b = Z;
              h.flags |= 32768;
              if (
                null !== k &&
                "object" === typeof k &&
                "function" === typeof k.then
              ) {
                var l = k,
                  m = h,
                  q = m.tag;
                if (0 === (m.mode & 1) && (0 === q || 11 === q || 15 === q)) {
                  var r = m.alternate;
                  r
                    ? ((m.updateQueue = r.updateQueue),
                      (m.memoizedState = r.memoizedState),
                      (m.lanes = r.lanes))
                    : ((m.updateQueue = null), (m.memoizedState = null));
                }
                var y = Ui(g);
                if (null !== y) {
                  y.flags &= -257;
                  Vi(y, g, h, f, b);
                  y.mode & 1 && Si(f, l, b);
                  b = y;
                  k = l;
                  var n = b.updateQueue;
                  if (null === n) {
                    var t = new Set();
                    t.add(k);
                    b.updateQueue = t;
                  } else n.add(k);
                  break a;
                } else {
                  if (0 === (b & 1)) {
                    Si(f, l, b);
                    tj();
                    break a;
                  }
                  k = Error(p(426));
                }
              } else if (I && h.mode & 1) {
                var J = Ui(g);
                if (null !== J) {
                  0 === (J.flags & 65536) && (J.flags |= 256);
                  Vi(J, g, h, f, b);
                  Jg(Ji(k, h));
                  break a;
                }
              }
              f = k = Ji(k, h);
              4 !== T && (T = 2);
              null === sk ? (sk = [f]) : sk.push(f);
              f = g;
              do {
                switch (f.tag) {
                  case 3:
                    f.flags |= 65536;
                    b &= -b;
                    f.lanes |= b;
                    var x = Ni(f, k, b);
                    ph(f, x);
                    break a;
                  case 1:
                    h = k;
                    var w = f.type,
                      u = f.stateNode;
                    if (
                      0 === (f.flags & 128) &&
                      ("function" === typeof w.getDerivedStateFromError ||
                        (null !== u &&
                          "function" === typeof u.componentDidCatch &&
                          (null === Ri || !Ri.has(u))))
                    ) {
                      f.flags |= 65536;
                      b &= -b;
                      f.lanes |= b;
                      var F = Qi(f, h, b);
                      ph(f, F);
                      break a;
                    }
                }
                f = f.return;
              } while (null !== f);
            }
            Sk(c);
          } catch (na) {
            b = na;
            Y === c && null !== c && (Y = c = c.return);
            continue;
          }
          break;
        } while (1);
      }
      function Jk() {
        var a = mk.current;
        mk.current = Rh;
        return null === a ? Rh : a;
      }
      function tj() {
        if (0 === T || 3 === T || 2 === T) T = 4;
        null === Q ||
          (0 === (rh & 268435455) && 0 === (qk & 268435455)) ||
          Ck(Q, Z);
      }
      function Ik(a, b) {
        var c = K;
        K |= 2;
        var d = Jk();
        if (Q !== a || Z !== b) ((uk = null), Kk(a, b));
        do
          try {
            Tk();
            break;
          } catch (e) {
            Mk(a, e);
          }
        while (1);
        $g();
        K = c;
        mk.current = d;
        if (null !== Y) throw Error(p(261));
        Q = null;
        Z = 0;
        return T;
      }
      function Tk() {
        for (; null !== Y; ) Uk(Y);
      }
      function Lk() {
        for (; null !== Y && !cc(); ) Uk(Y);
      }
      function Uk(a) {
        var b = Vk(a.alternate, a, fj);
        a.memoizedProps = a.pendingProps;
        null === b ? Sk(a) : (Y = b);
        nk.current = null;
      }
      function Sk(a) {
        var b = a;
        do {
          var c = b.alternate;
          a = b.return;
          if (0 === (b.flags & 32768)) {
            if (((c = Ej(c, b, fj)), null !== c)) {
              Y = c;
              return;
            }
          } else {
            c = Ij(c, b);
            if (null !== c) {
              c.flags &= 32767;
              Y = c;
              return;
            }
            if (null !== a)
              ((a.flags |= 32768), (a.subtreeFlags = 0), (a.deletions = null));
            else {
              T = 6;
              Y = null;
              return;
            }
          }
          b = b.sibling;
          if (null !== b) {
            Y = b;
            return;
          }
          Y = b = a;
        } while (null !== b);
        0 === T && (T = 5);
      }
      function Pk(a, b, c) {
        var d = C,
          e = ok.transition;
        try {
          ((ok.transition = null), (C = 1), Wk(a, b, c, d));
        } finally {
          ((ok.transition = e), (C = d));
        }
        return null;
      }
      function Wk(a, b, c, d) {
        do Hk();
        while (null !== wk);
        if (0 !== (K & 6)) throw Error(p(327));
        c = a.finishedWork;
        var e = a.finishedLanes;
        if (null === c) return null;
        a.finishedWork = null;
        a.finishedLanes = 0;
        if (c === a.current) throw Error(p(177));
        a.callbackNode = null;
        a.callbackPriority = 0;
        var f = c.lanes | c.childLanes;
        Bc(a, f);
        a === Q && ((Y = Q = null), (Z = 0));
        (0 === (c.subtreeFlags & 2064) && 0 === (c.flags & 2064)) ||
          vk ||
          ((vk = true),
          Fk(hc, function () {
            Hk();
            return null;
          }));
        f = 0 !== (c.flags & 15990);
        if (0 !== (c.subtreeFlags & 15990) || f) {
          f = ok.transition;
          ok.transition = null;
          var g = C;
          C = 1;
          var h = K;
          K |= 4;
          nk.current = null;
          Oj(a, c);
          dk(c, a);
          Oe(Df);
          dd = !!Cf;
          Df = Cf = null;
          a.current = c;
          hk(c);
          dc();
          K = h;
          C = g;
          ok.transition = f;
        } else a.current = c;
        vk && ((vk = false), (wk = a), (xk = e));
        f = a.pendingLanes;
        0 === f && (Ri = null);
        mc(c.stateNode);
        Dk(a, B());
        if (null !== b)
          for (d = a.onRecoverableError, c = 0; c < b.length; c++)
            ((e = b[c]),
              d(e.value, { componentStack: e.stack, digest: e.digest }));
        if (Oi) throw ((Oi = false), (a = Pi), (Pi = null), a);
        0 !== (xk & 1) && 0 !== a.tag && Hk();
        f = a.pendingLanes;
        0 !== (f & 1) ? (a === zk ? yk++ : ((yk = 0), (zk = a))) : (yk = 0);
        jg();
        return null;
      }
      function Hk() {
        if (null !== wk) {
          var a = Dc(xk),
            b = ok.transition,
            c = C;
          try {
            ok.transition = null;
            C = 16 > a ? 16 : a;
            if (null === wk) var d = !1;
            else {
              a = wk;
              wk = null;
              xk = 0;
              if (0 !== (K & 6)) throw Error(p(331));
              var e = K;
              K |= 4;
              for (V = a.current; null !== V; ) {
                var f = V,
                  g = f.child;
                if (0 !== (V.flags & 16)) {
                  var h = f.deletions;
                  if (null !== h) {
                    for (var k = 0; k < h.length; k++) {
                      var l = h[k];
                      for (V = l; null !== V; ) {
                        var m = V;
                        switch (m.tag) {
                          case 0:
                          case 11:
                          case 15:
                            Pj(8, m, f);
                        }
                        var q = m.child;
                        if (null !== q) ((q.return = m), (V = q));
                        else
                          for (; null !== V; ) {
                            m = V;
                            var r = m.sibling,
                              y = m.return;
                            Sj(m);
                            if (m === l) {
                              V = null;
                              break;
                            }
                            if (null !== r) {
                              r.return = y;
                              V = r;
                              break;
                            }
                            V = y;
                          }
                      }
                    }
                    var n = f.alternate;
                    if (null !== n) {
                      var t = n.child;
                      if (null !== t) {
                        n.child = null;
                        do {
                          var J = t.sibling;
                          t.sibling = null;
                          t = J;
                        } while (null !== t);
                      }
                    }
                    V = f;
                  }
                }
                if (0 !== (f.subtreeFlags & 2064) && null !== g)
                  ((g.return = f), (V = g));
                else
                  b: for (; null !== V; ) {
                    f = V;
                    if (0 !== (f.flags & 2048))
                      switch (f.tag) {
                        case 0:
                        case 11:
                        case 15:
                          Pj(9, f, f.return);
                      }
                    var x = f.sibling;
                    if (null !== x) {
                      x.return = f.return;
                      V = x;
                      break b;
                    }
                    V = f.return;
                  }
              }
              var w = a.current;
              for (V = w; null !== V; ) {
                g = V;
                var u = g.child;
                if (0 !== (g.subtreeFlags & 2064) && null !== u)
                  ((u.return = g), (V = u));
                else
                  b: for (g = w; null !== V; ) {
                    h = V;
                    if (0 !== (h.flags & 2048))
                      try {
                        switch (h.tag) {
                          case 0:
                          case 11:
                          case 15:
                            Qj(9, h);
                        }
                      } catch (na) {
                        W(h, h.return, na);
                      }
                    if (h === g) {
                      V = null;
                      break b;
                    }
                    var F = h.sibling;
                    if (null !== F) {
                      F.return = h.return;
                      V = F;
                      break b;
                    }
                    V = h.return;
                  }
              }
              K = e;
              jg();
              if (lc && "function" === typeof lc.onPostCommitFiberRoot)
                try {
                  lc.onPostCommitFiberRoot(kc, a);
                } catch (na) {}
              d = !0;
            }
            return d;
          } finally {
            ((C = c), (ok.transition = b));
          }
        }
        return false;
      }
      function Xk(a, b, c) {
        b = Ji(c, b);
        b = Ni(a, b, 1);
        a = nh(a, b, 1);
        b = R();
        null !== a && (Ac(a, 1, b), Dk(a, b));
      }
      function W(a, b, c) {
        if (3 === a.tag) Xk(a, a, c);
        else
          for (; null !== b; ) {
            if (3 === b.tag) {
              Xk(b, a, c);
              break;
            } else if (1 === b.tag) {
              var d = b.stateNode;
              if (
                "function" === typeof b.type.getDerivedStateFromError ||
                ("function" === typeof d.componentDidCatch &&
                  (null === Ri || !Ri.has(d)))
              ) {
                a = Ji(c, a);
                a = Qi(b, a, 1);
                b = nh(b, a, 1);
                a = R();
                null !== b && (Ac(b, 1, a), Dk(b, a));
                break;
              }
            }
            b = b.return;
          }
      }
      function Ti(a, b, c) {
        var d = a.pingCache;
        null !== d && d.delete(b);
        b = R();
        a.pingedLanes |= a.suspendedLanes & c;
        Q === a &&
          (Z & c) === c &&
          (4 === T || (3 === T && (Z & 130023424) === Z && 500 > B() - fk)
            ? Kk(a, 0)
            : (rk |= c));
        Dk(a, b);
      }
      function Yk(a, b) {
        0 === b &&
          (0 === (a.mode & 1)
            ? (b = 1)
            : ((b = sc), (sc <<= 1), 0 === (sc & 130023424) && (sc = 4194304)));
        var c = R();
        a = ih(a, b);
        null !== a && (Ac(a, b, c), Dk(a, c));
      }
      function uj(a) {
        var b = a.memoizedState,
          c = 0;
        null !== b && (c = b.retryLane);
        Yk(a, c);
      }
      function bk(a, b) {
        var c = 0;
        switch (a.tag) {
          case 13:
            var d = a.stateNode;
            var e = a.memoizedState;
            null !== e && (c = e.retryLane);
            break;
          case 19:
            d = a.stateNode;
            break;
          default:
            throw Error(p(314));
        }
        null !== d && d.delete(b);
        Yk(a, c);
      }
      var Vk;
      Vk = function (a, b, c) {
        if (null !== a)
          if (a.memoizedProps !== b.pendingProps || Wf.current) dh = true;
          else {
            if (0 === (a.lanes & c) && 0 === (b.flags & 128))
              return ((dh = false), yj(a, b, c));
            dh = 0 !== (a.flags & 131072) ? true : false;
          }
        else
          ((dh = false), I && 0 !== (b.flags & 1048576) && ug(b, ng, b.index));
        b.lanes = 0;
        switch (b.tag) {
          case 2:
            var d = b.type;
            ij(a, b);
            a = b.pendingProps;
            var e = Yf(b, H.current);
            ch(b, c);
            e = Nh(null, b, d, a, e, c);
            var f = Sh();
            b.flags |= 1;
            "object" === typeof e &&
            null !== e &&
            "function" === typeof e.render &&
            void 0 === e.$$typeof
              ? ((b.tag = 1),
                (b.memoizedState = null),
                (b.updateQueue = null),
                Zf(d) ? ((f = true), cg(b)) : (f = false),
                (b.memoizedState =
                  null !== e.state && void 0 !== e.state ? e.state : null),
                kh(b),
                (e.updater = Ei),
                (b.stateNode = e),
                (e._reactInternals = b),
                Ii(b, d, a, c),
                (b = jj(null, b, d, true, f, c)))
              : ((b.tag = 0),
                I && f && vg(b),
                Xi(null, b, e, c),
                (b = b.child));
            return b;
          case 16:
            d = b.elementType;
            a: {
              ij(a, b);
              a = b.pendingProps;
              e = d._init;
              d = e(d._payload);
              b.type = d;
              e = b.tag = Zk(d);
              a = Ci(d, a);
              switch (e) {
                case 0:
                  b = cj(null, b, d, a, c);
                  break a;
                case 1:
                  b = hj(null, b, d, a, c);
                  break a;
                case 11:
                  b = Yi(null, b, d, a, c);
                  break a;
                case 14:
                  b = $i(null, b, d, Ci(d.type, a), c);
                  break a;
              }
              throw Error(p(306, d, ""));
            }
            return b;
          case 0:
            return (
              (d = b.type),
              (e = b.pendingProps),
              (e = b.elementType === d ? e : Ci(d, e)),
              cj(a, b, d, e, c)
            );
          case 1:
            return (
              (d = b.type),
              (e = b.pendingProps),
              (e = b.elementType === d ? e : Ci(d, e)),
              hj(a, b, d, e, c)
            );
          case 3:
            a: {
              kj(b);
              if (null === a) throw Error(p(387));
              d = b.pendingProps;
              f = b.memoizedState;
              e = f.element;
              lh(a, b);
              qh(b, d, null, c);
              var g = b.memoizedState;
              d = g.element;
              if (f.isDehydrated)
                if (
                  ((f = {
                    element: d,
                    isDehydrated: false,
                    cache: g.cache,
                    pendingSuspenseBoundaries: g.pendingSuspenseBoundaries,
                    transitions: g.transitions,
                  }),
                  (b.updateQueue.baseState = f),
                  (b.memoizedState = f),
                  b.flags & 256)
                ) {
                  e = Ji(Error(p(423)), b);
                  b = lj(a, b, d, c, e);
                  break a;
                } else if (d !== e) {
                  e = Ji(Error(p(424)), b);
                  b = lj(a, b, d, c, e);
                  break a;
                } else
                  for (
                    yg = Lf(b.stateNode.containerInfo.firstChild),
                      xg = b,
                      I = true,
                      zg = null,
                      c = Vg(b, null, d, c),
                      b.child = c;
                    c;
                  )
                    ((c.flags = (c.flags & -3) | 4096), (c = c.sibling));
              else {
                Ig();
                if (d === e) {
                  b = Zi(a, b, c);
                  break a;
                }
                Xi(a, b, d, c);
              }
              b = b.child;
            }
            return b;
          case 5:
            return (
              Ah(b),
              null === a && Eg(b),
              (d = b.type),
              (e = b.pendingProps),
              (f = null !== a ? a.memoizedProps : null),
              (g = e.children),
              Ef(d, e) ? (g = null) : null !== f && Ef(d, f) && (b.flags |= 32),
              gj(a, b),
              Xi(a, b, g, c),
              b.child
            );
          case 6:
            return (null === a && Eg(b), null);
          case 13:
            return oj(a, b, c);
          case 4:
            return (
              yh(b, b.stateNode.containerInfo),
              (d = b.pendingProps),
              null === a ? (b.child = Ug(b, null, d, c)) : Xi(a, b, d, c),
              b.child
            );
          case 11:
            return (
              (d = b.type),
              (e = b.pendingProps),
              (e = b.elementType === d ? e : Ci(d, e)),
              Yi(a, b, d, e, c)
            );
          case 7:
            return (Xi(a, b, b.pendingProps, c), b.child);
          case 8:
            return (Xi(a, b, b.pendingProps.children, c), b.child);
          case 12:
            return (Xi(a, b, b.pendingProps.children, c), b.child);
          case 10:
            a: {
              d = b.type._context;
              e = b.pendingProps;
              f = b.memoizedProps;
              g = e.value;
              G(Wg, d._currentValue);
              d._currentValue = g;
              if (null !== f)
                if (He(f.value, g)) {
                  if (f.children === e.children && !Wf.current) {
                    b = Zi(a, b, c);
                    break a;
                  }
                } else
                  for (
                    f = b.child, null !== f && (f.return = b);
                    null !== f;
                  ) {
                    var h = f.dependencies;
                    if (null !== h) {
                      g = f.child;
                      for (var k = h.firstContext; null !== k; ) {
                        if (k.context === d) {
                          if (1 === f.tag) {
                            k = mh(-1, c & -c);
                            k.tag = 2;
                            var l = f.updateQueue;
                            if (null !== l) {
                              l = l.shared;
                              var m = l.pending;
                              null === m
                                ? (k.next = k)
                                : ((k.next = m.next), (m.next = k));
                              l.pending = k;
                            }
                          }
                          f.lanes |= c;
                          k = f.alternate;
                          null !== k && (k.lanes |= c);
                          bh(f.return, c, b);
                          h.lanes |= c;
                          break;
                        }
                        k = k.next;
                      }
                    } else if (10 === f.tag)
                      g = f.type === b.type ? null : f.child;
                    else if (18 === f.tag) {
                      g = f.return;
                      if (null === g) throw Error(p(341));
                      g.lanes |= c;
                      h = g.alternate;
                      null !== h && (h.lanes |= c);
                      bh(g, c, b);
                      g = f.sibling;
                    } else g = f.child;
                    if (null !== g) g.return = f;
                    else
                      for (g = f; null !== g; ) {
                        if (g === b) {
                          g = null;
                          break;
                        }
                        f = g.sibling;
                        if (null !== f) {
                          f.return = g.return;
                          g = f;
                          break;
                        }
                        g = g.return;
                      }
                    f = g;
                  }
              Xi(a, b, e.children, c);
              b = b.child;
            }
            return b;
          case 9:
            return (
              (e = b.type),
              (d = b.pendingProps.children),
              ch(b, c),
              (e = eh(e)),
              (d = d(e)),
              (b.flags |= 1),
              Xi(a, b, d, c),
              b.child
            );
          case 14:
            return (
              (d = b.type),
              (e = Ci(d, b.pendingProps)),
              (e = Ci(d.type, e)),
              $i(a, b, d, e, c)
            );
          case 15:
            return bj(a, b, b.type, b.pendingProps, c);
          case 17:
            return (
              (d = b.type),
              (e = b.pendingProps),
              (e = b.elementType === d ? e : Ci(d, e)),
              ij(a, b),
              (b.tag = 1),
              Zf(d) ? ((a = true), cg(b)) : (a = false),
              ch(b, c),
              Gi(b, d, e),
              Ii(b, d, e, c),
              jj(null, b, d, true, a, c)
            );
          case 19:
            return xj(a, b, c);
          case 22:
            return dj(a, b, c);
        }
        throw Error(p(156, b.tag));
      };
      function Fk(a, b) {
        return ac(a, b);
      }
      function $k(a, b, c, d) {
        this.tag = a;
        this.key = c;
        this.sibling =
          this.child =
          this.return =
          this.stateNode =
          this.type =
          this.elementType =
            null;
        this.index = 0;
        this.ref = null;
        this.pendingProps = b;
        this.dependencies =
          this.memoizedState =
          this.updateQueue =
          this.memoizedProps =
            null;
        this.mode = d;
        this.subtreeFlags = this.flags = 0;
        this.deletions = null;
        this.childLanes = this.lanes = 0;
        this.alternate = null;
      }
      function Bg(a, b, c, d) {
        return new $k(a, b, c, d);
      }
      function aj(a) {
        a = a.prototype;
        return !(!a || !a.isReactComponent);
      }
      function Zk(a) {
        if ("function" === typeof a) return aj(a) ? 1 : 0;
        if (void 0 !== a && null !== a) {
          a = a.$$typeof;
          if (a === Da) return 11;
          if (a === Ga) return 14;
        }
        return 2;
      }
      function Pg(a, b) {
        var c = a.alternate;
        null === c
          ? ((c = Bg(a.tag, b, a.key, a.mode)),
            (c.elementType = a.elementType),
            (c.type = a.type),
            (c.stateNode = a.stateNode),
            (c.alternate = a),
            (a.alternate = c))
          : ((c.pendingProps = b),
            (c.type = a.type),
            (c.flags = 0),
            (c.subtreeFlags = 0),
            (c.deletions = null));
        c.flags = a.flags & 14680064;
        c.childLanes = a.childLanes;
        c.lanes = a.lanes;
        c.child = a.child;
        c.memoizedProps = a.memoizedProps;
        c.memoizedState = a.memoizedState;
        c.updateQueue = a.updateQueue;
        b = a.dependencies;
        c.dependencies =
          null === b ? null : { lanes: b.lanes, firstContext: b.firstContext };
        c.sibling = a.sibling;
        c.index = a.index;
        c.ref = a.ref;
        return c;
      }
      function Rg(a, b, c, d, e, f) {
        var g = 2;
        d = a;
        if ("function" === typeof a) aj(a) && (g = 1);
        else if ("string" === typeof a) g = 5;
        else
          a: switch (a) {
            case ya:
              return Tg(c.children, e, f, b);
            case za:
              g = 8;
              e |= 8;
              break;
            case Aa:
              return (
                (a = Bg(12, c, b, e | 2)),
                (a.elementType = Aa),
                (a.lanes = f),
                a
              );
            case Ea:
              return (
                (a = Bg(13, c, b, e)),
                (a.elementType = Ea),
                (a.lanes = f),
                a
              );
            case Fa:
              return (
                (a = Bg(19, c, b, e)),
                (a.elementType = Fa),
                (a.lanes = f),
                a
              );
            case Ia:
              return pj(c, e, f, b);
            default:
              if ("object" === typeof a && null !== a)
                switch (a.$$typeof) {
                  case Ba:
                    g = 10;
                    break a;
                  case Ca:
                    g = 9;
                    break a;
                  case Da:
                    g = 11;
                    break a;
                  case Ga:
                    g = 14;
                    break a;
                  case Ha:
                    g = 16;
                    d = null;
                    break a;
                }
              throw Error(p(130, null == a ? a : typeof a, ""));
          }
        b = Bg(g, c, b, e);
        b.elementType = a;
        b.type = d;
        b.lanes = f;
        return b;
      }
      function Tg(a, b, c, d) {
        a = Bg(7, a, d, b);
        a.lanes = c;
        return a;
      }
      function pj(a, b, c, d) {
        a = Bg(22, a, d, b);
        a.elementType = Ia;
        a.lanes = c;
        a.stateNode = { isHidden: false };
        return a;
      }
      function Qg(a, b, c) {
        a = Bg(6, a, null, b);
        a.lanes = c;
        return a;
      }
      function Sg(a, b, c) {
        b = Bg(4, null !== a.children ? a.children : [], a.key, b);
        b.lanes = c;
        b.stateNode = {
          containerInfo: a.containerInfo,
          pendingChildren: null,
          implementation: a.implementation,
        };
        return b;
      }
      function al(a, b, c, d, e) {
        this.tag = b;
        this.containerInfo = a;
        this.finishedWork =
          this.pingCache =
          this.current =
          this.pendingChildren =
            null;
        this.timeoutHandle = -1;
        this.callbackNode = this.pendingContext = this.context = null;
        this.callbackPriority = 0;
        this.eventTimes = zc(0);
        this.expirationTimes = zc(-1);
        this.entangledLanes =
          this.finishedLanes =
          this.mutableReadLanes =
          this.expiredLanes =
          this.pingedLanes =
          this.suspendedLanes =
          this.pendingLanes =
            0;
        this.entanglements = zc(0);
        this.identifierPrefix = d;
        this.onRecoverableError = e;
        this.mutableSourceEagerHydrationData = null;
      }
      function bl(a, b, c, d, e, f, g, h, k) {
        a = new al(a, b, c, h, k);
        1 === b ? ((b = 1), true === f && (b |= 8)) : (b = 0);
        f = Bg(3, null, null, b);
        a.current = f;
        f.stateNode = a;
        f.memoizedState = {
          element: d,
          isDehydrated: c,
          cache: null,
          transitions: null,
          pendingSuspenseBoundaries: null,
        };
        kh(f);
        return a;
      }
      function cl(a, b, c) {
        var d =
          3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
        return {
          $$typeof: wa,
          key: null == d ? null : "" + d,
          children: a,
          containerInfo: b,
          implementation: c,
        };
      }
      function dl(a) {
        if (!a) return Vf;
        a = a._reactInternals;
        a: {
          if (Vb(a) !== a || 1 !== a.tag) throw Error(p(170));
          var b = a;
          do {
            switch (b.tag) {
              case 3:
                b = b.stateNode.context;
                break a;
              case 1:
                if (Zf(b.type)) {
                  b = b.stateNode.__reactInternalMemoizedMergedChildContext;
                  break a;
                }
            }
            b = b.return;
          } while (null !== b);
          throw Error(p(171));
        }
        if (1 === a.tag) {
          var c = a.type;
          if (Zf(c)) return bg(a, c, b);
        }
        return b;
      }
      function el(a, b, c, d, e, f, g, h, k) {
        a = bl(c, d, true, a, e, f, g, h, k);
        a.context = dl(null);
        c = a.current;
        d = R();
        e = yi(c);
        f = mh(d, e);
        f.callback = void 0 !== b && null !== b ? b : null;
        nh(c, f, e);
        a.current.lanes = e;
        Ac(a, e, d);
        Dk(a, d);
        return a;
      }
      function fl(a, b, c, d) {
        var e = b.current,
          f = R(),
          g = yi(e);
        c = dl(c);
        null === b.context ? (b.context = c) : (b.pendingContext = c);
        b = mh(f, g);
        b.payload = { element: a };
        d = void 0 === d ? null : d;
        null !== d && (b.callback = d);
        a = nh(e, b, g);
        null !== a && (gi(a, e, g, f), oh(a, e, g));
        return g;
      }
      function gl(a) {
        a = a.current;
        if (!a.child) return null;
        switch (a.child.tag) {
          case 5:
            return a.child.stateNode;
          default:
            return a.child.stateNode;
        }
      }
      function hl(a, b) {
        a = a.memoizedState;
        if (null !== a && null !== a.dehydrated) {
          var c = a.retryLane;
          a.retryLane = 0 !== c && c < b ? c : b;
        }
      }
      function il(a, b) {
        hl(a, b);
        (a = a.alternate) && hl(a, b);
      }
      function jl() {
        return null;
      }
      var kl =
        "function" === typeof reportError
          ? reportError
          : function (a) {
              console.error(a);
            };
      function ll(a) {
        this._internalRoot = a;
      }
      ml.prototype.render = ll.prototype.render = function (a) {
        var b = this._internalRoot;
        if (null === b) throw Error(p(409));
        fl(a, b, null, null);
      };
      ml.prototype.unmount = ll.prototype.unmount = function () {
        var a = this._internalRoot;
        if (null !== a) {
          this._internalRoot = null;
          var b = a.containerInfo;
          Rk(function () {
            fl(null, a, null, null);
          });
          b[uf] = null;
        }
      };
      function ml(a) {
        this._internalRoot = a;
      }
      ml.prototype.unstable_scheduleHydration = function (a) {
        if (a) {
          var b = Hc();
          a = { blockedOn: null, target: a, priority: b };
          for (var c = 0; c < Qc.length && 0 !== b && b < Qc[c].priority; c++);
          Qc.splice(c, 0, a);
          0 === c && Vc(a);
        }
      };
      function nl(a) {
        return !(
          !a ||
          (1 !== a.nodeType && 9 !== a.nodeType && 11 !== a.nodeType)
        );
      }
      function ol(a) {
        return !(
          !a ||
          (1 !== a.nodeType &&
            9 !== a.nodeType &&
            11 !== a.nodeType &&
            (8 !== a.nodeType ||
              " react-mount-point-unstable " !== a.nodeValue))
        );
      }
      function pl() {}
      function ql(a, b, c, d, e) {
        if (e) {
          if ("function" === typeof d) {
            var f = d;
            d = function () {
              var a = gl(g);
              f.call(a);
            };
          }
          var g = el(b, d, a, 0, null, false, false, "", pl);
          a._reactRootContainer = g;
          a[uf] = g.current;
          sf(8 === a.nodeType ? a.parentNode : a);
          Rk();
          return g;
        }
        for (; (e = a.lastChild); ) a.removeChild(e);
        if ("function" === typeof d) {
          var h = d;
          d = function () {
            var a = gl(k);
            h.call(a);
          };
        }
        var k = bl(a, 0, false, null, null, false, false, "", pl);
        a._reactRootContainer = k;
        a[uf] = k.current;
        sf(8 === a.nodeType ? a.parentNode : a);
        Rk(function () {
          fl(b, k, c, d);
        });
        return k;
      }
      function rl(a, b, c, d, e) {
        var f = c._reactRootContainer;
        if (f) {
          var g = f;
          if ("function" === typeof e) {
            var h = e;
            e = function () {
              var a = gl(g);
              h.call(a);
            };
          }
          fl(b, g, a, e);
        } else g = ql(c, b, a, e, d);
        return gl(g);
      }
      Ec = function (a) {
        switch (a.tag) {
          case 3:
            var b = a.stateNode;
            if (b.current.memoizedState.isDehydrated) {
              var c = tc(b.pendingLanes);
              0 !== c &&
                (Cc(b, c | 1),
                Dk(b, B()),
                0 === (K & 6) && ((Gj = B() + 500), jg()));
            }
            break;
          case 13:
            (Rk(function () {
              var b = ih(a, 1);
              if (null !== b) {
                var c = R();
                gi(b, a, 1, c);
              }
            }),
              il(a, 1));
        }
      };
      Fc = function (a) {
        if (13 === a.tag) {
          var b = ih(a, 134217728);
          if (null !== b) {
            var c = R();
            gi(b, a, 134217728, c);
          }
          il(a, 134217728);
        }
      };
      Gc = function (a) {
        if (13 === a.tag) {
          var b = yi(a),
            c = ih(a, b);
          if (null !== c) {
            var d = R();
            gi(c, a, b, d);
          }
          il(a, b);
        }
      };
      Hc = function () {
        return C;
      };
      Ic = function (a, b) {
        var c = C;
        try {
          return ((C = a), b());
        } finally {
          C = c;
        }
      };
      yb = function (a, b, c) {
        switch (b) {
          case "input":
            bb(a, c);
            b = c.name;
            if ("radio" === c.type && null != b) {
              for (c = a; c.parentNode; ) c = c.parentNode;
              c = c.querySelectorAll(
                "input[name=" + JSON.stringify("" + b) + '][type="radio"]',
              );
              for (b = 0; b < c.length; b++) {
                var d = c[b];
                if (d !== a && d.form === a.form) {
                  var e = Db(d);
                  if (!e) throw Error(p(90));
                  Wa(d);
                  bb(d, e);
                }
              }
            }
            break;
          case "textarea":
            ib(a, c);
            break;
          case "select":
            ((b = c.value), null != b && fb(a, !!c.multiple, b, false));
        }
      };
      Gb = Qk;
      Hb = Rk;
      var sl = {
          usingClientEntryPoint: false,
          Events: [Cb, ue, Db, Eb, Fb, Qk],
        },
        tl = {
          findFiberByHostInstance: Wc,
          bundleType: 0,
          version: "18.3.1",
          rendererPackageName: "react-dom",
        };
      var ul = {
        bundleType: tl.bundleType,
        version: tl.version,
        rendererPackageName: tl.rendererPackageName,
        rendererConfig: tl.rendererConfig,
        overrideHookState: null,
        overrideHookStateDeletePath: null,
        overrideHookStateRenamePath: null,
        overrideProps: null,
        overridePropsDeletePath: null,
        overridePropsRenamePath: null,
        setErrorHandler: null,
        setSuspenseHandler: null,
        scheduleUpdate: null,
        currentDispatcherRef: ua.ReactCurrentDispatcher,
        findHostInstanceByFiber: function (a) {
          a = Zb(a);
          return null === a ? null : a.stateNode;
        },
        findFiberByHostInstance: tl.findFiberByHostInstance || jl,
        findHostInstancesForRefresh: null,
        scheduleRefresh: null,
        scheduleRoot: null,
        setRefreshHandler: null,
        getCurrentFiber: null,
        reconcilerVersion: "18.3.1-next-f1338f8080-20240426",
      };
      if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
        var vl = __REACT_DEVTOOLS_GLOBAL_HOOK__;
        if (!vl.isDisabled && vl.supportsFiber)
          try {
            ((kc = vl.inject(ul)), (lc = vl));
          } catch (a) {}
      }
      reactDom_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED =
        sl;
      reactDom_production_min.createPortal = function (a, b) {
        var c =
          2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
        if (!nl(b)) throw Error(p(200));
        return cl(a, b, null, c);
      };
      reactDom_production_min.createRoot = function (a, b) {
        if (!nl(a)) throw Error(p(299));
        var c = false,
          d = "",
          e = kl;
        null !== b &&
          void 0 !== b &&
          (true === b.unstable_strictMode && (c = true),
          void 0 !== b.identifierPrefix && (d = b.identifierPrefix),
          void 0 !== b.onRecoverableError && (e = b.onRecoverableError));
        b = bl(a, 1, false, null, null, c, false, d, e);
        a[uf] = b.current;
        sf(8 === a.nodeType ? a.parentNode : a);
        return new ll(b);
      };
      reactDom_production_min.findDOMNode = function (a) {
        if (null == a) return null;
        if (1 === a.nodeType) return a;
        var b = a._reactInternals;
        if (void 0 === b) {
          if ("function" === typeof a.render) throw Error(p(188));
          a = Object.keys(a).join(",");
          throw Error(p(268, a));
        }
        a = Zb(b);
        a = null === a ? null : a.stateNode;
        return a;
      };
      reactDom_production_min.flushSync = function (a) {
        return Rk(a);
      };
      reactDom_production_min.hydrate = function (a, b, c) {
        if (!ol(b)) throw Error(p(200));
        return rl(null, a, b, true, c);
      };
      reactDom_production_min.hydrateRoot = function (a, b, c) {
        if (!nl(a)) throw Error(p(405));
        var d = (null != c && c.hydratedSources) || null,
          e = false,
          f = "",
          g = kl;
        null !== c &&
          void 0 !== c &&
          (true === c.unstable_strictMode && (e = true),
          void 0 !== c.identifierPrefix && (f = c.identifierPrefix),
          void 0 !== c.onRecoverableError && (g = c.onRecoverableError));
        b = el(b, null, a, 1, null != c ? c : null, e, false, f, g);
        a[uf] = b.current;
        sf(a);
        if (d)
          for (a = 0; a < d.length; a++)
            ((c = d[a]),
              (e = c._getVersion),
              (e = e(c._source)),
              null == b.mutableSourceEagerHydrationData
                ? (b.mutableSourceEagerHydrationData = [c, e])
                : b.mutableSourceEagerHydrationData.push(c, e));
        return new ml(b);
      };
      reactDom_production_min.render = function (a, b, c) {
        if (!ol(b)) throw Error(p(200));
        return rl(null, a, b, false, c);
      };
      reactDom_production_min.unmountComponentAtNode = function (a) {
        if (!ol(a)) throw Error(p(40));
        return a._reactRootContainer
          ? (Rk(function () {
              rl(null, null, a, !1, function () {
                a._reactRootContainer = null;
                a[uf] = null;
              });
            }),
            true)
          : false;
      };
      reactDom_production_min.unstable_batchedUpdates = Qk;
      reactDom_production_min.unstable_renderSubtreeIntoContainer = function (
        a,
        b,
        c,
        d,
      ) {
        if (!ol(c)) throw Error(p(200));
        if (null == a || void 0 === a._reactInternals) throw Error(p(38));
        return rl(a, b, c, false, d);
      };
      reactDom_production_min.version = "18.3.1-next-f1338f8080-20240426";

      function checkDCE() {
        if (
          typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" ||
          typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function"
        ) {
          return;
        }
        try {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
        } catch (err) {
          console.error(err);
        }
      }
      {
        checkDCE();
        reactDom.exports = reactDom_production_min;
      }

      var reactDomExports = reactDom.exports;
      const vt = /*@__PURE__*/ getDefaultExportFromCjs(reactDomExports);

      var createRoot;
      var m = reactDomExports;
      {
        createRoot = m.createRoot;
        m.hydrateRoot;
      }

      const TOAST_LIMIT = 1;
      const TOAST_REMOVE_DELAY = 1e6;
      let count = 0;
      function genId() {
        count = (count + 1) % Number.MAX_SAFE_INTEGER;
        return count.toString();
      }
      const toastTimeouts = /* @__PURE__ */ new Map();
      const addToRemoveQueue = (toastId) => {
        if (toastTimeouts.has(toastId)) {
          return;
        }
        const timeout = setTimeout(() => {
          toastTimeouts.delete(toastId);
          dispatch({
            type: "REMOVE_TOAST",
            toastId,
          });
        }, TOAST_REMOVE_DELAY);
        toastTimeouts.set(toastId, timeout);
      };
      const reducer = (state, action) => {
        switch (action.type) {
          case "ADD_TOAST":
            return {
              ...state,
              toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT),
            };
          case "UPDATE_TOAST":
            return {
              ...state,
              toasts: state.toasts.map((t) =>
                t.id === action.toast.id ? { ...t, ...action.toast } : t,
              ),
            };
          case "DISMISS_TOAST": {
            const { toastId } = action;
            if (toastId) {
              addToRemoveQueue(toastId);
            } else {
              state.toasts.forEach((toast2) => {
                addToRemoveQueue(toast2.id);
              });
            }
            return {
              ...state,
              toasts: state.toasts.map((t) =>
                t.id === toastId || toastId === void 0
                  ? {
                      ...t,
                      open: false,
                    }
                  : t,
              ),
            };
          }
          case "REMOVE_TOAST":
            if (action.toastId === void 0) {
              return {
                ...state,
                toasts: [],
              };
            }
            return {
              ...state,
              toasts: state.toasts.filter((t) => t.id !== action.toastId),
            };
        }
      };
      const listeners = [];
      let memoryState = { toasts: [] };
      function dispatch(action) {
        memoryState = reducer(memoryState, action);
        listeners.forEach((listener) => {
          listener(memoryState);
        });
      }
      function toast({ ...props }) {
        const id = genId();
        const update = (props2) =>
          dispatch({
            type: "UPDATE_TOAST",
            toast: { ...props2, id },
          });
        const dismiss = () => dispatch({ type: "DISMISS_TOAST", toastId: id });
        dispatch({
          type: "ADD_TOAST",
          toast: {
            ...props,
            id,
            open: true,
            onOpenChange: (open) => {
              if (!open) dismiss();
            },
          },
        });
        return {
          id,
          dismiss,
          update,
        };
      }
      function useToast() {
        const [state, setState] = reactExports.useState(memoryState);
        reactExports.useEffect(() => {
          listeners.push(setState);
          return () => {
            const index = listeners.indexOf(setState);
            if (index > -1) {
              listeners.splice(index, 1);
            }
          };
        }, [state]);
        return {
          ...state,
          toast,
          dismiss: (toastId) => dispatch({ type: "DISMISS_TOAST", toastId }),
        };
      }

      // packages/core/primitive/src/primitive.tsx
      function composeEventHandlers(
        originalEventHandler,
        ourEventHandler,
        { checkForDefaultPrevented = true } = {},
      ) {
        return function handleEvent(event) {
          originalEventHandler?.(event);
          if (checkForDefaultPrevented === false || !event.defaultPrevented) {
            return ourEventHandler?.(event);
          }
        };
      }

      // packages/react/compose-refs/src/compose-refs.tsx
      function setRef$1(ref, value) {
        if (typeof ref === "function") {
          return ref(value);
        } else if (ref !== null && ref !== void 0) {
          ref.current = value;
        }
      }
      function composeRefs$1(...refs) {
        return (node) => {
          let hasCleanup = false;
          const cleanups = refs.map((ref) => {
            const cleanup = setRef$1(ref, node);
            if (!hasCleanup && typeof cleanup == "function") {
              hasCleanup = true;
            }
            return cleanup;
          });
          if (hasCleanup) {
            return () => {
              for (let i = 0; i < cleanups.length; i++) {
                const cleanup = cleanups[i];
                if (typeof cleanup == "function") {
                  cleanup();
                } else {
                  setRef$1(refs[i], null);
                }
              }
            };
          }
        };
      }
      function useComposedRefs$1(...refs) {
        return reactExports.useCallback(composeRefs$1(...refs), refs);
      }

      // packages/react/context/src/create-context.tsx
      function createContextScope(scopeName, createContextScopeDeps = []) {
        let defaultContexts = [];
        function createContext3(rootComponentName, defaultContext) {
          const BaseContext = reactExports.createContext(defaultContext);
          const index = defaultContexts.length;
          defaultContexts = [...defaultContexts, defaultContext];
          const Provider = (props) => {
            const { scope, children, ...context } = props;
            const Context = scope?.[scopeName]?.[index] || BaseContext;
            const value = reactExports.useMemo(
              () => context,
              Object.values(context),
            );
            return /* @__PURE__ */ jsxRuntimeExports.jsx(Context.Provider, {
              value,
              children,
            });
          };
          Provider.displayName = rootComponentName + "Provider";
          function useContext2(consumerName, scope) {
            const Context = scope?.[scopeName]?.[index] || BaseContext;
            const context = reactExports.useContext(Context);
            if (context) return context;
            if (defaultContext !== void 0) return defaultContext;
            throw new Error(
              `\`${consumerName}\` must be used within \`${rootComponentName}\``,
            );
          }
          return [Provider, useContext2];
        }
        const createScope = () => {
          const scopeContexts = defaultContexts.map((defaultContext) => {
            return reactExports.createContext(defaultContext);
          });
          return function useScope(scope) {
            const contexts = scope?.[scopeName] || scopeContexts;
            return reactExports.useMemo(
              () => ({
                [`__scope${scopeName}`]: { ...scope, [scopeName]: contexts },
              }),
              [scope, contexts],
            );
          };
        };
        createScope.scopeName = scopeName;
        return [
          createContext3,
          composeContextScopes(createScope, ...createContextScopeDeps),
        ];
      }
      function composeContextScopes(...scopes) {
        const baseScope = scopes[0];
        if (scopes.length === 1) return baseScope;
        const createScope = () => {
          const scopeHooks = scopes.map((createScope2) => ({
            useScope: createScope2(),
            scopeName: createScope2.scopeName,
          }));
          return function useComposedScopes(overrideScopes) {
            const nextScopes = scopeHooks.reduce(
              (nextScopes2, { useScope, scopeName }) => {
                const scopeProps = useScope(overrideScopes);
                const currentScope = scopeProps[`__scope${scopeName}`];
                return { ...nextScopes2, ...currentScope };
              },
              {},
            );
            return reactExports.useMemo(
              () => ({ [`__scope${baseScope.scopeName}`]: nextScopes }),
              [nextScopes],
            );
          };
        };
        createScope.scopeName = baseScope.scopeName;
        return createScope;
      }

      // src/slot.tsx
      // @__NO_SIDE_EFFECTS__
      function createSlot(ownerName) {
        const SlotClone = /* @__PURE__ */ createSlotClone(ownerName);
        const Slot2 = reactExports.forwardRef((props, forwardedRef) => {
          const { children, ...slotProps } = props;
          const childrenArray = reactExports.Children.toArray(children);
          const slottable = childrenArray.find(isSlottable);
          if (slottable) {
            const newElement = slottable.props.children;
            const newChildren = childrenArray.map((child) => {
              if (child === slottable) {
                if (reactExports.Children.count(newElement) > 1)
                  return reactExports.Children.only(null);
                return reactExports.isValidElement(newElement)
                  ? newElement.props.children
                  : null;
              } else {
                return child;
              }
            });
            return /* @__PURE__ */ jsxRuntimeExports.jsx(SlotClone, {
              ...slotProps,
              ref: forwardedRef,
              children: reactExports.isValidElement(newElement)
                ? reactExports.cloneElement(newElement, void 0, newChildren)
                : null,
            });
          }
          return /* @__PURE__ */ jsxRuntimeExports.jsx(SlotClone, {
            ...slotProps,
            ref: forwardedRef,
            children,
          });
        });
        Slot2.displayName = `${ownerName}.Slot`;
        return Slot2;
      }
      var Slot = /* @__PURE__ */ createSlot("Slot");
      // @__NO_SIDE_EFFECTS__
      function createSlotClone(ownerName) {
        const SlotClone = reactExports.forwardRef((props, forwardedRef) => {
          const { children, ...slotProps } = props;
          if (reactExports.isValidElement(children)) {
            const childrenRef = getElementRef$1(children);
            const props2 = mergeProps(slotProps, children.props);
            if (children.type !== reactExports.Fragment) {
              props2.ref = forwardedRef
                ? composeRefs$1(forwardedRef, childrenRef)
                : childrenRef;
            }
            return reactExports.cloneElement(children, props2);
          }
          return reactExports.Children.count(children) > 1
            ? reactExports.Children.only(null)
            : null;
        });
        SlotClone.displayName = `${ownerName}.SlotClone`;
        return SlotClone;
      }
      var SLOTTABLE_IDENTIFIER = Symbol("radix.slottable");
      // @__NO_SIDE_EFFECTS__
      function createSlottable(ownerName) {
        const Slottable2 = ({ children }) => {
          return /* @__PURE__ */ jsxRuntimeExports.jsx(
            jsxRuntimeExports.Fragment,
            { children },
          );
        };
        Slottable2.displayName = `${ownerName}.Slottable`;
        Slottable2.__radixId = SLOTTABLE_IDENTIFIER;
        return Slottable2;
      }
      function isSlottable(child) {
        return (
          reactExports.isValidElement(child) &&
          typeof child.type === "function" &&
          "__radixId" in child.type &&
          child.type.__radixId === SLOTTABLE_IDENTIFIER
        );
      }
      function mergeProps(slotProps, childProps) {
        const overrideProps = { ...childProps };
        for (const propName in childProps) {
          const slotPropValue = slotProps[propName];
          const childPropValue = childProps[propName];
          const isHandler = /^on[A-Z]/.test(propName);
          if (isHandler) {
            if (slotPropValue && childPropValue) {
              overrideProps[propName] = (...args) => {
                const result = childPropValue(...args);
                slotPropValue(...args);
                return result;
              };
            } else if (slotPropValue) {
              overrideProps[propName] = slotPropValue;
            }
          } else if (propName === "style") {
            overrideProps[propName] = { ...slotPropValue, ...childPropValue };
          } else if (propName === "className") {
            overrideProps[propName] = [slotPropValue, childPropValue]
              .filter(Boolean)
              .join(" ");
          }
        }
        return { ...slotProps, ...overrideProps };
      }
      function getElementRef$1(element) {
        let getter = Object.getOwnPropertyDescriptor(element.props, "ref")?.get;
        let mayWarn =
          getter && "isReactWarning" in getter && getter.isReactWarning;
        if (mayWarn) {
          return element.ref;
        }
        getter = Object.getOwnPropertyDescriptor(element, "ref")?.get;
        mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
        if (mayWarn) {
          return element.props.ref;
        }
        return element.props.ref || element.ref;
      }

      function createCollection(name) {
        const PROVIDER_NAME = name + "CollectionProvider";
        const [createCollectionContext, createCollectionScope] =
          createContextScope(PROVIDER_NAME);
        const [CollectionProviderImpl, useCollectionContext] =
          createCollectionContext(PROVIDER_NAME, {
            collectionRef: { current: null },
            itemMap: /* @__PURE__ */ new Map(),
          });
        const CollectionProvider = (props) => {
          const { scope, children } = props;
          const ref = React.useRef(null);
          const itemMap = React.useRef(/* @__PURE__ */ new Map()).current;
          return /* @__PURE__ */ jsxRuntimeExports.jsx(CollectionProviderImpl, {
            scope,
            itemMap,
            collectionRef: ref,
            children,
          });
        };
        CollectionProvider.displayName = PROVIDER_NAME;
        const COLLECTION_SLOT_NAME = name + "CollectionSlot";
        const CollectionSlotImpl = createSlot(COLLECTION_SLOT_NAME);
        const CollectionSlot = React.forwardRef((props, forwardedRef) => {
          const { scope, children } = props;
          const context = useCollectionContext(COLLECTION_SLOT_NAME, scope);
          const composedRefs = useComposedRefs$1(
            forwardedRef,
            context.collectionRef,
          );
          return /* @__PURE__ */ jsxRuntimeExports.jsx(CollectionSlotImpl, {
            ref: composedRefs,
            children,
          });
        });
        CollectionSlot.displayName = COLLECTION_SLOT_NAME;
        const ITEM_SLOT_NAME = name + "CollectionItemSlot";
        const ITEM_DATA_ATTR = "data-radix-collection-item";
        const CollectionItemSlotImpl = createSlot(ITEM_SLOT_NAME);
        const CollectionItemSlot = React.forwardRef((props, forwardedRef) => {
          const { scope, children, ...itemData } = props;
          const ref = React.useRef(null);
          const composedRefs = useComposedRefs$1(forwardedRef, ref);
          const context = useCollectionContext(ITEM_SLOT_NAME, scope);
          React.useEffect(() => {
            context.itemMap.set(ref, { ref, ...itemData });
            return () => void context.itemMap.delete(ref);
          });
          return /* @__PURE__ */ jsxRuntimeExports.jsx(CollectionItemSlotImpl, {
            ...{ [ITEM_DATA_ATTR]: "" },
            ref: composedRefs,
            children,
          });
        });
        CollectionItemSlot.displayName = ITEM_SLOT_NAME;
        function useCollection(scope) {
          const context = useCollectionContext(
            name + "CollectionConsumer",
            scope,
          );
          const getItems = React.useCallback(() => {
            const collectionNode = context.collectionRef.current;
            if (!collectionNode) return [];
            const orderedNodes = Array.from(
              collectionNode.querySelectorAll(`[${ITEM_DATA_ATTR}]`),
            );
            const items = Array.from(context.itemMap.values());
            const orderedItems = items.sort(
              (a, b) =>
                orderedNodes.indexOf(a.ref.current) -
                orderedNodes.indexOf(b.ref.current),
            );
            return orderedItems;
          }, [context.collectionRef, context.itemMap]);
          return getItems;
        }
        return [
          {
            Provider: CollectionProvider,
            Slot: CollectionSlot,
            ItemSlot: CollectionItemSlot,
          },
          useCollection,
          createCollectionScope,
        ];
      }

      // src/primitive.tsx
      var NODES = [
        "a",
        "button",
        "div",
        "form",
        "h2",
        "h3",
        "img",
        "input",
        "label",
        "li",
        "nav",
        "ol",
        "p",
        "select",
        "span",
        "svg",
        "ul",
      ];
      var Primitive = NODES.reduce((primitive, node) => {
        const Slot = createSlot(`Primitive.${node}`);
        const Node = reactExports.forwardRef((props, forwardedRef) => {
          const { asChild, ...primitiveProps } = props;
          const Comp = asChild ? Slot : node;
          if (typeof window !== "undefined") {
            window[Symbol.for("radix-ui")] = true;
          }
          return /* @__PURE__ */ jsxRuntimeExports.jsx(Comp, {
            ...primitiveProps,
            ref: forwardedRef,
          });
        });
        Node.displayName = `Primitive.${node}`;
        return { ...primitive, [node]: Node };
      }, {});
      function dispatchDiscreteCustomEvent(target, event) {
        if (target)
          reactDomExports.flushSync(() => target.dispatchEvent(event));
      }

      // packages/react/use-callback-ref/src/use-callback-ref.tsx
      function useCallbackRef(callback) {
        const callbackRef = reactExports.useRef(callback);
        reactExports.useEffect(() => {
          callbackRef.current = callback;
        });
        return reactExports.useMemo(
          () =>
            (...args) =>
              callbackRef.current?.(...args),
          [],
        );
      }

      // packages/react/use-escape-keydown/src/use-escape-keydown.tsx
      function useEscapeKeydown(
        onEscapeKeyDownProp,
        ownerDocument = globalThis?.document,
      ) {
        const onEscapeKeyDown = useCallbackRef(onEscapeKeyDownProp);
        reactExports.useEffect(() => {
          const handleKeyDown = (event) => {
            if (event.key === "Escape") {
              onEscapeKeyDown(event);
            }
          };
          ownerDocument.addEventListener("keydown", handleKeyDown, {
            capture: true,
          });
          return () =>
            ownerDocument.removeEventListener("keydown", handleKeyDown, {
              capture: true,
            });
        }, [onEscapeKeyDown, ownerDocument]);
      }

      var DISMISSABLE_LAYER_NAME = "DismissableLayer";
      var CONTEXT_UPDATE = "dismissableLayer.update";
      var POINTER_DOWN_OUTSIDE = "dismissableLayer.pointerDownOutside";
      var FOCUS_OUTSIDE = "dismissableLayer.focusOutside";
      var originalBodyPointerEvents;
      var DismissableLayerContext = reactExports.createContext({
        layers: /* @__PURE__ */ new Set(),
        layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
        branches: /* @__PURE__ */ new Set(),
      });
      var DismissableLayer = reactExports.forwardRef((props, forwardedRef) => {
        const {
          disableOutsidePointerEvents = false,
          onEscapeKeyDown,
          onPointerDownOutside,
          onFocusOutside,
          onInteractOutside,
          onDismiss,
          ...layerProps
        } = props;
        const context = reactExports.useContext(DismissableLayerContext);
        const [node, setNode] = reactExports.useState(null);
        const ownerDocument = node?.ownerDocument ?? globalThis?.document;
        const [, force] = reactExports.useState({});
        const composedRefs = useComposedRefs$1(forwardedRef, (node2) =>
          setNode(node2),
        );
        const layers = Array.from(context.layers);
        const [highestLayerWithOutsidePointerEventsDisabled] = [
          ...context.layersWithOutsidePointerEventsDisabled,
        ].slice(-1);
        const highestLayerWithOutsidePointerEventsDisabledIndex =
          layers.indexOf(highestLayerWithOutsidePointerEventsDisabled);
        const index = node ? layers.indexOf(node) : -1;
        const isBodyPointerEventsDisabled =
          context.layersWithOutsidePointerEventsDisabled.size > 0;
        const isPointerEventsEnabled =
          index >= highestLayerWithOutsidePointerEventsDisabledIndex;
        const pointerDownOutside = usePointerDownOutside((event) => {
          const target = event.target;
          const isPointerDownOnBranch = [...context.branches].some((branch) =>
            branch.contains(target),
          );
          if (!isPointerEventsEnabled || isPointerDownOnBranch) return;
          onPointerDownOutside?.(event);
          onInteractOutside?.(event);
          if (!event.defaultPrevented) onDismiss?.();
        }, ownerDocument);
        const focusOutside = useFocusOutside((event) => {
          const target = event.target;
          const isFocusInBranch = [...context.branches].some((branch) =>
            branch.contains(target),
          );
          if (isFocusInBranch) return;
          onFocusOutside?.(event);
          onInteractOutside?.(event);
          if (!event.defaultPrevented) onDismiss?.();
        }, ownerDocument);
        useEscapeKeydown((event) => {
          const isHighestLayer = index === context.layers.size - 1;
          if (!isHighestLayer) return;
          onEscapeKeyDown?.(event);
          if (!event.defaultPrevented && onDismiss) {
            event.preventDefault();
            onDismiss();
          }
        }, ownerDocument);
        reactExports.useEffect(() => {
          if (!node) return;
          if (disableOutsidePointerEvents) {
            if (context.layersWithOutsidePointerEventsDisabled.size === 0) {
              originalBodyPointerEvents =
                ownerDocument.body.style.pointerEvents;
              ownerDocument.body.style.pointerEvents = "none";
            }
            context.layersWithOutsidePointerEventsDisabled.add(node);
          }
          context.layers.add(node);
          dispatchUpdate();
          return () => {
            if (
              disableOutsidePointerEvents &&
              context.layersWithOutsidePointerEventsDisabled.size === 1
            ) {
              ownerDocument.body.style.pointerEvents =
                originalBodyPointerEvents;
            }
          };
        }, [node, ownerDocument, disableOutsidePointerEvents, context]);
        reactExports.useEffect(() => {
          return () => {
            if (!node) return;
            context.layers.delete(node);
            context.layersWithOutsidePointerEventsDisabled.delete(node);
            dispatchUpdate();
          };
        }, [node, context]);
        reactExports.useEffect(() => {
          const handleUpdate = () => force({});
          document.addEventListener(CONTEXT_UPDATE, handleUpdate);
          return () =>
            document.removeEventListener(CONTEXT_UPDATE, handleUpdate);
        }, []);
        return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.div, {
          ...layerProps,
          ref: composedRefs,
          style: {
            pointerEvents: isBodyPointerEventsDisabled
              ? isPointerEventsEnabled
                ? "auto"
                : "none"
              : void 0,
            ...props.style,
          },
          onFocusCapture: composeEventHandlers(
            props.onFocusCapture,
            focusOutside.onFocusCapture,
          ),
          onBlurCapture: composeEventHandlers(
            props.onBlurCapture,
            focusOutside.onBlurCapture,
          ),
          onPointerDownCapture: composeEventHandlers(
            props.onPointerDownCapture,
            pointerDownOutside.onPointerDownCapture,
          ),
        });
      });
      DismissableLayer.displayName = DISMISSABLE_LAYER_NAME;
      var BRANCH_NAME = "DismissableLayerBranch";
      var DismissableLayerBranch = reactExports.forwardRef(
        (props, forwardedRef) => {
          const context = reactExports.useContext(DismissableLayerContext);
          const ref = reactExports.useRef(null);
          const composedRefs = useComposedRefs$1(forwardedRef, ref);
          reactExports.useEffect(() => {
            const node = ref.current;
            if (node) {
              context.branches.add(node);
              return () => {
                context.branches.delete(node);
              };
            }
          }, [context.branches]);
          return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.div, {
            ...props,
            ref: composedRefs,
          });
        },
      );
      DismissableLayerBranch.displayName = BRANCH_NAME;
      function usePointerDownOutside(
        onPointerDownOutside,
        ownerDocument = globalThis?.document,
      ) {
        const handlePointerDownOutside = useCallbackRef(onPointerDownOutside);
        const isPointerInsideReactTreeRef = reactExports.useRef(false);
        const handleClickRef = reactExports.useRef(() => {});
        reactExports.useEffect(() => {
          const handlePointerDown = (event) => {
            if (event.target && !isPointerInsideReactTreeRef.current) {
              let handleAndDispatchPointerDownOutsideEvent2 = function () {
                handleAndDispatchCustomEvent$1(
                  POINTER_DOWN_OUTSIDE,
                  handlePointerDownOutside,
                  eventDetail,
                  { discrete: true },
                );
              };
              const eventDetail = { originalEvent: event };
              if (event.pointerType === "touch") {
                ownerDocument.removeEventListener(
                  "click",
                  handleClickRef.current,
                );
                handleClickRef.current =
                  handleAndDispatchPointerDownOutsideEvent2;
                ownerDocument.addEventListener(
                  "click",
                  handleClickRef.current,
                  { once: true },
                );
              } else {
                handleAndDispatchPointerDownOutsideEvent2();
              }
            } else {
              ownerDocument.removeEventListener(
                "click",
                handleClickRef.current,
              );
            }
            isPointerInsideReactTreeRef.current = false;
          };
          const timerId = window.setTimeout(() => {
            ownerDocument.addEventListener("pointerdown", handlePointerDown);
          }, 0);
          return () => {
            window.clearTimeout(timerId);
            ownerDocument.removeEventListener("pointerdown", handlePointerDown);
            ownerDocument.removeEventListener("click", handleClickRef.current);
          };
        }, [ownerDocument, handlePointerDownOutside]);
        return {
          // ensures we check React component tree (not just DOM tree)
          onPointerDownCapture: () =>
            (isPointerInsideReactTreeRef.current = true),
        };
      }
      function useFocusOutside(
        onFocusOutside,
        ownerDocument = globalThis?.document,
      ) {
        const handleFocusOutside = useCallbackRef(onFocusOutside);
        const isFocusInsideReactTreeRef = reactExports.useRef(false);
        reactExports.useEffect(() => {
          const handleFocus = (event) => {
            if (event.target && !isFocusInsideReactTreeRef.current) {
              const eventDetail = { originalEvent: event };
              handleAndDispatchCustomEvent$1(
                FOCUS_OUTSIDE,
                handleFocusOutside,
                eventDetail,
                {
                  discrete: false,
                },
              );
            }
          };
          ownerDocument.addEventListener("focusin", handleFocus);
          return () =>
            ownerDocument.removeEventListener("focusin", handleFocus);
        }, [ownerDocument, handleFocusOutside]);
        return {
          onFocusCapture: () => (isFocusInsideReactTreeRef.current = true),
          onBlurCapture: () => (isFocusInsideReactTreeRef.current = false),
        };
      }
      function dispatchUpdate() {
        const event = new CustomEvent(CONTEXT_UPDATE);
        document.dispatchEvent(event);
      }
      function handleAndDispatchCustomEvent$1(
        name,
        handler,
        detail,
        { discrete },
      ) {
        const target = detail.originalEvent.target;
        const event = new CustomEvent(name, {
          bubbles: false,
          cancelable: true,
          detail,
        });
        if (handler) target.addEventListener(name, handler, { once: true });
        if (discrete) {
          dispatchDiscreteCustomEvent(target, event);
        } else {
          target.dispatchEvent(event);
        }
      }
      var Root$2 = DismissableLayer;
      var Branch = DismissableLayerBranch;

      // packages/react/use-layout-effect/src/use-layout-effect.tsx
      var useLayoutEffect2 = globalThis?.document
        ? reactExports.useLayoutEffect
        : () => {};

      var PORTAL_NAME$1 = "Portal";
      var Portal = reactExports.forwardRef((props, forwardedRef) => {
        const { container: containerProp, ...portalProps } = props;
        const [mounted, setMounted] = reactExports.useState(false);
        useLayoutEffect2(() => setMounted(true), []);
        const container =
          containerProp || (mounted && globalThis?.document?.body);
        return container
          ? vt.createPortal(
              /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.div, {
                ...portalProps,
                ref: forwardedRef,
              }),
              container,
            )
          : null;
      });
      Portal.displayName = PORTAL_NAME$1;

      function useStateMachine(initialState, machine) {
        return reactExports.useReducer((state, event) => {
          const nextState = machine[state][event];
          return nextState ?? state;
        }, initialState);
      }

      // src/presence.tsx
      var Presence = (props) => {
        const { present, children } = props;
        const presence = usePresence$1(present);
        const child =
          typeof children === "function"
            ? children({ present: presence.isPresent })
            : reactExports.Children.only(children);
        const ref = useComposedRefs$1(presence.ref, getElementRef(child));
        const forceMount = typeof children === "function";
        return forceMount || presence.isPresent
          ? reactExports.cloneElement(child, { ref })
          : null;
      };
      Presence.displayName = "Presence";
      function usePresence$1(present) {
        const [node, setNode] = reactExports.useState();
        const stylesRef = reactExports.useRef(null);
        const prevPresentRef = reactExports.useRef(present);
        const prevAnimationNameRef = reactExports.useRef("none");
        const initialState = present ? "mounted" : "unmounted";
        const [state, send] = useStateMachine(initialState, {
          mounted: {
            UNMOUNT: "unmounted",
            ANIMATION_OUT: "unmountSuspended",
          },
          unmountSuspended: {
            MOUNT: "mounted",
            ANIMATION_END: "unmounted",
          },
          unmounted: {
            MOUNT: "mounted",
          },
        });
        reactExports.useEffect(() => {
          const currentAnimationName = getAnimationName(stylesRef.current);
          prevAnimationNameRef.current =
            state === "mounted" ? currentAnimationName : "none";
        }, [state]);
        useLayoutEffect2(() => {
          const styles = stylesRef.current;
          const wasPresent = prevPresentRef.current;
          const hasPresentChanged = wasPresent !== present;
          if (hasPresentChanged) {
            const prevAnimationName = prevAnimationNameRef.current;
            const currentAnimationName = getAnimationName(styles);
            if (present) {
              send("MOUNT");
            } else if (
              currentAnimationName === "none" ||
              styles?.display === "none"
            ) {
              send("UNMOUNT");
            } else {
              const isAnimating = prevAnimationName !== currentAnimationName;
              if (wasPresent && isAnimating) {
                send("ANIMATION_OUT");
              } else {
                send("UNMOUNT");
              }
            }
            prevPresentRef.current = present;
          }
        }, [present, send]);
        useLayoutEffect2(() => {
          if (node) {
            let timeoutId;
            const ownerWindow = node.ownerDocument.defaultView ?? window;
            const handleAnimationEnd = (event) => {
              const currentAnimationName = getAnimationName(stylesRef.current);
              const isCurrentAnimation = currentAnimationName.includes(
                event.animationName,
              );
              if (event.target === node && isCurrentAnimation) {
                send("ANIMATION_END");
                if (!prevPresentRef.current) {
                  const currentFillMode = node.style.animationFillMode;
                  node.style.animationFillMode = "forwards";
                  timeoutId = ownerWindow.setTimeout(() => {
                    if (node.style.animationFillMode === "forwards") {
                      node.style.animationFillMode = currentFillMode;
                    }
                  });
                }
              }
            };
            const handleAnimationStart = (event) => {
              if (event.target === node) {
                prevAnimationNameRef.current = getAnimationName(
                  stylesRef.current,
                );
              }
            };
            node.addEventListener("animationstart", handleAnimationStart);
            node.addEventListener("animationcancel", handleAnimationEnd);
            node.addEventListener("animationend", handleAnimationEnd);
            return () => {
              ownerWindow.clearTimeout(timeoutId);
              node.removeEventListener("animationstart", handleAnimationStart);
              node.removeEventListener("animationcancel", handleAnimationEnd);
              node.removeEventListener("animationend", handleAnimationEnd);
            };
          } else {
            send("ANIMATION_END");
          }
        }, [node, send]);
        return {
          isPresent: ["mounted", "unmountSuspended"].includes(state),
          ref: reactExports.useCallback((node2) => {
            stylesRef.current = node2 ? getComputedStyle(node2) : null;
            setNode(node2);
          }, []),
        };
      }
      function getAnimationName(styles) {
        return styles?.animationName || "none";
      }
      function getElementRef(element) {
        let getter = Object.getOwnPropertyDescriptor(element.props, "ref")?.get;
        let mayWarn =
          getter && "isReactWarning" in getter && getter.isReactWarning;
        if (mayWarn) {
          return element.ref;
        }
        getter = Object.getOwnPropertyDescriptor(element, "ref")?.get;
        mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
        if (mayWarn) {
          return element.props.ref;
        }
        return element.props.ref || element.ref;
      }

      // src/use-controllable-state.tsx
      var useInsertionEffect =
        React$1[" useInsertionEffect ".trim().toString()] || useLayoutEffect2;
      function useControllableState({
        prop,
        defaultProp,
        onChange = () => {},
        caller,
      }) {
        const [uncontrolledProp, setUncontrolledProp, onChangeRef] =
          useUncontrolledState({
            defaultProp,
            onChange,
          });
        const isControlled = prop !== void 0;
        const value = isControlled ? prop : uncontrolledProp;
        {
          const isControlledRef = reactExports.useRef(prop !== void 0);
          reactExports.useEffect(() => {
            const wasControlled = isControlledRef.current;
            if (wasControlled !== isControlled) {
              const from = wasControlled ? "controlled" : "uncontrolled";
              const to = isControlled ? "controlled" : "uncontrolled";
              console.warn(
                `${caller} is changing from ${from} to ${to}. Components should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled value for the lifetime of the component.`,
              );
            }
            isControlledRef.current = isControlled;
          }, [isControlled, caller]);
        }
        const setValue = reactExports.useCallback(
          (nextValue) => {
            if (isControlled) {
              const value2 = isFunction(nextValue)
                ? nextValue(prop)
                : nextValue;
              if (value2 !== prop) {
                onChangeRef.current?.(value2);
              }
            } else {
              setUncontrolledProp(nextValue);
            }
          },
          [isControlled, prop, setUncontrolledProp, onChangeRef],
        );
        return [value, setValue];
      }
      function useUncontrolledState({ defaultProp, onChange }) {
        const [value, setValue] = reactExports.useState(defaultProp);
        const prevValueRef = reactExports.useRef(value);
        const onChangeRef = reactExports.useRef(onChange);
        useInsertionEffect(() => {
          onChangeRef.current = onChange;
        }, [onChange]);
        reactExports.useEffect(() => {
          if (prevValueRef.current !== value) {
            onChangeRef.current?.(value);
            prevValueRef.current = value;
          }
        }, [value, prevValueRef]);
        return [value, setValue, onChangeRef];
      }
      function isFunction(value) {
        return typeof value === "function";
      }

      // src/visually-hidden.tsx
      var VISUALLY_HIDDEN_STYLES = Object.freeze({
        // See: https://github.com/twbs/bootstrap/blob/main/scss/mixins/_visually-hidden.scss
        position: "absolute",
        border: 0,
        width: 1,
        height: 1,
        padding: 0,
        margin: -1,
        overflow: "hidden",
        clip: "rect(0, 0, 0, 0)",
        whiteSpace: "nowrap",
        wordWrap: "normal",
      });
      var NAME$1 = "VisuallyHidden";
      var VisuallyHidden = reactExports.forwardRef((props, forwardedRef) => {
        return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.span, {
          ...props,
          ref: forwardedRef,
          style: { ...VISUALLY_HIDDEN_STYLES, ...props.style },
        });
      });
      VisuallyHidden.displayName = NAME$1;
      var Root$1 = VisuallyHidden;

      var PROVIDER_NAME$1 = "ToastProvider";
      var [Collection, useCollection, createCollectionScope] =
        createCollection("Toast");
      var [createToastContext] = createContextScope("Toast", [
        createCollectionScope,
      ]);
      var [ToastProviderProvider, useToastProviderContext] =
        createToastContext(PROVIDER_NAME$1);
      var ToastProvider$1 = (props) => {
        const {
          __scopeToast,
          label = "Notification",
          duration = 5e3,
          swipeDirection = "right",
          swipeThreshold = 50,
          children,
        } = props;
        const [viewport, setViewport] = reactExports.useState(null);
        const [toastCount, setToastCount] = reactExports.useState(0);
        const isFocusedToastEscapeKeyDownRef = reactExports.useRef(false);
        const isClosePausedRef = reactExports.useRef(false);
        if (!label.trim()) {
          console.error(
            `Invalid prop \`label\` supplied to \`${PROVIDER_NAME$1}\`. Expected non-empty \`string\`.`,
          );
        }
        return /* @__PURE__ */ jsxRuntimeExports.jsx(Collection.Provider, {
          scope: __scopeToast,
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            ToastProviderProvider,
            {
              scope: __scopeToast,
              label,
              duration,
              swipeDirection,
              swipeThreshold,
              toastCount,
              viewport,
              onViewportChange: setViewport,
              onToastAdd: reactExports.useCallback(
                () => setToastCount((prevCount) => prevCount + 1),
                [],
              ),
              onToastRemove: reactExports.useCallback(
                () => setToastCount((prevCount) => prevCount - 1),
                [],
              ),
              isFocusedToastEscapeKeyDownRef,
              isClosePausedRef,
              children,
            },
          ),
        });
      };
      ToastProvider$1.displayName = PROVIDER_NAME$1;
      var VIEWPORT_NAME = "ToastViewport";
      var VIEWPORT_DEFAULT_HOTKEY = ["F8"];
      var VIEWPORT_PAUSE = "toast.viewportPause";
      var VIEWPORT_RESUME = "toast.viewportResume";
      var ToastViewport$1 = reactExports.forwardRef((props, forwardedRef) => {
        const {
          __scopeToast,
          hotkey = VIEWPORT_DEFAULT_HOTKEY,
          label = "Notifications ({hotkey})",
          ...viewportProps
        } = props;
        const context = useToastProviderContext(VIEWPORT_NAME, __scopeToast);
        const getItems = useCollection(__scopeToast);
        const wrapperRef = reactExports.useRef(null);
        const headFocusProxyRef = reactExports.useRef(null);
        const tailFocusProxyRef = reactExports.useRef(null);
        const ref = reactExports.useRef(null);
        const composedRefs = useComposedRefs$1(
          forwardedRef,
          ref,
          context.onViewportChange,
        );
        const hotkeyLabel = hotkey
          .join("+")
          .replace(/Key/g, "")
          .replace(/Digit/g, "");
        const hasToasts = context.toastCount > 0;
        reactExports.useEffect(() => {
          const handleKeyDown = (event) => {
            const isHotkeyPressed =
              hotkey.length !== 0 &&
              hotkey.every((key) => event[key] || event.code === key);
            if (isHotkeyPressed) ref.current?.focus();
          };
          document.addEventListener("keydown", handleKeyDown);
          return () => document.removeEventListener("keydown", handleKeyDown);
        }, [hotkey]);
        reactExports.useEffect(() => {
          const wrapper = wrapperRef.current;
          const viewport = ref.current;
          if (hasToasts && wrapper && viewport) {
            const handlePause = () => {
              if (!context.isClosePausedRef.current) {
                const pauseEvent = new CustomEvent(VIEWPORT_PAUSE);
                viewport.dispatchEvent(pauseEvent);
                context.isClosePausedRef.current = true;
              }
            };
            const handleResume = () => {
              if (context.isClosePausedRef.current) {
                const resumeEvent = new CustomEvent(VIEWPORT_RESUME);
                viewport.dispatchEvent(resumeEvent);
                context.isClosePausedRef.current = false;
              }
            };
            const handleFocusOutResume = (event) => {
              const isFocusMovingOutside = !wrapper.contains(
                event.relatedTarget,
              );
              if (isFocusMovingOutside) handleResume();
            };
            const handlePointerLeaveResume = () => {
              const isFocusInside = wrapper.contains(document.activeElement);
              if (!isFocusInside) handleResume();
            };
            wrapper.addEventListener("focusin", handlePause);
            wrapper.addEventListener("focusout", handleFocusOutResume);
            wrapper.addEventListener("pointermove", handlePause);
            wrapper.addEventListener("pointerleave", handlePointerLeaveResume);
            window.addEventListener("blur", handlePause);
            window.addEventListener("focus", handleResume);
            return () => {
              wrapper.removeEventListener("focusin", handlePause);
              wrapper.removeEventListener("focusout", handleFocusOutResume);
              wrapper.removeEventListener("pointermove", handlePause);
              wrapper.removeEventListener(
                "pointerleave",
                handlePointerLeaveResume,
              );
              window.removeEventListener("blur", handlePause);
              window.removeEventListener("focus", handleResume);
            };
          }
        }, [hasToasts, context.isClosePausedRef]);
        const getSortedTabbableCandidates = reactExports.useCallback(
          ({ tabbingDirection }) => {
            const toastItems = getItems();
            const tabbableCandidates = toastItems.map((toastItem) => {
              const toastNode = toastItem.ref.current;
              const toastTabbableCandidates = [
                toastNode,
                ...getTabbableCandidates(toastNode),
              ];
              return tabbingDirection === "forwards"
                ? toastTabbableCandidates
                : toastTabbableCandidates.reverse();
            });
            return (
              tabbingDirection === "forwards"
                ? tabbableCandidates.reverse()
                : tabbableCandidates
            ).flat();
          },
          [getItems],
        );
        reactExports.useEffect(() => {
          const viewport = ref.current;
          if (viewport) {
            const handleKeyDown = (event) => {
              const isMetaKey = event.altKey || event.ctrlKey || event.metaKey;
              const isTabKey = event.key === "Tab" && !isMetaKey;
              if (isTabKey) {
                const focusedElement = document.activeElement;
                const isTabbingBackwards = event.shiftKey;
                const targetIsViewport = event.target === viewport;
                if (targetIsViewport && isTabbingBackwards) {
                  headFocusProxyRef.current?.focus();
                  return;
                }
                const tabbingDirection = isTabbingBackwards
                  ? "backwards"
                  : "forwards";
                const sortedCandidates = getSortedTabbableCandidates({
                  tabbingDirection,
                });
                const index = sortedCandidates.findIndex(
                  (candidate) => candidate === focusedElement,
                );
                if (focusFirst(sortedCandidates.slice(index + 1))) {
                  event.preventDefault();
                } else {
                  isTabbingBackwards
                    ? headFocusProxyRef.current?.focus()
                    : tailFocusProxyRef.current?.focus();
                }
              }
            };
            viewport.addEventListener("keydown", handleKeyDown);
            return () => viewport.removeEventListener("keydown", handleKeyDown);
          }
        }, [getItems, getSortedTabbableCandidates]);
        return /* @__PURE__ */ jsxRuntimeExports.jsxs(Branch, {
          ref: wrapperRef,
          role: "region",
          "aria-label": label.replace("{hotkey}", hotkeyLabel),
          tabIndex: -1,
          style: { pointerEvents: hasToasts ? void 0 : "none" },
          children: [
            hasToasts &&
              /* @__PURE__ */ jsxRuntimeExports.jsx(FocusProxy, {
                ref: headFocusProxyRef,
                onFocusFromOutsideViewport: () => {
                  const tabbableCandidates = getSortedTabbableCandidates({
                    tabbingDirection: "forwards",
                  });
                  focusFirst(tabbableCandidates);
                },
              }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Collection.Slot, {
              scope: __scopeToast,
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.ol, {
                tabIndex: -1,
                ...viewportProps,
                ref: composedRefs,
              }),
            }),
            hasToasts &&
              /* @__PURE__ */ jsxRuntimeExports.jsx(FocusProxy, {
                ref: tailFocusProxyRef,
                onFocusFromOutsideViewport: () => {
                  const tabbableCandidates = getSortedTabbableCandidates({
                    tabbingDirection: "backwards",
                  });
                  focusFirst(tabbableCandidates);
                },
              }),
          ],
        });
      });
      ToastViewport$1.displayName = VIEWPORT_NAME;
      var FOCUS_PROXY_NAME = "ToastFocusProxy";
      var FocusProxy = reactExports.forwardRef((props, forwardedRef) => {
        const { __scopeToast, onFocusFromOutsideViewport, ...proxyProps } =
          props;
        const context = useToastProviderContext(FOCUS_PROXY_NAME, __scopeToast);
        return /* @__PURE__ */ jsxRuntimeExports.jsx(VisuallyHidden, {
          "aria-hidden": true,
          tabIndex: 0,
          ...proxyProps,
          ref: forwardedRef,
          style: { position: "fixed" },
          onFocus: (event) => {
            const prevFocusedElement = event.relatedTarget;
            const isFocusFromOutsideViewport =
              !context.viewport?.contains(prevFocusedElement);
            if (isFocusFromOutsideViewport) onFocusFromOutsideViewport();
          },
        });
      });
      FocusProxy.displayName = FOCUS_PROXY_NAME;
      var TOAST_NAME = "Toast";
      var TOAST_SWIPE_START = "toast.swipeStart";
      var TOAST_SWIPE_MOVE = "toast.swipeMove";
      var TOAST_SWIPE_CANCEL = "toast.swipeCancel";
      var TOAST_SWIPE_END = "toast.swipeEnd";
      var Toast$1 = reactExports.forwardRef((props, forwardedRef) => {
        const {
          forceMount,
          open: openProp,
          defaultOpen,
          onOpenChange,
          ...toastProps
        } = props;
        const [open, setOpen] = useControllableState({
          prop: openProp,
          defaultProp: defaultOpen ?? true,
          onChange: onOpenChange,
          caller: TOAST_NAME,
        });
        return /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, {
          present: forceMount || open,
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(ToastImpl, {
            open,
            ...toastProps,
            ref: forwardedRef,
            onClose: () => setOpen(false),
            onPause: useCallbackRef(props.onPause),
            onResume: useCallbackRef(props.onResume),
            onSwipeStart: composeEventHandlers(props.onSwipeStart, (event) => {
              event.currentTarget.setAttribute("data-swipe", "start");
            }),
            onSwipeMove: composeEventHandlers(props.onSwipeMove, (event) => {
              const { x, y } = event.detail.delta;
              event.currentTarget.setAttribute("data-swipe", "move");
              event.currentTarget.style.setProperty(
                "--radix-toast-swipe-move-x",
                `${x}px`,
              );
              event.currentTarget.style.setProperty(
                "--radix-toast-swipe-move-y",
                `${y}px`,
              );
            }),
            onSwipeCancel: composeEventHandlers(
              props.onSwipeCancel,
              (event) => {
                event.currentTarget.setAttribute("data-swipe", "cancel");
                event.currentTarget.style.removeProperty(
                  "--radix-toast-swipe-move-x",
                );
                event.currentTarget.style.removeProperty(
                  "--radix-toast-swipe-move-y",
                );
                event.currentTarget.style.removeProperty(
                  "--radix-toast-swipe-end-x",
                );
                event.currentTarget.style.removeProperty(
                  "--radix-toast-swipe-end-y",
                );
              },
            ),
            onSwipeEnd: composeEventHandlers(props.onSwipeEnd, (event) => {
              const { x, y } = event.detail.delta;
              event.currentTarget.setAttribute("data-swipe", "end");
              event.currentTarget.style.removeProperty(
                "--radix-toast-swipe-move-x",
              );
              event.currentTarget.style.removeProperty(
                "--radix-toast-swipe-move-y",
              );
              event.currentTarget.style.setProperty(
                "--radix-toast-swipe-end-x",
                `${x}px`,
              );
              event.currentTarget.style.setProperty(
                "--radix-toast-swipe-end-y",
                `${y}px`,
              );
              setOpen(false);
            }),
          }),
        });
      });
      Toast$1.displayName = TOAST_NAME;
      var [ToastInteractiveProvider, useToastInteractiveContext] =
        createToastContext(TOAST_NAME, {
          onClose() {},
        });
      var ToastImpl = reactExports.forwardRef((props, forwardedRef) => {
        const {
          __scopeToast,
          type = "foreground",
          duration: durationProp,
          open,
          onClose,
          onEscapeKeyDown,
          onPause,
          onResume,
          onSwipeStart,
          onSwipeMove,
          onSwipeCancel,
          onSwipeEnd,
          ...toastProps
        } = props;
        const context = useToastProviderContext(TOAST_NAME, __scopeToast);
        const [node, setNode] = reactExports.useState(null);
        const composedRefs = useComposedRefs$1(forwardedRef, (node2) =>
          setNode(node2),
        );
        const pointerStartRef = reactExports.useRef(null);
        const swipeDeltaRef = reactExports.useRef(null);
        const duration = durationProp || context.duration;
        const closeTimerStartTimeRef = reactExports.useRef(0);
        const closeTimerRemainingTimeRef = reactExports.useRef(duration);
        const closeTimerRef = reactExports.useRef(0);
        const { onToastAdd, onToastRemove } = context;
        const handleClose = useCallbackRef(() => {
          const isFocusInToast = node?.contains(document.activeElement);
          if (isFocusInToast) context.viewport?.focus();
          onClose();
        });
        const startTimer = reactExports.useCallback(
          (duration2) => {
            if (!duration2 || duration2 === Infinity) return;
            window.clearTimeout(closeTimerRef.current);
            closeTimerStartTimeRef.current =
              /* @__PURE__ */ new Date().getTime();
            closeTimerRef.current = window.setTimeout(handleClose, duration2);
          },
          [handleClose],
        );
        reactExports.useEffect(() => {
          const viewport = context.viewport;
          if (viewport) {
            const handleResume = () => {
              startTimer(closeTimerRemainingTimeRef.current);
              onResume?.();
            };
            const handlePause = () => {
              const elapsedTime =
                /* @__PURE__ */ new Date().getTime() -
                closeTimerStartTimeRef.current;
              closeTimerRemainingTimeRef.current =
                closeTimerRemainingTimeRef.current - elapsedTime;
              window.clearTimeout(closeTimerRef.current);
              onPause?.();
            };
            viewport.addEventListener(VIEWPORT_PAUSE, handlePause);
            viewport.addEventListener(VIEWPORT_RESUME, handleResume);
            return () => {
              viewport.removeEventListener(VIEWPORT_PAUSE, handlePause);
              viewport.removeEventListener(VIEWPORT_RESUME, handleResume);
            };
          }
        }, [context.viewport, duration, onPause, onResume, startTimer]);
        reactExports.useEffect(() => {
          if (open && !context.isClosePausedRef.current) startTimer(duration);
        }, [open, duration, context.isClosePausedRef, startTimer]);
        reactExports.useEffect(() => {
          onToastAdd();
          return () => onToastRemove();
        }, [onToastAdd, onToastRemove]);
        const announceTextContent = reactExports.useMemo(() => {
          return node ? getAnnounceTextContent(node) : null;
        }, [node]);
        if (!context.viewport) return null;
        return /* @__PURE__ */ jsxRuntimeExports.jsxs(
          jsxRuntimeExports.Fragment,
          {
            children: [
              announceTextContent &&
                /* @__PURE__ */ jsxRuntimeExports.jsx(ToastAnnounce, {
                  __scopeToast,
                  role: "status",
                  "aria-live": type === "foreground" ? "assertive" : "polite",
                  "aria-atomic": true,
                  children: announceTextContent,
                }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(ToastInteractiveProvider, {
                scope: __scopeToast,
                onClose: handleClose,
                children: reactDomExports.createPortal(
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Collection.ItemSlot, {
                    scope: __scopeToast,
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx(Root$2, {
                      asChild: true,
                      onEscapeKeyDown: composeEventHandlers(
                        onEscapeKeyDown,
                        () => {
                          if (!context.isFocusedToastEscapeKeyDownRef.current)
                            handleClose();
                          context.isFocusedToastEscapeKeyDownRef.current = false;
                        },
                      ),
                      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                        Primitive.li,
                        {
                          role: "status",
                          "aria-live": "off",
                          "aria-atomic": true,
                          tabIndex: 0,
                          "data-state": open ? "open" : "closed",
                          "data-swipe-direction": context.swipeDirection,
                          ...toastProps,
                          ref: composedRefs,
                          style: {
                            userSelect: "none",
                            touchAction: "none",
                            ...props.style,
                          },
                          onKeyDown: composeEventHandlers(
                            props.onKeyDown,
                            (event) => {
                              if (event.key !== "Escape") return;
                              onEscapeKeyDown?.(event.nativeEvent);
                              if (!event.nativeEvent.defaultPrevented) {
                                context.isFocusedToastEscapeKeyDownRef.current = true;
                                handleClose();
                              }
                            },
                          ),
                          onPointerDown: composeEventHandlers(
                            props.onPointerDown,
                            (event) => {
                              if (event.button !== 0) return;
                              pointerStartRef.current = {
                                x: event.clientX,
                                y: event.clientY,
                              };
                            },
                          ),
                          onPointerMove: composeEventHandlers(
                            props.onPointerMove,
                            (event) => {
                              if (!pointerStartRef.current) return;
                              const x =
                                event.clientX - pointerStartRef.current.x;
                              const y =
                                event.clientY - pointerStartRef.current.y;
                              const hasSwipeMoveStarted = Boolean(
                                swipeDeltaRef.current,
                              );
                              const isHorizontalSwipe = [
                                "left",
                                "right",
                              ].includes(context.swipeDirection);
                              const clamp = ["left", "up"].includes(
                                context.swipeDirection,
                              )
                                ? Math.min
                                : Math.max;
                              const clampedX = isHorizontalSwipe
                                ? clamp(0, x)
                                : 0;
                              const clampedY = !isHorizontalSwipe
                                ? clamp(0, y)
                                : 0;
                              const moveStartBuffer =
                                event.pointerType === "touch" ? 10 : 2;
                              const delta = { x: clampedX, y: clampedY };
                              const eventDetail = {
                                originalEvent: event,
                                delta,
                              };
                              if (hasSwipeMoveStarted) {
                                swipeDeltaRef.current = delta;
                                handleAndDispatchCustomEvent(
                                  TOAST_SWIPE_MOVE,
                                  onSwipeMove,
                                  eventDetail,
                                  {
                                    discrete: false,
                                  },
                                );
                              } else if (
                                isDeltaInDirection(
                                  delta,
                                  context.swipeDirection,
                                  moveStartBuffer,
                                )
                              ) {
                                swipeDeltaRef.current = delta;
                                handleAndDispatchCustomEvent(
                                  TOAST_SWIPE_START,
                                  onSwipeStart,
                                  eventDetail,
                                  {
                                    discrete: false,
                                  },
                                );
                                event.target.setPointerCapture(event.pointerId);
                              } else if (
                                Math.abs(x) > moveStartBuffer ||
                                Math.abs(y) > moveStartBuffer
                              ) {
                                pointerStartRef.current = null;
                              }
                            },
                          ),
                          onPointerUp: composeEventHandlers(
                            props.onPointerUp,
                            (event) => {
                              const delta = swipeDeltaRef.current;
                              const target = event.target;
                              if (target.hasPointerCapture(event.pointerId)) {
                                target.releasePointerCapture(event.pointerId);
                              }
                              swipeDeltaRef.current = null;
                              pointerStartRef.current = null;
                              if (delta) {
                                const toast = event.currentTarget;
                                const eventDetail = {
                                  originalEvent: event,
                                  delta,
                                };
                                if (
                                  isDeltaInDirection(
                                    delta,
                                    context.swipeDirection,
                                    context.swipeThreshold,
                                  )
                                ) {
                                  handleAndDispatchCustomEvent(
                                    TOAST_SWIPE_END,
                                    onSwipeEnd,
                                    eventDetail,
                                    {
                                      discrete: true,
                                    },
                                  );
                                } else {
                                  handleAndDispatchCustomEvent(
                                    TOAST_SWIPE_CANCEL,
                                    onSwipeCancel,
                                    eventDetail,
                                    {
                                      discrete: true,
                                    },
                                  );
                                }
                                toast.addEventListener(
                                  "click",
                                  (event2) => event2.preventDefault(),
                                  {
                                    once: true,
                                  },
                                );
                              }
                            },
                          ),
                        },
                      ),
                    }),
                  }),
                  context.viewport,
                ),
              }),
            ],
          },
        );
      });
      var ToastAnnounce = (props) => {
        const { __scopeToast, children, ...announceProps } = props;
        const context = useToastProviderContext(TOAST_NAME, __scopeToast);
        const [renderAnnounceText, setRenderAnnounceText] =
          reactExports.useState(false);
        const [isAnnounced, setIsAnnounced] = reactExports.useState(false);
        useNextFrame(() => setRenderAnnounceText(true));
        reactExports.useEffect(() => {
          const timer = window.setTimeout(() => setIsAnnounced(true), 1e3);
          return () => window.clearTimeout(timer);
        }, []);
        return isAnnounced
          ? null
          : /* @__PURE__ */ jsxRuntimeExports.jsx(Portal, {
              asChild: true,
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(VisuallyHidden, {
                ...announceProps,
                children:
                  renderAnnounceText &&
                  /* @__PURE__ */ jsxRuntimeExports.jsxs(
                    jsxRuntimeExports.Fragment,
                    { children: [context.label, " ", children] },
                  ),
              }),
            });
      };
      var TITLE_NAME = "ToastTitle";
      var ToastTitle$1 = reactExports.forwardRef((props, forwardedRef) => {
        const { __scopeToast, ...titleProps } = props;
        return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.div, {
          ...titleProps,
          ref: forwardedRef,
        });
      });
      ToastTitle$1.displayName = TITLE_NAME;
      var DESCRIPTION_NAME = "ToastDescription";
      var ToastDescription$1 = reactExports.forwardRef(
        (props, forwardedRef) => {
          const { __scopeToast, ...descriptionProps } = props;
          return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.div, {
            ...descriptionProps,
            ref: forwardedRef,
          });
        },
      );
      ToastDescription$1.displayName = DESCRIPTION_NAME;
      var ACTION_NAME = "ToastAction";
      var ToastAction$1 = reactExports.forwardRef((props, forwardedRef) => {
        const { altText, ...actionProps } = props;
        if (!altText.trim()) {
          console.error(
            `Invalid prop \`altText\` supplied to \`${ACTION_NAME}\`. Expected non-empty \`string\`.`,
          );
          return null;
        }
        return /* @__PURE__ */ jsxRuntimeExports.jsx(ToastAnnounceExclude, {
          altText,
          asChild: true,
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(ToastClose$1, {
            ...actionProps,
            ref: forwardedRef,
          }),
        });
      });
      ToastAction$1.displayName = ACTION_NAME;
      var CLOSE_NAME = "ToastClose";
      var ToastClose$1 = reactExports.forwardRef((props, forwardedRef) => {
        const { __scopeToast, ...closeProps } = props;
        const interactiveContext = useToastInteractiveContext(
          CLOSE_NAME,
          __scopeToast,
        );
        return /* @__PURE__ */ jsxRuntimeExports.jsx(ToastAnnounceExclude, {
          asChild: true,
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.button, {
            type: "button",
            ...closeProps,
            ref: forwardedRef,
            onClick: composeEventHandlers(
              props.onClick,
              interactiveContext.onClose,
            ),
          }),
        });
      });
      ToastClose$1.displayName = CLOSE_NAME;
      var ToastAnnounceExclude = reactExports.forwardRef(
        (props, forwardedRef) => {
          const { __scopeToast, altText, ...announceExcludeProps } = props;
          return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.div, {
            "data-radix-toast-announce-exclude": "",
            "data-radix-toast-announce-alt": altText || void 0,
            ...announceExcludeProps,
            ref: forwardedRef,
          });
        },
      );
      function getAnnounceTextContent(container) {
        const textContent = [];
        const childNodes = Array.from(container.childNodes);
        childNodes.forEach((node) => {
          if (node.nodeType === node.TEXT_NODE && node.textContent)
            textContent.push(node.textContent);
          if (isHTMLElement$2(node)) {
            const isHidden =
              node.ariaHidden || node.hidden || node.style.display === "none";
            const isExcluded = node.dataset.radixToastAnnounceExclude === "";
            if (!isHidden) {
              if (isExcluded) {
                const altText = node.dataset.radixToastAnnounceAlt;
                if (altText) textContent.push(altText);
              } else {
                textContent.push(...getAnnounceTextContent(node));
              }
            }
          }
        });
        return textContent;
      }
      function handleAndDispatchCustomEvent(
        name,
        handler,
        detail,
        { discrete },
      ) {
        const currentTarget = detail.originalEvent.currentTarget;
        const event = new CustomEvent(name, {
          bubbles: true,
          cancelable: true,
          detail,
        });
        if (handler)
          currentTarget.addEventListener(name, handler, { once: true });
        if (discrete) {
          dispatchDiscreteCustomEvent(currentTarget, event);
        } else {
          currentTarget.dispatchEvent(event);
        }
      }
      var isDeltaInDirection = (delta, direction, threshold = 0) => {
        const deltaX = Math.abs(delta.x);
        const deltaY = Math.abs(delta.y);
        const isDeltaX = deltaX > deltaY;
        if (direction === "left" || direction === "right") {
          return isDeltaX && deltaX > threshold;
        } else {
          return !isDeltaX && deltaY > threshold;
        }
      };
      function useNextFrame(callback = () => {}) {
        const fn = useCallbackRef(callback);
        useLayoutEffect2(() => {
          let raf1 = 0;
          let raf2 = 0;
          raf1 = window.requestAnimationFrame(
            () => (raf2 = window.requestAnimationFrame(fn)),
          );
          return () => {
            window.cancelAnimationFrame(raf1);
            window.cancelAnimationFrame(raf2);
          };
        }, [fn]);
      }
      function isHTMLElement$2(node) {
        return node.nodeType === node.ELEMENT_NODE;
      }
      function getTabbableCandidates(container) {
        const nodes = [];
        const walker = document.createTreeWalker(
          container,
          NodeFilter.SHOW_ELEMENT,
          {
            acceptNode: (node) => {
              const isHiddenInput =
                node.tagName === "INPUT" && node.type === "hidden";
              if (node.disabled || node.hidden || isHiddenInput)
                return NodeFilter.FILTER_SKIP;
              return node.tabIndex >= 0
                ? NodeFilter.FILTER_ACCEPT
                : NodeFilter.FILTER_SKIP;
            },
          },
        );
        while (walker.nextNode()) nodes.push(walker.currentNode);
        return nodes;
      }
      function focusFirst(candidates) {
        const previouslyFocusedElement = document.activeElement;
        return candidates.some((candidate) => {
          if (candidate === previouslyFocusedElement) return true;
          candidate.focus();
          return document.activeElement !== previouslyFocusedElement;
        });
      }
      var Provider$1 = ToastProvider$1;
      var Viewport = ToastViewport$1;
      var Root2 = Toast$1;
      var Title = ToastTitle$1;
      var Description = ToastDescription$1;
      var Action$1 = ToastAction$1;
      var Close = ToastClose$1;

      function r(e) {
        var t,
          f,
          n = "";
        if ("string" == typeof e || "number" == typeof e) n += e;
        else if ("object" == typeof e)
          if (Array.isArray(e)) {
            var o = e.length;
            for (t = 0; t < o; t++)
              e[t] && (f = r(e[t])) && (n && (n += " "), (n += f));
          } else for (f in e) e[f] && (n && (n += " "), (n += f));
        return n;
      }
      function clsx() {
        for (var e, t, f = 0, n = "", o = arguments.length; f < o; f++)
          (e = arguments[f]) && (t = r(e)) && (n && (n += " "), (n += t));
        return n;
      }

      const falsyToString = (value) =>
        typeof value === "boolean" ? `${value}` : value === 0 ? "0" : value;
      const cx = clsx;
      const cva = (base, config) => (props) => {
        var _config_compoundVariants;
        if (
          (config === null || config === void 0 ? void 0 : config.variants) ==
          null
        )
          return cx(
            base,
            props === null || props === void 0 ? void 0 : props.class,
            props === null || props === void 0 ? void 0 : props.className,
          );
        const { variants, defaultVariants } = config;
        const getVariantClassNames = Object.keys(variants).map((variant) => {
          const variantProp =
            props === null || props === void 0 ? void 0 : props[variant];
          const defaultVariantProp =
            defaultVariants === null || defaultVariants === void 0
              ? void 0
              : defaultVariants[variant];
          if (variantProp === null) return null;
          const variantKey =
            falsyToString(variantProp) || falsyToString(defaultVariantProp);
          return variants[variant][variantKey];
        });
        const propsWithoutUndefined =
          props &&
          Object.entries(props).reduce((acc, param) => {
            let [key, value] = param;
            if (value === undefined) {
              return acc;
            }
            acc[key] = value;
            return acc;
          }, {});
        const getCompoundVariantClassNames =
          config === null || config === void 0
            ? void 0
            : (_config_compoundVariants = config.compoundVariants) === null ||
                _config_compoundVariants === void 0
              ? void 0
              : _config_compoundVariants.reduce((acc, param) => {
                  let {
                    class: cvClass,
                    className: cvClassName,
                    ...compoundVariantOptions
                  } = param;
                  return Object.entries(compoundVariantOptions).every(
                    (param) => {
                      let [key, value] = param;
                      return Array.isArray(value)
                        ? value.includes(
                            {
                              ...defaultVariants,
                              ...propsWithoutUndefined,
                            }[key],
                          )
                        : {
                            ...defaultVariants,
                            ...propsWithoutUndefined,
                          }[key] === value;
                    },
                  )
                    ? [...acc, cvClass, cvClassName]
                    : acc;
                }, []);
        return cx(
          base,
          getVariantClassNames,
          getCompoundVariantClassNames,
          props === null || props === void 0 ? void 0 : props.class,
          props === null || props === void 0 ? void 0 : props.className,
        );
      };

      const toKebabCase = (string) =>
        string.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase();
      const mergeClasses = (...classes) =>
        classes
          .filter((className, index, array) => {
            return (
              Boolean(className) &&
              className.trim() !== "" &&
              array.indexOf(className) === index
            );
          })
          .join(" ")
          .trim();

      var defaultAttributes = {
        xmlns: "http://www.w3.org/2000/svg",
        width: 24,
        height: 24,
        viewBox: "0 0 24 24",
        fill: "none",
        stroke: "currentColor",
        strokeWidth: 2,
        strokeLinecap: "round",
        strokeLinejoin: "round",
      };

      const Icon = reactExports.forwardRef(
        (
          {
            color = "currentColor",
            size = 24,
            strokeWidth = 2,
            absoluteStrokeWidth,
            className = "",
            children,
            iconNode,
            ...rest
          },
          ref,
        ) => {
          return reactExports.createElement(
            "svg",
            {
              ref,
              ...defaultAttributes,
              width: size,
              height: size,
              stroke: color,
              strokeWidth: absoluteStrokeWidth
                ? (Number(strokeWidth) * 24) / Number(size)
                : strokeWidth,
              className: mergeClasses("lucide", className),
              ...rest,
            },
            [
              ...iconNode.map(([tag, attrs]) =>
                reactExports.createElement(tag, attrs),
              ),
              ...(Array.isArray(children) ? children : [children]),
            ],
          );
        },
      );

      const createLucideIcon = (iconName, iconNode) => {
        const Component = reactExports.forwardRef(
          ({ className, ...props }, ref) =>
            reactExports.createElement(Icon, {
              ref,
              iconNode,
              className: mergeClasses(
                `lucide-${toKebabCase(iconName)}`,
                className,
              ),
              ...props,
            }),
        );
        Component.displayName = `${iconName}`;
        return Component;
      };

      const Beaker = createLucideIcon("Beaker", [
        ["path", { d: "M4.5 3h15", key: "c7n0jr" }],
        [
          "path",
          { d: "M6 3v16a2 2 0 0 0 2 2h8a2 2 0 0 0 2-2V3", key: "m1uhx7" },
        ],
        ["path", { d: "M6 14h12", key: "4cwo0f" }],
      ]);

      const Check = createLucideIcon("Check", [
        ["path", { d: "M20 6 9 17l-5-5", key: "1gmf2c" }],
      ]);

      const ChevronLeft = createLucideIcon("ChevronLeft", [
        ["path", { d: "m15 18-6-6 6-6", key: "1wnfg3" }],
      ]);

      const ChevronRight = createLucideIcon("ChevronRight", [
        ["path", { d: "m9 18 6-6-6-6", key: "mthhwq" }],
      ]);

      const FlaskRound = createLucideIcon("FlaskRound", [
        ["path", { d: "M10 2v7.31", key: "5d1hyh" }],
        ["path", { d: "M14 9.3V1.99", key: "14k4l0" }],
        ["path", { d: "M8.5 2h7", key: "csnxdl" }],
        ["path", { d: "M14 9.3a6.5 6.5 0 1 1-4 0", key: "1r8fvy" }],
        ["path", { d: "M5.52 16h12.96", key: "46hh1i" }],
      ]);

      const Radiation = createLucideIcon("Radiation", [
        ["path", { d: "M12 12h.01", key: "1mp3jc" }],
        [
          "path",
          {
            d: "M7.5 4.2c-.3-.5-.9-.7-1.3-.4C3.9 5.5 2.3 8.1 2 11c-.1.5.4 1 1 1h5c0-1.5.8-2.8 2-3.4-1.1-1.9-2-3.5-2.5-4.4z",
            key: "wy49g3",
          },
        ],
        [
          "path",
          {
            d: "M21 12c.6 0 1-.4 1-1-.3-2.9-1.8-5.5-4.1-7.1-.4-.3-1.1-.2-1.3.3-.6.9-1.5 2.5-2.6 4.3 1.2.7 2 2 2 3.5h5z",
            key: "vklnvr",
          },
        ],
        [
          "path",
          {
            d: "M7.5 19.8c-.3.5-.1 1.1.4 1.3 2.6 1.2 5.6 1.2 8.2 0 .5-.2.7-.8.4-1.3-.5-.9-1.4-2.5-2.5-4.3-1.2.7-2.8.7-4 0-1.1 1.8-2 3.4-2.5 4.3z",
            key: "wkdf1o",
          },
        ],
      ]);

      const RotateCcw = createLucideIcon("RotateCcw", [
        [
          "path",
          {
            d: "M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8",
            key: "1357e3",
          },
        ],
        ["path", { d: "M3 3v5h5", key: "1xhq8a" }],
      ]);

      const Skull = createLucideIcon("Skull", [
        ["path", { d: "m12.5 17-.5-1-.5 1h1z", key: "3me087" }],
        [
          "path",
          {
            d: "M15 22a1 1 0 0 0 1-1v-1a2 2 0 0 0 1.56-3.25 8 8 0 1 0-11.12 0A2 2 0 0 0 8 20v1a1 1 0 0 0 1 1z",
            key: "1o5pge",
          },
        ],
        ["circle", { cx: "15", cy: "12", r: "1", key: "1tmaij" }],
        ["circle", { cx: "9", cy: "12", r: "1", key: "1vctgf" }],
      ]);

      const X = createLucideIcon("X", [
        ["path", { d: "M18 6 6 18", key: "1bl5f8" }],
        ["path", { d: "m6 6 12 12", key: "d8bk6v" }],
      ]);

      const CLASS_PART_SEPARATOR = "-";
      const createClassGroupUtils = (config) => {
        const classMap = createClassMap(config);
        const { conflictingClassGroups, conflictingClassGroupModifiers } =
          config;
        const getClassGroupId = (className) => {
          const classParts = className.split(CLASS_PART_SEPARATOR);
          // Classes like `-inset-1` produce an empty string as first classPart. We assume that classes for negative values are used correctly and remove it from classParts.
          if (classParts[0] === "" && classParts.length !== 1) {
            classParts.shift();
          }
          return (
            getGroupRecursive(classParts, classMap) ||
            getGroupIdForArbitraryProperty(className)
          );
        };
        const getConflictingClassGroupIds = (
          classGroupId,
          hasPostfixModifier,
        ) => {
          const conflicts = conflictingClassGroups[classGroupId] || [];
          if (
            hasPostfixModifier &&
            conflictingClassGroupModifiers[classGroupId]
          ) {
            return [
              ...conflicts,
              ...conflictingClassGroupModifiers[classGroupId],
            ];
          }
          return conflicts;
        };
        return {
          getClassGroupId,
          getConflictingClassGroupIds,
        };
      };
      const getGroupRecursive = (classParts, classPartObject) => {
        if (classParts.length === 0) {
          return classPartObject.classGroupId;
        }
        const currentClassPart = classParts[0];
        const nextClassPartObject =
          classPartObject.nextPart.get(currentClassPart);
        const classGroupFromNextClassPart = nextClassPartObject
          ? getGroupRecursive(classParts.slice(1), nextClassPartObject)
          : undefined;
        if (classGroupFromNextClassPart) {
          return classGroupFromNextClassPart;
        }
        if (classPartObject.validators.length === 0) {
          return undefined;
        }
        const classRest = classParts.join(CLASS_PART_SEPARATOR);
        return classPartObject.validators.find(({ validator }) =>
          validator(classRest),
        )?.classGroupId;
      };
      const arbitraryPropertyRegex = /^\[(.+)\]$/;
      const getGroupIdForArbitraryProperty = (className) => {
        if (arbitraryPropertyRegex.test(className)) {
          const arbitraryPropertyClassName =
            arbitraryPropertyRegex.exec(className)[1];
          const property = arbitraryPropertyClassName?.substring(
            0,
            arbitraryPropertyClassName.indexOf(":"),
          );
          if (property) {
            // I use two dots here because one dot is used as prefix for class groups in plugins
            return "arbitrary.." + property;
          }
        }
      };

      const createClassMap = (config) => {
        const { theme, prefix } = config;
        const classMap = {
          nextPart: new Map(),
          validators: [],
        };
        const prefixedClassGroupEntries = getPrefixedClassGroupEntries(
          Object.entries(config.classGroups),
          prefix,
        );
        prefixedClassGroupEntries.forEach(([classGroupId, classGroup]) => {
          processClassesRecursively(classGroup, classMap, classGroupId, theme);
        });
        return classMap;
      };
      const processClassesRecursively = (
        classGroup,
        classPartObject,
        classGroupId,
        theme,
      ) => {
        classGroup.forEach((classDefinition) => {
          if (typeof classDefinition === "string") {
            const classPartObjectToEdit =
              classDefinition === ""
                ? classPartObject
                : getPart(classPartObject, classDefinition);
            classPartObjectToEdit.classGroupId = classGroupId;
            return;
          }
          if (typeof classDefinition === "function") {
            if (isThemeGetter(classDefinition)) {
              processClassesRecursively(
                classDefinition(theme),
                classPartObject,
                classGroupId,
                theme,
              );
              return;
            }
            classPartObject.validators.push({
              validator: classDefinition,
              classGroupId,
            });
            return;
          }
          Object.entries(classDefinition).forEach(([key, classGroup]) => {
            processClassesRecursively(
              classGroup,
              getPart(classPartObject, key),
              classGroupId,
              theme,
            );
          });
        });
      };
      const getPart = (classPartObject, path) => {
        let currentClassPartObject = classPartObject;
        path.split(CLASS_PART_SEPARATOR).forEach((pathPart) => {
          if (!currentClassPartObject.nextPart.has(pathPart)) {
            currentClassPartObject.nextPart.set(pathPart, {
              nextPart: new Map(),
              validators: [],
            });
          }
          currentClassPartObject =
            currentClassPartObject.nextPart.get(pathPart);
        });
        return currentClassPartObject;
      };
      const isThemeGetter = (func) => func.isThemeGetter;
      const getPrefixedClassGroupEntries = (classGroupEntries, prefix) => {
        if (!prefix) {
          return classGroupEntries;
        }
        return classGroupEntries.map(([classGroupId, classGroup]) => {
          const prefixedClassGroup = classGroup.map((classDefinition) => {
            if (typeof classDefinition === "string") {
              return prefix + classDefinition;
            }
            if (typeof classDefinition === "object") {
              return Object.fromEntries(
                Object.entries(classDefinition).map(([key, value]) => [
                  prefix + key,
                  value,
                ]),
              );
            }
            return classDefinition;
          });
          return [classGroupId, prefixedClassGroup];
        });
      };

      // LRU cache inspired from hashlru (https://github.com/dominictarr/hashlru/blob/v1.0.4/index.js) but object replaced with Map to improve performance
      const createLruCache = (maxCacheSize) => {
        if (maxCacheSize < 1) {
          return {
            get: () => undefined,
            set: () => {},
          };
        }
        let cacheSize = 0;
        let cache = new Map();
        let previousCache = new Map();
        const update = (key, value) => {
          cache.set(key, value);
          cacheSize++;
          if (cacheSize > maxCacheSize) {
            cacheSize = 0;
            previousCache = cache;
            cache = new Map();
          }
        };
        return {
          get(key) {
            let value = cache.get(key);
            if (value !== undefined) {
              return value;
            }
            if ((value = previousCache.get(key)) !== undefined) {
              update(key, value);
              return value;
            }
          },
          set(key, value) {
            if (cache.has(key)) {
              cache.set(key, value);
            } else {
              update(key, value);
            }
          },
        };
      };
      const IMPORTANT_MODIFIER = "!";
      const createParseClassName = (config) => {
        const { separator, experimentalParseClassName } = config;
        const isSeparatorSingleCharacter = separator.length === 1;
        const firstSeparatorCharacter = separator[0];
        const separatorLength = separator.length;
        // parseClassName inspired by https://github.com/tailwindlabs/tailwindcss/blob/v3.2.2/src/util/splitAtTopLevelOnly.js
        const parseClassName = (className) => {
          const modifiers = [];
          let bracketDepth = 0;
          let modifierStart = 0;
          let postfixModifierPosition;
          for (let index = 0; index < className.length; index++) {
            let currentCharacter = className[index];
            if (bracketDepth === 0) {
              if (
                currentCharacter === firstSeparatorCharacter &&
                (isSeparatorSingleCharacter ||
                  className.slice(index, index + separatorLength) === separator)
              ) {
                modifiers.push(className.slice(modifierStart, index));
                modifierStart = index + separatorLength;
                continue;
              }
              if (currentCharacter === "/") {
                postfixModifierPosition = index;
                continue;
              }
            }
            if (currentCharacter === "[") {
              bracketDepth++;
            } else if (currentCharacter === "]") {
              bracketDepth--;
            }
          }
          const baseClassNameWithImportantModifier =
            modifiers.length === 0
              ? className
              : className.substring(modifierStart);
          const hasImportantModifier =
            baseClassNameWithImportantModifier.startsWith(IMPORTANT_MODIFIER);
          const baseClassName = hasImportantModifier
            ? baseClassNameWithImportantModifier.substring(1)
            : baseClassNameWithImportantModifier;
          const maybePostfixModifierPosition =
            postfixModifierPosition && postfixModifierPosition > modifierStart
              ? postfixModifierPosition - modifierStart
              : undefined;
          return {
            modifiers,
            hasImportantModifier,
            baseClassName,
            maybePostfixModifierPosition,
          };
        };
        if (experimentalParseClassName) {
          return (className) =>
            experimentalParseClassName({
              className,
              parseClassName,
            });
        }
        return parseClassName;
      };

      const sortModifiers = (modifiers) => {
        if (modifiers.length <= 1) {
          return modifiers;
        }
        const sortedModifiers = [];
        let unsortedModifiers = [];
        modifiers.forEach((modifier) => {
          const isArbitraryVariant = modifier[0] === "[";
          if (isArbitraryVariant) {
            sortedModifiers.push(...unsortedModifiers.sort(), modifier);
            unsortedModifiers = [];
          } else {
            unsortedModifiers.push(modifier);
          }
        });
        sortedModifiers.push(...unsortedModifiers.sort());
        return sortedModifiers;
      };
      const createConfigUtils = (config) => ({
        cache: createLruCache(config.cacheSize),
        parseClassName: createParseClassName(config),
        ...createClassGroupUtils(config),
      });
      const SPLIT_CLASSES_REGEX = /\s+/;
      const mergeClassList = (classList, configUtils) => {
        const { parseClassName, getClassGroupId, getConflictingClassGroupIds } =
          configUtils;

        const classGroupsInConflict = [];
        const classNames = classList.trim().split(SPLIT_CLASSES_REGEX);
        let result = "";
        for (let index = classNames.length - 1; index >= 0; index -= 1) {
          const originalClassName = classNames[index];
          const {
            modifiers,
            hasImportantModifier,
            baseClassName,
            maybePostfixModifierPosition,
          } = parseClassName(originalClassName);
          let hasPostfixModifier = Boolean(maybePostfixModifierPosition);
          let classGroupId = getClassGroupId(
            hasPostfixModifier
              ? baseClassName.substring(0, maybePostfixModifierPosition)
              : baseClassName,
          );
          if (!classGroupId) {
            if (!hasPostfixModifier) {
              // Not a Tailwind class
              result =
                originalClassName + (result.length > 0 ? " " + result : result);
              continue;
            }
            classGroupId = getClassGroupId(baseClassName);
            if (!classGroupId) {
              // Not a Tailwind class
              result =
                originalClassName + (result.length > 0 ? " " + result : result);
              continue;
            }
            hasPostfixModifier = false;
          }
          const variantModifier = sortModifiers(modifiers).join(":");
          const modifierId = hasImportantModifier
            ? variantModifier + IMPORTANT_MODIFIER
            : variantModifier;
          const classId = modifierId + classGroupId;
          if (classGroupsInConflict.includes(classId)) {
            // Tailwind class omitted due to conflict
            continue;
          }
          classGroupsInConflict.push(classId);
          const conflictGroups = getConflictingClassGroupIds(
            classGroupId,
            hasPostfixModifier,
          );
          for (let i = 0; i < conflictGroups.length; ++i) {
            const group = conflictGroups[i];
            classGroupsInConflict.push(modifierId + group);
          }
          // Tailwind class not in conflict
          result =
            originalClassName + (result.length > 0 ? " " + result : result);
        }
        return result;
      };

      function twJoin() {
        let index = 0;
        let argument;
        let resolvedValue;
        let string = "";
        while (index < arguments.length) {
          if ((argument = arguments[index++])) {
            if ((resolvedValue = toValue(argument))) {
              string && (string += " ");
              string += resolvedValue;
            }
          }
        }
        return string;
      }
      const toValue = (mix) => {
        if (typeof mix === "string") {
          return mix;
        }
        let resolvedValue;
        let string = "";
        for (let k = 0; k < mix.length; k++) {
          if (mix[k]) {
            if ((resolvedValue = toValue(mix[k]))) {
              string && (string += " ");
              string += resolvedValue;
            }
          }
        }
        return string;
      };
      function createTailwindMerge(createConfigFirst, ...createConfigRest) {
        let configUtils;
        let cacheGet;
        let cacheSet;
        let functionToCall = initTailwindMerge;
        function initTailwindMerge(classList) {
          const config = createConfigRest.reduce(
            (previousConfig, createConfigCurrent) =>
              createConfigCurrent(previousConfig),
            createConfigFirst(),
          );
          configUtils = createConfigUtils(config);
          cacheGet = configUtils.cache.get;
          cacheSet = configUtils.cache.set;
          functionToCall = tailwindMerge;
          return tailwindMerge(classList);
        }
        function tailwindMerge(classList) {
          const cachedResult = cacheGet(classList);
          if (cachedResult) {
            return cachedResult;
          }
          const result = mergeClassList(classList, configUtils);
          cacheSet(classList, result);
          return result;
        }
        return function callTailwindMerge() {
          return functionToCall(twJoin.apply(null, arguments));
        };
      }
      const fromTheme = (key) => {
        const themeGetter = (theme) => theme[key] || [];
        themeGetter.isThemeGetter = true;
        return themeGetter;
      };
      const arbitraryValueRegex = /^\[(?:([a-z-]+):)?(.+)\]$/i;
      const fractionRegex = /^\d+\/\d+$/;
      const stringLengths = /*#__PURE__*/ new Set(["px", "full", "screen"]);
      const tshirtUnitRegex = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/;
      const lengthUnitRegex =
        /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/;
      const colorFunctionRegex = /^(rgba?|hsla?|hwb|(ok)?(lab|lch))\(.+\)$/;
      // Shadow always begins with x and y offset separated by underscore optionally prepended by inset
      const shadowRegex =
        /^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/;
      const imageRegex =
        /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/;
      const isLength = (value) =>
        isNumber(value) ||
        stringLengths.has(value) ||
        fractionRegex.test(value);
      const isArbitraryLength = (value) =>
        getIsArbitraryValue(value, "length", isLengthOnly);
      const isNumber = (value) =>
        Boolean(value) && !Number.isNaN(Number(value));
      const isArbitraryNumber = (value) =>
        getIsArbitraryValue(value, "number", isNumber);
      const isInteger = (value) =>
        Boolean(value) && Number.isInteger(Number(value));
      const isPercent = (value) =>
        value.endsWith("%") && isNumber(value.slice(0, -1));
      const isArbitraryValue = (value) => arbitraryValueRegex.test(value);
      const isTshirtSize = (value) => tshirtUnitRegex.test(value);
      const sizeLabels = /*#__PURE__*/ new Set([
        "length",
        "size",
        "percentage",
      ]);
      const isArbitrarySize = (value) =>
        getIsArbitraryValue(value, sizeLabels, isNever);
      const isArbitraryPosition = (value) =>
        getIsArbitraryValue(value, "position", isNever);
      const imageLabels = /*#__PURE__*/ new Set(["image", "url"]);
      const isArbitraryImage = (value) =>
        getIsArbitraryValue(value, imageLabels, isImage);
      const isArbitraryShadow = (value) =>
        getIsArbitraryValue(value, "", isShadow);
      const isAny = () => true;
      const getIsArbitraryValue = (value, label, testValue) => {
        const result = arbitraryValueRegex.exec(value);
        if (result) {
          if (result[1]) {
            return typeof label === "string"
              ? result[1] === label
              : label.has(result[1]);
          }
          return testValue(result[2]);
        }
        return false;
      };
      const isLengthOnly = (value) =>
        // `colorFunctionRegex` check is necessary because color functions can have percentages in them which which would be incorrectly classified as lengths.
        // For example, `hsl(0 0% 0%)` would be classified as a length without this check.
        // I could also use lookbehind assertion in `lengthUnitRegex` but that isn't supported widely enough.
        lengthUnitRegex.test(value) && !colorFunctionRegex.test(value);
      const isNever = () => false;
      const isShadow = (value) => shadowRegex.test(value);
      const isImage = (value) => imageRegex.test(value);
      const getDefaultConfig = () => {
        const colors = fromTheme("colors");
        const spacing = fromTheme("spacing");
        const blur = fromTheme("blur");
        const brightness = fromTheme("brightness");
        const borderColor = fromTheme("borderColor");
        const borderRadius = fromTheme("borderRadius");
        const borderSpacing = fromTheme("borderSpacing");
        const borderWidth = fromTheme("borderWidth");
        const contrast = fromTheme("contrast");
        const grayscale = fromTheme("grayscale");
        const hueRotate = fromTheme("hueRotate");
        const invert = fromTheme("invert");
        const gap = fromTheme("gap");
        const gradientColorStops = fromTheme("gradientColorStops");
        const gradientColorStopPositions = fromTheme(
          "gradientColorStopPositions",
        );
        const inset = fromTheme("inset");
        const margin = fromTheme("margin");
        const opacity = fromTheme("opacity");
        const padding = fromTheme("padding");
        const saturate = fromTheme("saturate");
        const scale = fromTheme("scale");
        const sepia = fromTheme("sepia");
        const skew = fromTheme("skew");
        const space = fromTheme("space");
        const translate = fromTheme("translate");
        const getOverscroll = () => ["auto", "contain", "none"];
        const getOverflow = () => [
          "auto",
          "hidden",
          "clip",
          "visible",
          "scroll",
        ];
        const getSpacingWithAutoAndArbitrary = () => [
          "auto",
          isArbitraryValue,
          spacing,
        ];
        const getSpacingWithArbitrary = () => [isArbitraryValue, spacing];
        const getLengthWithEmptyAndArbitrary = () => [
          "",
          isLength,
          isArbitraryLength,
        ];
        const getNumberWithAutoAndArbitrary = () => [
          "auto",
          isNumber,
          isArbitraryValue,
        ];
        const getPositions = () => [
          "bottom",
          "center",
          "left",
          "left-bottom",
          "left-top",
          "right",
          "right-bottom",
          "right-top",
          "top",
        ];
        const getLineStyles = () => [
          "solid",
          "dashed",
          "dotted",
          "double",
          "none",
        ];
        const getBlendModes = () => [
          "normal",
          "multiply",
          "screen",
          "overlay",
          "darken",
          "lighten",
          "color-dodge",
          "color-burn",
          "hard-light",
          "soft-light",
          "difference",
          "exclusion",
          "hue",
          "saturation",
          "color",
          "luminosity",
        ];
        const getAlign = () => [
          "start",
          "end",
          "center",
          "between",
          "around",
          "evenly",
          "stretch",
        ];
        const getZeroAndEmpty = () => ["", "0", isArbitraryValue];
        const getBreaks = () => [
          "auto",
          "avoid",
          "all",
          "avoid-page",
          "page",
          "left",
          "right",
          "column",
        ];
        const getNumberAndArbitrary = () => [isNumber, isArbitraryValue];
        return {
          cacheSize: 500,
          separator: ":",
          theme: {
            colors: [isAny],
            spacing: [isLength, isArbitraryLength],
            blur: ["none", "", isTshirtSize, isArbitraryValue],
            brightness: getNumberAndArbitrary(),
            borderColor: [colors],
            borderRadius: ["none", "", "full", isTshirtSize, isArbitraryValue],
            borderSpacing: getSpacingWithArbitrary(),
            borderWidth: getLengthWithEmptyAndArbitrary(),
            contrast: getNumberAndArbitrary(),
            grayscale: getZeroAndEmpty(),
            hueRotate: getNumberAndArbitrary(),
            invert: getZeroAndEmpty(),
            gap: getSpacingWithArbitrary(),
            gradientColorStops: [colors],
            gradientColorStopPositions: [isPercent, isArbitraryLength],
            inset: getSpacingWithAutoAndArbitrary(),
            margin: getSpacingWithAutoAndArbitrary(),
            opacity: getNumberAndArbitrary(),
            padding: getSpacingWithArbitrary(),
            saturate: getNumberAndArbitrary(),
            scale: getNumberAndArbitrary(),
            sepia: getZeroAndEmpty(),
            skew: getNumberAndArbitrary(),
            space: getSpacingWithArbitrary(),
            translate: getSpacingWithArbitrary(),
          },
          classGroups: {
            // Layout

            aspect: [
              {
                aspect: ["auto", "square", "video", isArbitraryValue],
              },
            ],

            container: ["container"],

            columns: [
              {
                columns: [isTshirtSize],
              },
            ],

            "break-after": [
              {
                "break-after": getBreaks(),
              },
            ],

            "break-before": [
              {
                "break-before": getBreaks(),
              },
            ],

            "break-inside": [
              {
                "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"],
              },
            ],

            "box-decoration": [
              {
                "box-decoration": ["slice", "clone"],
              },
            ],

            box: [
              {
                box: ["border", "content"],
              },
            ],

            display: [
              "block",
              "inline-block",
              "inline",
              "flex",
              "inline-flex",
              "table",
              "inline-table",
              "table-caption",
              "table-cell",
              "table-column",
              "table-column-group",
              "table-footer-group",
              "table-header-group",
              "table-row-group",
              "table-row",
              "flow-root",
              "grid",
              "inline-grid",
              "contents",
              "list-item",
              "hidden",
            ],

            float: [
              {
                float: ["right", "left", "none", "start", "end"],
              },
            ],

            clear: [
              {
                clear: ["left", "right", "both", "none", "start", "end"],
              },
            ],

            isolation: ["isolate", "isolation-auto"],

            "object-fit": [
              {
                object: ["contain", "cover", "fill", "none", "scale-down"],
              },
            ],

            "object-position": [
              {
                object: [...getPositions(), isArbitraryValue],
              },
            ],

            overflow: [
              {
                overflow: getOverflow(),
              },
            ],

            "overflow-x": [
              {
                "overflow-x": getOverflow(),
              },
            ],

            "overflow-y": [
              {
                "overflow-y": getOverflow(),
              },
            ],

            overscroll: [
              {
                overscroll: getOverscroll(),
              },
            ],

            "overscroll-x": [
              {
                "overscroll-x": getOverscroll(),
              },
            ],

            "overscroll-y": [
              {
                "overscroll-y": getOverscroll(),
              },
            ],

            position: ["static", "fixed", "absolute", "relative", "sticky"],

            inset: [
              {
                inset: [inset],
              },
            ],

            "inset-x": [
              {
                "inset-x": [inset],
              },
            ],

            "inset-y": [
              {
                "inset-y": [inset],
              },
            ],

            start: [
              {
                start: [inset],
              },
            ],

            end: [
              {
                end: [inset],
              },
            ],

            top: [
              {
                top: [inset],
              },
            ],

            right: [
              {
                right: [inset],
              },
            ],

            bottom: [
              {
                bottom: [inset],
              },
            ],

            left: [
              {
                left: [inset],
              },
            ],

            visibility: ["visible", "invisible", "collapse"],

            z: [
              {
                z: ["auto", isInteger, isArbitraryValue],
              },
            ],
            // Flexbox and Grid

            basis: [
              {
                basis: getSpacingWithAutoAndArbitrary(),
              },
            ],

            "flex-direction": [
              {
                flex: ["row", "row-reverse", "col", "col-reverse"],
              },
            ],

            "flex-wrap": [
              {
                flex: ["wrap", "wrap-reverse", "nowrap"],
              },
            ],

            flex: [
              {
                flex: ["1", "auto", "initial", "none", isArbitraryValue],
              },
            ],

            grow: [
              {
                grow: getZeroAndEmpty(),
              },
            ],

            shrink: [
              {
                shrink: getZeroAndEmpty(),
              },
            ],

            order: [
              {
                order: ["first", "last", "none", isInteger, isArbitraryValue],
              },
            ],

            "grid-cols": [
              {
                "grid-cols": [isAny],
              },
            ],

            "col-start-end": [
              {
                col: [
                  "auto",
                  {
                    span: ["full", isInteger, isArbitraryValue],
                  },
                  isArbitraryValue,
                ],
              },
            ],

            "col-start": [
              {
                "col-start": getNumberWithAutoAndArbitrary(),
              },
            ],

            "col-end": [
              {
                "col-end": getNumberWithAutoAndArbitrary(),
              },
            ],

            "grid-rows": [
              {
                "grid-rows": [isAny],
              },
            ],

            "row-start-end": [
              {
                row: [
                  "auto",
                  {
                    span: [isInteger, isArbitraryValue],
                  },
                  isArbitraryValue,
                ],
              },
            ],

            "row-start": [
              {
                "row-start": getNumberWithAutoAndArbitrary(),
              },
            ],

            "row-end": [
              {
                "row-end": getNumberWithAutoAndArbitrary(),
              },
            ],

            "grid-flow": [
              {
                "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"],
              },
            ],

            "auto-cols": [
              {
                "auto-cols": ["auto", "min", "max", "fr", isArbitraryValue],
              },
            ],

            "auto-rows": [
              {
                "auto-rows": ["auto", "min", "max", "fr", isArbitraryValue],
              },
            ],

            gap: [
              {
                gap: [gap],
              },
            ],

            "gap-x": [
              {
                "gap-x": [gap],
              },
            ],

            "gap-y": [
              {
                "gap-y": [gap],
              },
            ],

            "justify-content": [
              {
                justify: ["normal", ...getAlign()],
              },
            ],

            "justify-items": [
              {
                "justify-items": ["start", "end", "center", "stretch"],
              },
            ],

            "justify-self": [
              {
                "justify-self": ["auto", "start", "end", "center", "stretch"],
              },
            ],

            "align-content": [
              {
                content: ["normal", ...getAlign(), "baseline"],
              },
            ],

            "align-items": [
              {
                items: ["start", "end", "center", "baseline", "stretch"],
              },
            ],

            "align-self": [
              {
                self: ["auto", "start", "end", "center", "stretch", "baseline"],
              },
            ],

            "place-content": [
              {
                "place-content": [...getAlign(), "baseline"],
              },
            ],

            "place-items": [
              {
                "place-items": [
                  "start",
                  "end",
                  "center",
                  "baseline",
                  "stretch",
                ],
              },
            ],

            "place-self": [
              {
                "place-self": ["auto", "start", "end", "center", "stretch"],
              },
            ],
            // Spacing

            p: [
              {
                p: [padding],
              },
            ],

            px: [
              {
                px: [padding],
              },
            ],

            py: [
              {
                py: [padding],
              },
            ],

            ps: [
              {
                ps: [padding],
              },
            ],

            pe: [
              {
                pe: [padding],
              },
            ],

            pt: [
              {
                pt: [padding],
              },
            ],

            pr: [
              {
                pr: [padding],
              },
            ],

            pb: [
              {
                pb: [padding],
              },
            ],

            pl: [
              {
                pl: [padding],
              },
            ],

            m: [
              {
                m: [margin],
              },
            ],

            mx: [
              {
                mx: [margin],
              },
            ],

            my: [
              {
                my: [margin],
              },
            ],

            ms: [
              {
                ms: [margin],
              },
            ],

            me: [
              {
                me: [margin],
              },
            ],

            mt: [
              {
                mt: [margin],
              },
            ],

            mr: [
              {
                mr: [margin],
              },
            ],

            mb: [
              {
                mb: [margin],
              },
            ],

            ml: [
              {
                ml: [margin],
              },
            ],

            "space-x": [
              {
                "space-x": [space],
              },
            ],

            "space-x-reverse": ["space-x-reverse"],

            "space-y": [
              {
                "space-y": [space],
              },
            ],

            "space-y-reverse": ["space-y-reverse"],
            // Sizing

            w: [
              {
                w: [
                  "auto",
                  "min",
                  "max",
                  "fit",
                  "svw",
                  "lvw",
                  "dvw",
                  isArbitraryValue,
                  spacing,
                ],
              },
            ],

            "min-w": [
              {
                "min-w": [isArbitraryValue, spacing, "min", "max", "fit"],
              },
            ],

            "max-w": [
              {
                "max-w": [
                  isArbitraryValue,
                  spacing,
                  "none",
                  "full",
                  "min",
                  "max",
                  "fit",
                  "prose",
                  {
                    screen: [isTshirtSize],
                  },
                  isTshirtSize,
                ],
              },
            ],

            h: [
              {
                h: [
                  isArbitraryValue,
                  spacing,
                  "auto",
                  "min",
                  "max",
                  "fit",
                  "svh",
                  "lvh",
                  "dvh",
                ],
              },
            ],

            "min-h": [
              {
                "min-h": [
                  isArbitraryValue,
                  spacing,
                  "min",
                  "max",
                  "fit",
                  "svh",
                  "lvh",
                  "dvh",
                ],
              },
            ],

            "max-h": [
              {
                "max-h": [
                  isArbitraryValue,
                  spacing,
                  "min",
                  "max",
                  "fit",
                  "svh",
                  "lvh",
                  "dvh",
                ],
              },
            ],

            size: [
              {
                size: [isArbitraryValue, spacing, "auto", "min", "max", "fit"],
              },
            ],
            // Typography

            "font-size": [
              {
                text: ["base", isTshirtSize, isArbitraryLength],
              },
            ],

            "font-smoothing": ["antialiased", "subpixel-antialiased"],

            "font-style": ["italic", "not-italic"],

            "font-weight": [
              {
                font: [
                  "thin",
                  "extralight",
                  "light",
                  "normal",
                  "medium",
                  "semibold",
                  "bold",
                  "extrabold",
                  "black",
                  isArbitraryNumber,
                ],
              },
            ],

            "font-family": [
              {
                font: [isAny],
              },
            ],

            "fvn-normal": ["normal-nums"],

            "fvn-ordinal": ["ordinal"],

            "fvn-slashed-zero": ["slashed-zero"],

            "fvn-figure": ["lining-nums", "oldstyle-nums"],

            "fvn-spacing": ["proportional-nums", "tabular-nums"],

            "fvn-fraction": ["diagonal-fractions", "stacked-fractions"],

            tracking: [
              {
                tracking: [
                  "tighter",
                  "tight",
                  "normal",
                  "wide",
                  "wider",
                  "widest",
                  isArbitraryValue,
                ],
              },
            ],

            "line-clamp": [
              {
                "line-clamp": ["none", isNumber, isArbitraryNumber],
              },
            ],

            leading: [
              {
                leading: [
                  "none",
                  "tight",
                  "snug",
                  "normal",
                  "relaxed",
                  "loose",
                  isLength,
                  isArbitraryValue,
                ],
              },
            ],

            "list-image": [
              {
                "list-image": ["none", isArbitraryValue],
              },
            ],

            "list-style-type": [
              {
                list: ["none", "disc", "decimal", isArbitraryValue],
              },
            ],

            "list-style-position": [
              {
                list: ["inside", "outside"],
              },
            ],

            "placeholder-color": [
              {
                placeholder: [colors],
              },
            ],

            "placeholder-opacity": [
              {
                "placeholder-opacity": [opacity],
              },
            ],

            "text-alignment": [
              {
                text: ["left", "center", "right", "justify", "start", "end"],
              },
            ],

            "text-color": [
              {
                text: [colors],
              },
            ],

            "text-opacity": [
              {
                "text-opacity": [opacity],
              },
            ],

            "text-decoration": [
              "underline",
              "overline",
              "line-through",
              "no-underline",
            ],

            "text-decoration-style": [
              {
                decoration: [...getLineStyles(), "wavy"],
              },
            ],

            "text-decoration-thickness": [
              {
                decoration: ["auto", "from-font", isLength, isArbitraryLength],
              },
            ],

            "underline-offset": [
              {
                "underline-offset": ["auto", isLength, isArbitraryValue],
              },
            ],

            "text-decoration-color": [
              {
                decoration: [colors],
              },
            ],

            "text-transform": [
              "uppercase",
              "lowercase",
              "capitalize",
              "normal-case",
            ],

            "text-overflow": ["truncate", "text-ellipsis", "text-clip"],

            "text-wrap": [
              {
                text: ["wrap", "nowrap", "balance", "pretty"],
              },
            ],

            indent: [
              {
                indent: getSpacingWithArbitrary(),
              },
            ],

            "vertical-align": [
              {
                align: [
                  "baseline",
                  "top",
                  "middle",
                  "bottom",
                  "text-top",
                  "text-bottom",
                  "sub",
                  "super",
                  isArbitraryValue,
                ],
              },
            ],

            whitespace: [
              {
                whitespace: [
                  "normal",
                  "nowrap",
                  "pre",
                  "pre-line",
                  "pre-wrap",
                  "break-spaces",
                ],
              },
            ],

            break: [
              {
                break: ["normal", "words", "all", "keep"],
              },
            ],

            hyphens: [
              {
                hyphens: ["none", "manual", "auto"],
              },
            ],

            content: [
              {
                content: ["none", isArbitraryValue],
              },
            ],
            // Backgrounds

            "bg-attachment": [
              {
                bg: ["fixed", "local", "scroll"],
              },
            ],

            "bg-clip": [
              {
                "bg-clip": ["border", "padding", "content", "text"],
              },
            ],

            "bg-opacity": [
              {
                "bg-opacity": [opacity],
              },
            ],

            "bg-origin": [
              {
                "bg-origin": ["border", "padding", "content"],
              },
            ],

            "bg-position": [
              {
                bg: [...getPositions(), isArbitraryPosition],
              },
            ],

            "bg-repeat": [
              {
                bg: [
                  "no-repeat",
                  {
                    repeat: ["", "x", "y", "round", "space"],
                  },
                ],
              },
            ],

            "bg-size": [
              {
                bg: ["auto", "cover", "contain", isArbitrarySize],
              },
            ],

            "bg-image": [
              {
                bg: [
                  "none",
                  {
                    "gradient-to": ["t", "tr", "r", "br", "b", "bl", "l", "tl"],
                  },
                  isArbitraryImage,
                ],
              },
            ],

            "bg-color": [
              {
                bg: [colors],
              },
            ],

            "gradient-from-pos": [
              {
                from: [gradientColorStopPositions],
              },
            ],

            "gradient-via-pos": [
              {
                via: [gradientColorStopPositions],
              },
            ],

            "gradient-to-pos": [
              {
                to: [gradientColorStopPositions],
              },
            ],

            "gradient-from": [
              {
                from: [gradientColorStops],
              },
            ],

            "gradient-via": [
              {
                via: [gradientColorStops],
              },
            ],

            "gradient-to": [
              {
                to: [gradientColorStops],
              },
            ],
            // Borders

            rounded: [
              {
                rounded: [borderRadius],
              },
            ],

            "rounded-s": [
              {
                "rounded-s": [borderRadius],
              },
            ],

            "rounded-e": [
              {
                "rounded-e": [borderRadius],
              },
            ],

            "rounded-t": [
              {
                "rounded-t": [borderRadius],
              },
            ],

            "rounded-r": [
              {
                "rounded-r": [borderRadius],
              },
            ],

            "rounded-b": [
              {
                "rounded-b": [borderRadius],
              },
            ],

            "rounded-l": [
              {
                "rounded-l": [borderRadius],
              },
            ],

            "rounded-ss": [
              {
                "rounded-ss": [borderRadius],
              },
            ],

            "rounded-se": [
              {
                "rounded-se": [borderRadius],
              },
            ],

            "rounded-ee": [
              {
                "rounded-ee": [borderRadius],
              },
            ],

            "rounded-es": [
              {
                "rounded-es": [borderRadius],
              },
            ],

            "rounded-tl": [
              {
                "rounded-tl": [borderRadius],
              },
            ],

            "rounded-tr": [
              {
                "rounded-tr": [borderRadius],
              },
            ],

            "rounded-br": [
              {
                "rounded-br": [borderRadius],
              },
            ],

            "rounded-bl": [
              {
                "rounded-bl": [borderRadius],
              },
            ],

            "border-w": [
              {
                border: [borderWidth],
              },
            ],

            "border-w-x": [
              {
                "border-x": [borderWidth],
              },
            ],

            "border-w-y": [
              {
                "border-y": [borderWidth],
              },
            ],

            "border-w-s": [
              {
                "border-s": [borderWidth],
              },
            ],

            "border-w-e": [
              {
                "border-e": [borderWidth],
              },
            ],

            "border-w-t": [
              {
                "border-t": [borderWidth],
              },
            ],

            "border-w-r": [
              {
                "border-r": [borderWidth],
              },
            ],

            "border-w-b": [
              {
                "border-b": [borderWidth],
              },
            ],

            "border-w-l": [
              {
                "border-l": [borderWidth],
              },
            ],

            "border-opacity": [
              {
                "border-opacity": [opacity],
              },
            ],

            "border-style": [
              {
                border: [...getLineStyles(), "hidden"],
              },
            ],

            "divide-x": [
              {
                "divide-x": [borderWidth],
              },
            ],

            "divide-x-reverse": ["divide-x-reverse"],

            "divide-y": [
              {
                "divide-y": [borderWidth],
              },
            ],

            "divide-y-reverse": ["divide-y-reverse"],

            "divide-opacity": [
              {
                "divide-opacity": [opacity],
              },
            ],

            "divide-style": [
              {
                divide: getLineStyles(),
              },
            ],

            "border-color": [
              {
                border: [borderColor],
              },
            ],

            "border-color-x": [
              {
                "border-x": [borderColor],
              },
            ],

            "border-color-y": [
              {
                "border-y": [borderColor],
              },
            ],

            "border-color-s": [
              {
                "border-s": [borderColor],
              },
            ],

            "border-color-e": [
              {
                "border-e": [borderColor],
              },
            ],

            "border-color-t": [
              {
                "border-t": [borderColor],
              },
            ],

            "border-color-r": [
              {
                "border-r": [borderColor],
              },
            ],

            "border-color-b": [
              {
                "border-b": [borderColor],
              },
            ],

            "border-color-l": [
              {
                "border-l": [borderColor],
              },
            ],

            "divide-color": [
              {
                divide: [borderColor],
              },
            ],

            "outline-style": [
              {
                outline: ["", ...getLineStyles()],
              },
            ],

            "outline-offset": [
              {
                "outline-offset": [isLength, isArbitraryValue],
              },
            ],

            "outline-w": [
              {
                outline: [isLength, isArbitraryLength],
              },
            ],

            "outline-color": [
              {
                outline: [colors],
              },
            ],

            "ring-w": [
              {
                ring: getLengthWithEmptyAndArbitrary(),
              },
            ],

            "ring-w-inset": ["ring-inset"],

            "ring-color": [
              {
                ring: [colors],
              },
            ],

            "ring-opacity": [
              {
                "ring-opacity": [opacity],
              },
            ],

            "ring-offset-w": [
              {
                "ring-offset": [isLength, isArbitraryLength],
              },
            ],

            "ring-offset-color": [
              {
                "ring-offset": [colors],
              },
            ],
            // Effects

            shadow: [
              {
                shadow: ["", "inner", "none", isTshirtSize, isArbitraryShadow],
              },
            ],

            "shadow-color": [
              {
                shadow: [isAny],
              },
            ],

            opacity: [
              {
                opacity: [opacity],
              },
            ],

            "mix-blend": [
              {
                "mix-blend": [
                  ...getBlendModes(),
                  "plus-lighter",
                  "plus-darker",
                ],
              },
            ],

            "bg-blend": [
              {
                "bg-blend": getBlendModes(),
              },
            ],
            // Filters

            filter: [
              {
                filter: ["", "none"],
              },
            ],

            blur: [
              {
                blur: [blur],
              },
            ],

            brightness: [
              {
                brightness: [brightness],
              },
            ],

            contrast: [
              {
                contrast: [contrast],
              },
            ],

            "drop-shadow": [
              {
                "drop-shadow": ["", "none", isTshirtSize, isArbitraryValue],
              },
            ],

            grayscale: [
              {
                grayscale: [grayscale],
              },
            ],

            "hue-rotate": [
              {
                "hue-rotate": [hueRotate],
              },
            ],

            invert: [
              {
                invert: [invert],
              },
            ],

            saturate: [
              {
                saturate: [saturate],
              },
            ],

            sepia: [
              {
                sepia: [sepia],
              },
            ],

            "backdrop-filter": [
              {
                "backdrop-filter": ["", "none"],
              },
            ],

            "backdrop-blur": [
              {
                "backdrop-blur": [blur],
              },
            ],

            "backdrop-brightness": [
              {
                "backdrop-brightness": [brightness],
              },
            ],

            "backdrop-contrast": [
              {
                "backdrop-contrast": [contrast],
              },
            ],

            "backdrop-grayscale": [
              {
                "backdrop-grayscale": [grayscale],
              },
            ],

            "backdrop-hue-rotate": [
              {
                "backdrop-hue-rotate": [hueRotate],
              },
            ],

            "backdrop-invert": [
              {
                "backdrop-invert": [invert],
              },
            ],

            "backdrop-opacity": [
              {
                "backdrop-opacity": [opacity],
              },
            ],

            "backdrop-saturate": [
              {
                "backdrop-saturate": [saturate],
              },
            ],

            "backdrop-sepia": [
              {
                "backdrop-sepia": [sepia],
              },
            ],
            // Tables

            "border-collapse": [
              {
                border: ["collapse", "separate"],
              },
            ],

            "border-spacing": [
              {
                "border-spacing": [borderSpacing],
              },
            ],

            "border-spacing-x": [
              {
                "border-spacing-x": [borderSpacing],
              },
            ],

            "border-spacing-y": [
              {
                "border-spacing-y": [borderSpacing],
              },
            ],

            "table-layout": [
              {
                table: ["auto", "fixed"],
              },
            ],

            caption: [
              {
                caption: ["top", "bottom"],
              },
            ],
            // Transitions and Animation

            transition: [
              {
                transition: [
                  "none",
                  "all",
                  "",
                  "colors",
                  "opacity",
                  "shadow",
                  "transform",
                  isArbitraryValue,
                ],
              },
            ],

            duration: [
              {
                duration: getNumberAndArbitrary(),
              },
            ],

            ease: [
              {
                ease: ["linear", "in", "out", "in-out", isArbitraryValue],
              },
            ],

            delay: [
              {
                delay: getNumberAndArbitrary(),
              },
            ],

            animate: [
              {
                animate: [
                  "none",
                  "spin",
                  "ping",
                  "pulse",
                  "bounce",
                  isArbitraryValue,
                ],
              },
            ],
            // Transforms

            transform: [
              {
                transform: ["", "gpu", "none"],
              },
            ],

            scale: [
              {
                scale: [scale],
              },
            ],

            "scale-x": [
              {
                "scale-x": [scale],
              },
            ],

            "scale-y": [
              {
                "scale-y": [scale],
              },
            ],

            rotate: [
              {
                rotate: [isInteger, isArbitraryValue],
              },
            ],

            "translate-x": [
              {
                "translate-x": [translate],
              },
            ],

            "translate-y": [
              {
                "translate-y": [translate],
              },
            ],

            "skew-x": [
              {
                "skew-x": [skew],
              },
            ],

            "skew-y": [
              {
                "skew-y": [skew],
              },
            ],

            "transform-origin": [
              {
                origin: [
                  "center",
                  "top",
                  "top-right",
                  "right",
                  "bottom-right",
                  "bottom",
                  "bottom-left",
                  "left",
                  "top-left",
                  isArbitraryValue,
                ],
              },
            ],
            // Interactivity

            accent: [
              {
                accent: ["auto", colors],
              },
            ],

            appearance: [
              {
                appearance: ["none", "auto"],
              },
            ],

            cursor: [
              {
                cursor: [
                  "auto",
                  "default",
                  "pointer",
                  "wait",
                  "text",
                  "move",
                  "help",
                  "not-allowed",
                  "none",
                  "context-menu",
                  "progress",
                  "cell",
                  "crosshair",
                  "vertical-text",
                  "alias",
                  "copy",
                  "no-drop",
                  "grab",
                  "grabbing",
                  "all-scroll",
                  "col-resize",
                  "row-resize",
                  "n-resize",
                  "e-resize",
                  "s-resize",
                  "w-resize",
                  "ne-resize",
                  "nw-resize",
                  "se-resize",
                  "sw-resize",
                  "ew-resize",
                  "ns-resize",
                  "nesw-resize",
                  "nwse-resize",
                  "zoom-in",
                  "zoom-out",
                  isArbitraryValue,
                ],
              },
            ],

            "caret-color": [
              {
                caret: [colors],
              },
            ],

            "pointer-events": [
              {
                "pointer-events": ["none", "auto"],
              },
            ],

            resize: [
              {
                resize: ["none", "y", "x", ""],
              },
            ],

            "scroll-behavior": [
              {
                scroll: ["auto", "smooth"],
              },
            ],

            "scroll-m": [
              {
                "scroll-m": getSpacingWithArbitrary(),
              },
            ],

            "scroll-mx": [
              {
                "scroll-mx": getSpacingWithArbitrary(),
              },
            ],

            "scroll-my": [
              {
                "scroll-my": getSpacingWithArbitrary(),
              },
            ],

            "scroll-ms": [
              {
                "scroll-ms": getSpacingWithArbitrary(),
              },
            ],

            "scroll-me": [
              {
                "scroll-me": getSpacingWithArbitrary(),
              },
            ],

            "scroll-mt": [
              {
                "scroll-mt": getSpacingWithArbitrary(),
              },
            ],

            "scroll-mr": [
              {
                "scroll-mr": getSpacingWithArbitrary(),
              },
            ],

            "scroll-mb": [
              {
                "scroll-mb": getSpacingWithArbitrary(),
              },
            ],

            "scroll-ml": [
              {
                "scroll-ml": getSpacingWithArbitrary(),
              },
            ],

            "scroll-p": [
              {
                "scroll-p": getSpacingWithArbitrary(),
              },
            ],

            "scroll-px": [
              {
                "scroll-px": getSpacingWithArbitrary(),
              },
            ],

            "scroll-py": [
              {
                "scroll-py": getSpacingWithArbitrary(),
              },
            ],

            "scroll-ps": [
              {
                "scroll-ps": getSpacingWithArbitrary(),
              },
            ],

            "scroll-pe": [
              {
                "scroll-pe": getSpacingWithArbitrary(),
              },
            ],

            "scroll-pt": [
              {
                "scroll-pt": getSpacingWithArbitrary(),
              },
            ],

            "scroll-pr": [
              {
                "scroll-pr": getSpacingWithArbitrary(),
              },
            ],

            "scroll-pb": [
              {
                "scroll-pb": getSpacingWithArbitrary(),
              },
            ],

            "scroll-pl": [
              {
                "scroll-pl": getSpacingWithArbitrary(),
              },
            ],

            "snap-align": [
              {
                snap: ["start", "end", "center", "align-none"],
              },
            ],

            "snap-stop": [
              {
                snap: ["normal", "always"],
              },
            ],

            "snap-type": [
              {
                snap: ["none", "x", "y", "both"],
              },
            ],

            "snap-strictness": [
              {
                snap: ["mandatory", "proximity"],
              },
            ],

            touch: [
              {
                touch: ["auto", "none", "manipulation"],
              },
            ],

            "touch-x": [
              {
                "touch-pan": ["x", "left", "right"],
              },
            ],

            "touch-y": [
              {
                "touch-pan": ["y", "up", "down"],
              },
            ],

            "touch-pz": ["touch-pinch-zoom"],

            select: [
              {
                select: ["none", "text", "all", "auto"],
              },
            ],

            "will-change": [
              {
                "will-change": [
                  "auto",
                  "scroll",
                  "contents",
                  "transform",
                  isArbitraryValue,
                ],
              },
            ],
            // SVG

            fill: [
              {
                fill: [colors, "none"],
              },
            ],

            "stroke-w": [
              {
                stroke: [isLength, isArbitraryLength, isArbitraryNumber],
              },
            ],

            stroke: [
              {
                stroke: [colors, "none"],
              },
            ],
            // Accessibility

            sr: ["sr-only", "not-sr-only"],

            "forced-color-adjust": [
              {
                "forced-color-adjust": ["auto", "none"],
              },
            ],
          },
          conflictingClassGroups: {
            overflow: ["overflow-x", "overflow-y"],
            overscroll: ["overscroll-x", "overscroll-y"],
            inset: [
              "inset-x",
              "inset-y",
              "start",
              "end",
              "top",
              "right",
              "bottom",
              "left",
            ],
            "inset-x": ["right", "left"],
            "inset-y": ["top", "bottom"],
            flex: ["basis", "grow", "shrink"],
            gap: ["gap-x", "gap-y"],
            p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"],
            px: ["pr", "pl"],
            py: ["pt", "pb"],
            m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"],
            mx: ["mr", "ml"],
            my: ["mt", "mb"],
            size: ["w", "h"],
            "font-size": ["leading"],
            "fvn-normal": [
              "fvn-ordinal",
              "fvn-slashed-zero",
              "fvn-figure",
              "fvn-spacing",
              "fvn-fraction",
            ],
            "fvn-ordinal": ["fvn-normal"],
            "fvn-slashed-zero": ["fvn-normal"],
            "fvn-figure": ["fvn-normal"],
            "fvn-spacing": ["fvn-normal"],
            "fvn-fraction": ["fvn-normal"],
            "line-clamp": ["display", "overflow"],
            rounded: [
              "rounded-s",
              "rounded-e",
              "rounded-t",
              "rounded-r",
              "rounded-b",
              "rounded-l",
              "rounded-ss",
              "rounded-se",
              "rounded-ee",
              "rounded-es",
              "rounded-tl",
              "rounded-tr",
              "rounded-br",
              "rounded-bl",
            ],
            "rounded-s": ["rounded-ss", "rounded-es"],
            "rounded-e": ["rounded-se", "rounded-ee"],
            "rounded-t": ["rounded-tl", "rounded-tr"],
            "rounded-r": ["rounded-tr", "rounded-br"],
            "rounded-b": ["rounded-br", "rounded-bl"],
            "rounded-l": ["rounded-tl", "rounded-bl"],
            "border-spacing": ["border-spacing-x", "border-spacing-y"],
            "border-w": [
              "border-w-s",
              "border-w-e",
              "border-w-t",
              "border-w-r",
              "border-w-b",
              "border-w-l",
            ],
            "border-w-x": ["border-w-r", "border-w-l"],
            "border-w-y": ["border-w-t", "border-w-b"],
            "border-color": [
              "border-color-s",
              "border-color-e",
              "border-color-t",
              "border-color-r",
              "border-color-b",
              "border-color-l",
            ],
            "border-color-x": ["border-color-r", "border-color-l"],
            "border-color-y": ["border-color-t", "border-color-b"],
            "scroll-m": [
              "scroll-mx",
              "scroll-my",
              "scroll-ms",
              "scroll-me",
              "scroll-mt",
              "scroll-mr",
              "scroll-mb",
              "scroll-ml",
            ],
            "scroll-mx": ["scroll-mr", "scroll-ml"],
            "scroll-my": ["scroll-mt", "scroll-mb"],
            "scroll-p": [
              "scroll-px",
              "scroll-py",
              "scroll-ps",
              "scroll-pe",
              "scroll-pt",
              "scroll-pr",
              "scroll-pb",
              "scroll-pl",
            ],
            "scroll-px": ["scroll-pr", "scroll-pl"],
            "scroll-py": ["scroll-pt", "scroll-pb"],
            touch: ["touch-x", "touch-y", "touch-pz"],
            "touch-x": ["touch"],
            "touch-y": ["touch"],
            "touch-pz": ["touch"],
          },
          conflictingClassGroupModifiers: {
            "font-size": ["leading"],
          },
        };
      };
      const twMerge = /*#__PURE__*/ createTailwindMerge(getDefaultConfig);

      function cn(...inputs) {
        return twMerge(clsx(inputs));
      }

      const ToastProvider = Provider$1;
      const ToastViewport = reactExports.forwardRef(
        ({ className, ...props }, ref) =>
          /* @__PURE__ */ jsxRuntimeExports.jsx(Viewport, {
            ref,
            className: cn(
              "fixed top-0 z-[100] flex max-h-screen w-full flex-col-reverse p-4 sm:bottom-0 sm:right-0 sm:top-auto sm:flex-col md:max-w-[420px]",
              className,
            ),
            ...props,
          }),
      );
      ToastViewport.displayName = Viewport.displayName;
      const toastVariants = cva(
        "group pointer-events-auto relative flex w-full items-center justify-between space-x-4 overflow-hidden rounded-md border p-6 pr-8 shadow-lg transition-all data-[swipe=cancel]:translate-x-0 data-[swipe=end]:translate-x-[var(--radix-toast-swipe-end-x)] data-[swipe=move]:translate-x-[var(--radix-toast-swipe-move-x)] data-[swipe=move]:transition-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[swipe=end]:animate-out data-[state=closed]:fade-out-80 data-[state=closed]:slide-out-to-right-full data-[state=open]:slide-in-from-top-full data-[state=open]:sm:slide-in-from-bottom-full",
        {
          variants: {
            variant: {
              default: "border bg-background text-foreground",
              destructive:
                "destructive group border-destructive bg-destructive text-destructive-foreground",
            },
          },
          defaultVariants: {
            variant: "default",
          },
        },
      );
      const Toast = reactExports.forwardRef(
        ({ className, variant, ...props }, ref) => {
          return /* @__PURE__ */ jsxRuntimeExports.jsx(Root2, {
            ref,
            className: cn(toastVariants({ variant }), className),
            ...props,
          });
        },
      );
      Toast.displayName = Root2.displayName;
      const ToastAction = reactExports.forwardRef(
        ({ className, ...props }, ref) =>
          /* @__PURE__ */ jsxRuntimeExports.jsx(Action$1, {
            ref,
            className: cn(
              "inline-flex h-8 shrink-0 items-center justify-center rounded-md border bg-transparent px-3 text-sm font-medium ring-offset-background transition-colors group-[.destructive]:border-muted/40 hover:bg-secondary group-[.destructive]:hover:border-destructive/30 group-[.destructive]:hover:bg-destructive group-[.destructive]:hover:text-destructive-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 group-[.destructive]:focus:ring-destructive disabled:pointer-events-none disabled:opacity-50",
              className,
            ),
            ...props,
          }),
      );
      ToastAction.displayName = Action$1.displayName;
      const ToastClose = reactExports.forwardRef(
        ({ className, ...props }, ref) =>
          /* @__PURE__ */ jsxRuntimeExports.jsx(Close, {
            ref,
            className: cn(
              "absolute right-2 top-2 rounded-md p-1 text-foreground/50 opacity-0 transition-opacity group-hover:opacity-100 group-[.destructive]:text-red-300 hover:text-foreground group-[.destructive]:hover:text-red-50 focus:opacity-100 focus:outline-none focus:ring-2 group-[.destructive]:focus:ring-red-400 group-[.destructive]:focus:ring-offset-red-600",
              className,
            ),
            "toast-close": "",
            ...props,
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(X, {
              className: "h-4 w-4",
            }),
          }),
      );
      ToastClose.displayName = Close.displayName;
      const ToastTitle = reactExports.forwardRef(
        ({ className, ...props }, ref) =>
          /* @__PURE__ */ jsxRuntimeExports.jsx(Title, {
            ref,
            className: cn("text-sm font-semibold", className),
            ...props,
          }),
      );
      ToastTitle.displayName = Title.displayName;
      const ToastDescription = reactExports.forwardRef(
        ({ className, ...props }, ref) =>
          /* @__PURE__ */ jsxRuntimeExports.jsx(Description, {
            ref,
            className: cn("text-sm opacity-90", className),
            ...props,
          }),
      );
      ToastDescription.displayName = Description.displayName;

      function Toaster$1() {
        const { toasts } = useToast();
        return /* @__PURE__ */ jsxRuntimeExports.jsxs(ToastProvider, {
          children: [
            toasts.map(function ({ id, title, description, action, ...props }) {
              return /* @__PURE__ */ jsxRuntimeExports.jsxs(
                Toast,
                {
                  ...props,
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", {
                      className: "grid gap-1",
                      children: [
                        title &&
                          /* @__PURE__ */ jsxRuntimeExports.jsx(ToastTitle, {
                            children: title,
                          }),
                        description &&
                          /* @__PURE__ */ jsxRuntimeExports.jsx(
                            ToastDescription,
                            { children: description },
                          ),
                      ],
                    }),
                    action,
                    /* @__PURE__ */ jsxRuntimeExports.jsx(ToastClose, {}),
                  ],
                },
                id,
              );
            }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(ToastViewport, {}),
          ],
        });
      }

      var P = ["light", "dark"],
        E = "(prefers-color-scheme: dark)",
        L = reactExports.createContext(void 0),
        D = { setTheme: (e) => {}, themes: [] },
        j = () => {
          var e;
          return (e = reactExports.useContext(L)) != null ? e : D;
        };
      reactExports.memo(
        ({
          forcedTheme: e,
          storageKey: a,
          attribute: n,
          enableSystem: g,
          enableColorScheme: m,
          defaultTheme: c,
          value: o,
          attrs: y,
          nonce: h,
        }) => {
          let k = c === "system",
            w =
              n === "class"
                ? `var d=document.documentElement,c=d.classList;${`c.remove(${y.map((u) => `'${u}'`).join(",")})`};`
                : `var d=document.documentElement,n='${n}',s='setAttribute';`,
            i = m
              ? (P.includes(c) ? c : null)
                ? `if(e==='light'||e==='dark'||!e)d.style.colorScheme=e||'${c}'`
                : "if(e==='light'||e==='dark')d.style.colorScheme=e"
              : "",
            d = (l, u = false, R = true) => {
              let f = o ? o[l] : l,
                p = u ? l + "|| ''" : `'${f}'`,
                $ = "";
              return (
                m &&
                  R &&
                  !u &&
                  P.includes(l) &&
                  ($ += `d.style.colorScheme = '${l}';`),
                n === "class"
                  ? u || f
                    ? ($ += `c.add(${p})`)
                    : ($ += "null")
                  : f && ($ += `d[s](n,${p})`),
                $
              );
            },
            S = e
              ? `!function(){${w}${d(e)}}()`
              : g
                ? `!function(){try{${w}var e=localStorage.getItem('${a}');if('system'===e||(!e&&${k})){var t='${E}',m=window.matchMedia(t);if(m.media!==t||m.matches){${d("dark")}}else{${d("light")}}}else if(e){${o ? `var x=${JSON.stringify(o)};` : ""}${d(o ? "x[e]" : "e", true)}}${k ? "" : "else{" + d(c, false, false) + "}"}${i}}catch(e){}}()`
                : `!function(){try{${w}var e=localStorage.getItem('${a}');if(e){${o ? `var x=${JSON.stringify(o)};` : ""}${d(o ? "x[e]" : "e", true)}}else{${d(c, false, false)};}${i}}catch(t){}}();`;
          return reactExports.createElement("script", {
            nonce: h,
            dangerouslySetInnerHTML: { __html: S },
          });
        },
      );

      var jt = (n) => {
          switch (n) {
            case "success":
              return ee;
            case "info":
              return ae;
            case "warning":
              return oe;
            case "error":
              return se;
            default:
              return null;
          }
        },
        te = Array(12).fill(0),
        Yt = ({ visible: n, className: e }) =>
          React.createElement(
            "div",
            {
              className: ["sonner-loading-wrapper", e]
                .filter(Boolean)
                .join(" "),
              "data-visible": n,
            },
            React.createElement(
              "div",
              { className: "sonner-spinner" },
              te.map((t, a) =>
                React.createElement("div", {
                  className: "sonner-loading-bar",
                  key: `spinner-bar-${a}`,
                }),
              ),
            ),
          ),
        ee = React.createElement(
          "svg",
          {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 20 20",
            fill: "currentColor",
            height: "20",
            width: "20",
          },
          React.createElement("path", {
            fillRule: "evenodd",
            d: "M10 18a8 8 0 100-16 8 8 0 000 16zm3.857-9.809a.75.75 0 00-1.214-.882l-3.483 4.79-1.88-1.88a.75.75 0 10-1.06 1.061l2.5 2.5a.75.75 0 001.137-.089l4-5.5z",
            clipRule: "evenodd",
          }),
        ),
        oe = React.createElement(
          "svg",
          {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 24 24",
            fill: "currentColor",
            height: "20",
            width: "20",
          },
          React.createElement("path", {
            fillRule: "evenodd",
            d: "M9.401 3.003c1.155-2 4.043-2 5.197 0l7.355 12.748c1.154 2-.29 4.5-2.599 4.5H4.645c-2.309 0-3.752-2.5-2.598-4.5L9.4 3.003zM12 8.25a.75.75 0 01.75.75v3.75a.75.75 0 01-1.5 0V9a.75.75 0 01.75-.75zm0 8.25a.75.75 0 100-1.5.75.75 0 000 1.5z",
            clipRule: "evenodd",
          }),
        ),
        ae = React.createElement(
          "svg",
          {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 20 20",
            fill: "currentColor",
            height: "20",
            width: "20",
          },
          React.createElement("path", {
            fillRule: "evenodd",
            d: "M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a.75.75 0 000 1.5h.253a.25.25 0 01.244.304l-.459 2.066A1.75 1.75 0 0010.747 15H11a.75.75 0 000-1.5h-.253a.25.25 0 01-.244-.304l.459-2.066A1.75 1.75 0 009.253 9H9z",
            clipRule: "evenodd",
          }),
        ),
        se = React.createElement(
          "svg",
          {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 20 20",
            fill: "currentColor",
            height: "20",
            width: "20",
          },
          React.createElement("path", {
            fillRule: "evenodd",
            d: "M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-8-5a.75.75 0 01.75.75v4.5a.75.75 0 01-1.5 0v-4.5A.75.75 0 0110 5zm0 10a1 1 0 100-2 1 1 0 000 2z",
            clipRule: "evenodd",
          }),
        ),
        Ot = React.createElement(
          "svg",
          {
            xmlns: "http://www.w3.org/2000/svg",
            width: "12",
            height: "12",
            viewBox: "0 0 24 24",
            fill: "none",
            stroke: "currentColor",
            strokeWidth: "1.5",
            strokeLinecap: "round",
            strokeLinejoin: "round",
          },
          React.createElement("line", { x1: "18", y1: "6", x2: "6", y2: "18" }),
          React.createElement("line", { x1: "6", y1: "6", x2: "18", y2: "18" }),
        );
      var Ft = () => {
        let [n, e] = React.useState(document.hidden);
        return (
          React.useEffect(() => {
            let t = () => {
              e(document.hidden);
            };
            return (
              document.addEventListener("visibilitychange", t),
              () => window.removeEventListener("visibilitychange", t)
            );
          }, []),
          n
        );
      };
      var bt = 1,
        yt = class {
          constructor() {
            this.subscribe = (e) => (
              this.subscribers.push(e),
              () => {
                let t = this.subscribers.indexOf(e);
                this.subscribers.splice(t, 1);
              }
            );
            this.publish = (e) => {
              this.subscribers.forEach((t) => t(e));
            };
            this.addToast = (e) => {
              (this.publish(e), (this.toasts = [...this.toasts, e]));
            };
            this.create = (e) => {
              var S;
              let { message: t, ...a } = e,
                u =
                  typeof (e == null ? void 0 : e.id) == "number" ||
                  ((S = e.id) == null ? void 0 : S.length) > 0
                    ? e.id
                    : bt++,
                f = this.toasts.find((g) => g.id === u),
                w = e.dismissible === void 0 ? true : e.dismissible;
              return (
                this.dismissedToasts.has(u) && this.dismissedToasts.delete(u),
                f
                  ? (this.toasts = this.toasts.map((g) =>
                      g.id === u
                        ? (this.publish({ ...g, ...e, id: u, title: t }),
                          { ...g, ...e, id: u, dismissible: w, title: t })
                        : g,
                    ))
                  : this.addToast({ title: t, ...a, dismissible: w, id: u }),
                u
              );
            };
            this.dismiss = (e) => (
              this.dismissedToasts.add(e),
              e ||
                this.toasts.forEach((t) => {
                  this.subscribers.forEach((a) =>
                    a({ id: t.id, dismiss: true }),
                  );
                }),
              this.subscribers.forEach((t) => t({ id: e, dismiss: true })),
              e
            );
            this.message = (e, t) => this.create({ ...t, message: e });
            this.error = (e, t) =>
              this.create({ ...t, message: e, type: "error" });
            this.success = (e, t) =>
              this.create({ ...t, type: "success", message: e });
            this.info = (e, t) =>
              this.create({ ...t, type: "info", message: e });
            this.warning = (e, t) =>
              this.create({ ...t, type: "warning", message: e });
            this.loading = (e, t) =>
              this.create({ ...t, type: "loading", message: e });
            this.promise = (e, t) => {
              if (!t) return;
              let a;
              t.loading !== void 0 &&
                (a = this.create({
                  ...t,
                  promise: e,
                  type: "loading",
                  message: t.loading,
                  description:
                    typeof t.description != "function" ? t.description : void 0,
                }));
              let u = e instanceof Promise ? e : e(),
                f = a !== void 0,
                w,
                S = u
                  .then(async (i) => {
                    if (((w = ["resolve", i]), React.isValidElement(i)))
                      ((f = false),
                        this.create({ id: a, type: "default", message: i }));
                    else if (ie(i) && !i.ok) {
                      f = false;
                      let T =
                          typeof t.error == "function"
                            ? await t.error(`HTTP error! status: ${i.status}`)
                            : t.error,
                        F =
                          typeof t.description == "function"
                            ? await t.description(
                                `HTTP error! status: ${i.status}`,
                              )
                            : t.description;
                      this.create({
                        id: a,
                        type: "error",
                        message: T,
                        description: F,
                      });
                    } else if (t.success !== void 0) {
                      f = false;
                      let T =
                          typeof t.success == "function"
                            ? await t.success(i)
                            : t.success,
                        F =
                          typeof t.description == "function"
                            ? await t.description(i)
                            : t.description;
                      this.create({
                        id: a,
                        type: "success",
                        message: T,
                        description: F,
                      });
                    }
                  })
                  .catch(async (i) => {
                    if (((w = ["reject", i]), t.error !== void 0)) {
                      f = false;
                      let D =
                          typeof t.error == "function"
                            ? await t.error(i)
                            : t.error,
                        T =
                          typeof t.description == "function"
                            ? await t.description(i)
                            : t.description;
                      this.create({
                        id: a,
                        type: "error",
                        message: D,
                        description: T,
                      });
                    }
                  })
                  .finally(() => {
                    var i;
                    (f && (this.dismiss(a), (a = void 0)),
                      (i = t.finally) == null || i.call(t));
                  }),
                g = () =>
                  new Promise((i, D) =>
                    S.then(() => (w[0] === "reject" ? D(w[1]) : i(w[1]))).catch(
                      D,
                    ),
                  );
              return typeof a != "string" && typeof a != "number"
                ? { unwrap: g }
                : Object.assign(a, { unwrap: g });
            };
            this.custom = (e, t) => {
              let a = (t == null ? void 0 : t.id) || bt++;
              return (this.create({ jsx: e(a), id: a, ...t }), a);
            };
            this.getActiveToasts = () =>
              this.toasts.filter((e) => !this.dismissedToasts.has(e.id));
            ((this.subscribers = []),
              (this.toasts = []),
              (this.dismissedToasts = new Set()));
          }
        },
        v = new yt(),
        ne = (n, e) => {
          let t = (e == null ? void 0 : e.id) || bt++;
          return (v.addToast({ title: n, ...e, id: t }), t);
        },
        ie = (n) =>
          n &&
          typeof n == "object" &&
          "ok" in n &&
          typeof n.ok == "boolean" &&
          "status" in n &&
          typeof n.status == "number",
        le = ne,
        ce = () => v.toasts,
        de = () => v.getActiveToasts();
      Object.assign(
        le,
        {
          success: v.success,
          info: v.info,
          warning: v.warning,
          error: v.error,
          custom: v.custom,
          message: v.message,
          promise: v.promise,
          dismiss: v.dismiss,
          loading: v.loading,
        },
        { getHistory: ce, getToasts: de },
      );
      function wt(n, { insertAt: e } = {}) {
        if (typeof document == "undefined") return;
        let t = document.head || document.getElementsByTagName("head")[0],
          a = document.createElement("style");
        ((a.type = "text/css"),
          e === "top" && t.firstChild
            ? t.insertBefore(a, t.firstChild)
            : t.appendChild(a),
          a.styleSheet
            ? (a.styleSheet.cssText = n)
            : a.appendChild(document.createTextNode(n)));
      }
      wt(`:where(html[dir="ltr"]),:where([data-sonner-toaster][dir="ltr"]){--toast-icon-margin-start: -3px;--toast-icon-margin-end: 4px;--toast-svg-margin-start: -1px;--toast-svg-margin-end: 0px;--toast-button-margin-start: auto;--toast-button-margin-end: 0;--toast-close-button-start: 0;--toast-close-button-end: unset;--toast-close-button-transform: translate(-35%, -35%)}:where(html[dir="rtl"]),:where([data-sonner-toaster][dir="rtl"]){--toast-icon-margin-start: 4px;--toast-icon-margin-end: -3px;--toast-svg-margin-start: 0px;--toast-svg-margin-end: -1px;--toast-button-margin-start: 0;--toast-button-margin-end: auto;--toast-close-button-start: unset;--toast-close-button-end: 0;--toast-close-button-transform: translate(35%, -35%)}:where([data-sonner-toaster]){position:fixed;width:var(--width);font-family:ui-sans-serif,system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Arial,Noto Sans,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol,Noto Color Emoji;--gray1: hsl(0, 0%, 99%);--gray2: hsl(0, 0%, 97.3%);--gray3: hsl(0, 0%, 95.1%);--gray4: hsl(0, 0%, 93%);--gray5: hsl(0, 0%, 90.9%);--gray6: hsl(0, 0%, 88.7%);--gray7: hsl(0, 0%, 85.8%);--gray8: hsl(0, 0%, 78%);--gray9: hsl(0, 0%, 56.1%);--gray10: hsl(0, 0%, 52.3%);--gray11: hsl(0, 0%, 43.5%);--gray12: hsl(0, 0%, 9%);--border-radius: 8px;box-sizing:border-box;padding:0;margin:0;list-style:none;outline:none;z-index:999999999;transition:transform .4s ease}:where([data-sonner-toaster][data-lifted="true"]){transform:translateY(-10px)}@media (hover: none) and (pointer: coarse){:where([data-sonner-toaster][data-lifted="true"]){transform:none}}:where([data-sonner-toaster][data-x-position="right"]){right:var(--offset-right)}:where([data-sonner-toaster][data-x-position="left"]){left:var(--offset-left)}:where([data-sonner-toaster][data-x-position="center"]){left:50%;transform:translate(-50%)}:where([data-sonner-toaster][data-y-position="top"]){top:var(--offset-top)}:where([data-sonner-toaster][data-y-position="bottom"]){bottom:var(--offset-bottom)}:where([data-sonner-toast]){--y: translateY(100%);--lift-amount: calc(var(--lift) * var(--gap));z-index:var(--z-index);position:absolute;opacity:0;transform:var(--y);filter:blur(0);touch-action:none;transition:transform .4s,opacity .4s,height .4s,box-shadow .2s;box-sizing:border-box;outline:none;overflow-wrap:anywhere}:where([data-sonner-toast][data-styled="true"]){padding:16px;background:var(--normal-bg);border:1px solid var(--normal-border);color:var(--normal-text);border-radius:var(--border-radius);box-shadow:0 4px 12px #0000001a;width:var(--width);font-size:13px;display:flex;align-items:center;gap:6px}:where([data-sonner-toast]:focus-visible){box-shadow:0 4px 12px #0000001a,0 0 0 2px #0003}:where([data-sonner-toast][data-y-position="top"]){top:0;--y: translateY(-100%);--lift: 1;--lift-amount: calc(1 * var(--gap))}:where([data-sonner-toast][data-y-position="bottom"]){bottom:0;--y: translateY(100%);--lift: -1;--lift-amount: calc(var(--lift) * var(--gap))}:where([data-sonner-toast]) :where([data-description]){font-weight:400;line-height:1.4;color:inherit}:where([data-sonner-toast]) :where([data-title]){font-weight:500;line-height:1.5;color:inherit}:where([data-sonner-toast]) :where([data-icon]){display:flex;height:16px;width:16px;position:relative;justify-content:flex-start;align-items:center;flex-shrink:0;margin-left:var(--toast-icon-margin-start);margin-right:var(--toast-icon-margin-end)}:where([data-sonner-toast][data-promise="true"]) :where([data-icon])>svg{opacity:0;transform:scale(.8);transform-origin:center;animation:sonner-fade-in .3s ease forwards}:where([data-sonner-toast]) :where([data-icon])>*{flex-shrink:0}:where([data-sonner-toast]) :where([data-icon]) svg{margin-left:var(--toast-svg-margin-start);margin-right:var(--toast-svg-margin-end)}:where([data-sonner-toast]) :where([data-content]){display:flex;flex-direction:column;gap:2px}[data-sonner-toast][data-styled=true] [data-button]{border-radius:4px;padding-left:8px;padding-right:8px;height:24px;font-size:12px;color:var(--normal-bg);background:var(--normal-text);margin-left:var(--toast-button-margin-start);margin-right:var(--toast-button-margin-end);border:none;cursor:pointer;outline:none;display:flex;align-items:center;flex-shrink:0;transition:opacity .4s,box-shadow .2s}:where([data-sonner-toast]) :where([data-button]):focus-visible{box-shadow:0 0 0 2px #0006}:where([data-sonner-toast]) :where([data-button]):first-of-type{margin-left:var(--toast-button-margin-start);margin-right:var(--toast-button-margin-end)}:where([data-sonner-toast]) :where([data-cancel]){color:var(--normal-text);background:rgba(0,0,0,.08)}:where([data-sonner-toast][data-theme="dark"]) :where([data-cancel]){background:rgba(255,255,255,.3)}:where([data-sonner-toast]) :where([data-close-button]){position:absolute;left:var(--toast-close-button-start);right:var(--toast-close-button-end);top:0;height:20px;width:20px;display:flex;justify-content:center;align-items:center;padding:0;color:var(--gray12);border:1px solid var(--gray4);transform:var(--toast-close-button-transform);border-radius:50%;cursor:pointer;z-index:1;transition:opacity .1s,background .2s,border-color .2s}[data-sonner-toast] [data-close-button]{background:var(--gray1)}:where([data-sonner-toast]) :where([data-close-button]):focus-visible{box-shadow:0 4px 12px #0000001a,0 0 0 2px #0003}:where([data-sonner-toast]) :where([data-disabled="true"]){cursor:not-allowed}:where([data-sonner-toast]):hover :where([data-close-button]):hover{background:var(--gray2);border-color:var(--gray5)}:where([data-sonner-toast][data-swiping="true"]):before{content:"";position:absolute;left:-50%;right:-50%;height:100%;z-index:-1}:where([data-sonner-toast][data-y-position="top"][data-swiping="true"]):before{bottom:50%;transform:scaleY(3) translateY(50%)}:where([data-sonner-toast][data-y-position="bottom"][data-swiping="true"]):before{top:50%;transform:scaleY(3) translateY(-50%)}:where([data-sonner-toast][data-swiping="false"][data-removed="true"]):before{content:"";position:absolute;inset:0;transform:scaleY(2)}:where([data-sonner-toast]):after{content:"";position:absolute;left:0;height:calc(var(--gap) + 1px);bottom:100%;width:100%}:where([data-sonner-toast][data-mounted="true"]){--y: translateY(0);opacity:1}:where([data-sonner-toast][data-expanded="false"][data-front="false"]){--scale: var(--toasts-before) * .05 + 1;--y: translateY(calc(var(--lift-amount) * var(--toasts-before))) scale(calc(-1 * var(--scale)));height:var(--front-toast-height)}:where([data-sonner-toast])>*{transition:opacity .4s}:where([data-sonner-toast][data-expanded="false"][data-front="false"][data-styled="true"])>*{opacity:0}:where([data-sonner-toast][data-visible="false"]){opacity:0;pointer-events:none}:where([data-sonner-toast][data-mounted="true"][data-expanded="true"]){--y: translateY(calc(var(--lift) * var(--offset)));height:var(--initial-height)}:where([data-sonner-toast][data-removed="true"][data-front="true"][data-swipe-out="false"]){--y: translateY(calc(var(--lift) * -100%));opacity:0}:where([data-sonner-toast][data-removed="true"][data-front="false"][data-swipe-out="false"][data-expanded="true"]){--y: translateY(calc(var(--lift) * var(--offset) + var(--lift) * -100%));opacity:0}:where([data-sonner-toast][data-removed="true"][data-front="false"][data-swipe-out="false"][data-expanded="false"]){--y: translateY(40%);opacity:0;transition:transform .5s,opacity .2s}:where([data-sonner-toast][data-removed="true"][data-front="false"]):before{height:calc(var(--initial-height) + 20%)}[data-sonner-toast][data-swiping=true]{transform:var(--y) translateY(var(--swipe-amount-y, 0px)) translate(var(--swipe-amount-x, 0px));transition:none}[data-sonner-toast][data-swiped=true]{user-select:none}[data-sonner-toast][data-swipe-out=true][data-y-position=bottom],[data-sonner-toast][data-swipe-out=true][data-y-position=top]{animation-duration:.2s;animation-timing-function:ease-out;animation-fill-mode:forwards}[data-sonner-toast][data-swipe-out=true][data-swipe-direction=left]{animation-name:swipe-out-left}[data-sonner-toast][data-swipe-out=true][data-swipe-direction=right]{animation-name:swipe-out-right}[data-sonner-toast][data-swipe-out=true][data-swipe-direction=up]{animation-name:swipe-out-up}[data-sonner-toast][data-swipe-out=true][data-swipe-direction=down]{animation-name:swipe-out-down}@keyframes swipe-out-left{0%{transform:var(--y) translate(var(--swipe-amount-x));opacity:1}to{transform:var(--y) translate(calc(var(--swipe-amount-x) - 100%));opacity:0}}@keyframes swipe-out-right{0%{transform:var(--y) translate(var(--swipe-amount-x));opacity:1}to{transform:var(--y) translate(calc(var(--swipe-amount-x) + 100%));opacity:0}}@keyframes swipe-out-up{0%{transform:var(--y) translateY(var(--swipe-amount-y));opacity:1}to{transform:var(--y) translateY(calc(var(--swipe-amount-y) - 100%));opacity:0}}@keyframes swipe-out-down{0%{transform:var(--y) translateY(var(--swipe-amount-y));opacity:1}to{transform:var(--y) translateY(calc(var(--swipe-amount-y) + 100%));opacity:0}}@media (max-width: 600px){[data-sonner-toaster]{position:fixed;right:var(--mobile-offset-right);left:var(--mobile-offset-left);width:100%}[data-sonner-toaster][dir=rtl]{left:calc(var(--mobile-offset-left) * -1)}[data-sonner-toaster] [data-sonner-toast]{left:0;right:0;width:calc(100% - var(--mobile-offset-left) * 2)}[data-sonner-toaster][data-x-position=left]{left:var(--mobile-offset-left)}[data-sonner-toaster][data-y-position=bottom]{bottom:var(--mobile-offset-bottom)}[data-sonner-toaster][data-y-position=top]{top:var(--mobile-offset-top)}[data-sonner-toaster][data-x-position=center]{left:var(--mobile-offset-left);right:var(--mobile-offset-right);transform:none}}[data-sonner-toaster][data-theme=light]{--normal-bg: #fff;--normal-border: var(--gray4);--normal-text: var(--gray12);--success-bg: hsl(143, 85%, 96%);--success-border: hsl(145, 92%, 91%);--success-text: hsl(140, 100%, 27%);--info-bg: hsl(208, 100%, 97%);--info-border: hsl(221, 91%, 91%);--info-text: hsl(210, 92%, 45%);--warning-bg: hsl(49, 100%, 97%);--warning-border: hsl(49, 91%, 91%);--warning-text: hsl(31, 92%, 45%);--error-bg: hsl(359, 100%, 97%);--error-border: hsl(359, 100%, 94%);--error-text: hsl(360, 100%, 45%)}[data-sonner-toaster][data-theme=light] [data-sonner-toast][data-invert=true]{--normal-bg: #000;--normal-border: hsl(0, 0%, 20%);--normal-text: var(--gray1)}[data-sonner-toaster][data-theme=dark] [data-sonner-toast][data-invert=true]{--normal-bg: #fff;--normal-border: var(--gray3);--normal-text: var(--gray12)}[data-sonner-toaster][data-theme=dark]{--normal-bg: #000;--normal-bg-hover: hsl(0, 0%, 12%);--normal-border: hsl(0, 0%, 20%);--normal-border-hover: hsl(0, 0%, 25%);--normal-text: var(--gray1);--success-bg: hsl(150, 100%, 6%);--success-border: hsl(147, 100%, 12%);--success-text: hsl(150, 86%, 65%);--info-bg: hsl(215, 100%, 6%);--info-border: hsl(223, 100%, 12%);--info-text: hsl(216, 87%, 65%);--warning-bg: hsl(64, 100%, 6%);--warning-border: hsl(60, 100%, 12%);--warning-text: hsl(46, 87%, 65%);--error-bg: hsl(358, 76%, 10%);--error-border: hsl(357, 89%, 16%);--error-text: hsl(358, 100%, 81%)}[data-sonner-toaster][data-theme=dark] [data-sonner-toast] [data-close-button]{background:var(--normal-bg);border-color:var(--normal-border);color:var(--normal-text)}[data-sonner-toaster][data-theme=dark] [data-sonner-toast] [data-close-button]:hover{background:var(--normal-bg-hover);border-color:var(--normal-border-hover)}[data-rich-colors=true][data-sonner-toast][data-type=success],[data-rich-colors=true][data-sonner-toast][data-type=success] [data-close-button]{background:var(--success-bg);border-color:var(--success-border);color:var(--success-text)}[data-rich-colors=true][data-sonner-toast][data-type=info],[data-rich-colors=true][data-sonner-toast][data-type=info] [data-close-button]{background:var(--info-bg);border-color:var(--info-border);color:var(--info-text)}[data-rich-colors=true][data-sonner-toast][data-type=warning],[data-rich-colors=true][data-sonner-toast][data-type=warning] [data-close-button]{background:var(--warning-bg);border-color:var(--warning-border);color:var(--warning-text)}[data-rich-colors=true][data-sonner-toast][data-type=error],[data-rich-colors=true][data-sonner-toast][data-type=error] [data-close-button]{background:var(--error-bg);border-color:var(--error-border);color:var(--error-text)}.sonner-loading-wrapper{--size: 16px;height:var(--size);width:var(--size);position:absolute;inset:0;z-index:10}.sonner-loading-wrapper[data-visible=false]{transform-origin:center;animation:sonner-fade-out .2s ease forwards}.sonner-spinner{position:relative;top:50%;left:50%;height:var(--size);width:var(--size)}.sonner-loading-bar{animation:sonner-spin 1.2s linear infinite;background:var(--gray11);border-radius:6px;height:8%;left:-10%;position:absolute;top:-3.9%;width:24%}.sonner-loading-bar:nth-child(1){animation-delay:-1.2s;transform:rotate(.0001deg) translate(146%)}.sonner-loading-bar:nth-child(2){animation-delay:-1.1s;transform:rotate(30deg) translate(146%)}.sonner-loading-bar:nth-child(3){animation-delay:-1s;transform:rotate(60deg) translate(146%)}.sonner-loading-bar:nth-child(4){animation-delay:-.9s;transform:rotate(90deg) translate(146%)}.sonner-loading-bar:nth-child(5){animation-delay:-.8s;transform:rotate(120deg) translate(146%)}.sonner-loading-bar:nth-child(6){animation-delay:-.7s;transform:rotate(150deg) translate(146%)}.sonner-loading-bar:nth-child(7){animation-delay:-.6s;transform:rotate(180deg) translate(146%)}.sonner-loading-bar:nth-child(8){animation-delay:-.5s;transform:rotate(210deg) translate(146%)}.sonner-loading-bar:nth-child(9){animation-delay:-.4s;transform:rotate(240deg) translate(146%)}.sonner-loading-bar:nth-child(10){animation-delay:-.3s;transform:rotate(270deg) translate(146%)}.sonner-loading-bar:nth-child(11){animation-delay:-.2s;transform:rotate(300deg) translate(146%)}.sonner-loading-bar:nth-child(12){animation-delay:-.1s;transform:rotate(330deg) translate(146%)}@keyframes sonner-fade-in{0%{opacity:0;transform:scale(.8)}to{opacity:1;transform:scale(1)}}@keyframes sonner-fade-out{0%{opacity:1;transform:scale(1)}to{opacity:0;transform:scale(.8)}}@keyframes sonner-spin{0%{opacity:1}to{opacity:.15}}@media (prefers-reduced-motion){[data-sonner-toast],[data-sonner-toast]>*,.sonner-loading-bar{transition:none!important;animation:none!important}}.sonner-loader{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);transform-origin:center;transition:opacity .2s,transform .2s}.sonner-loader[data-visible=false]{opacity:0;transform:scale(.8) translate(-50%,-50%)}
`);
      function tt(n) {
        return n.label !== void 0;
      }
      var pe = 3,
        me = "32px",
        ge = "16px",
        Wt = 4e3,
        he = 356,
        be = 14,
        ye = 20,
        we = 200;
      function M(...n) {
        return n.filter(Boolean).join(" ");
      }
      function xe(n) {
        let [e, t] = n.split("-"),
          a = [];
        return (e && a.push(e), t && a.push(t), a);
      }
      var ve = (n) => {
        var Dt, Pt, Nt, Bt, Ct, kt, It, Mt, Ht, At, Lt;
        let {
            invert: e,
            toast: t,
            unstyled: a,
            interacting: u,
            setHeights: f,
            visibleToasts: w,
            heights: S,
            index: g,
            toasts: i,
            expanded: D,
            removeToast: T,
            defaultRichColors: F,
            closeButton: et,
            style: ut,
            cancelButtonStyle: ft,
            actionButtonStyle: l,
            className: ot = "",
            descriptionClassName: at = "",
            duration: X,
            position: st,
            gap: pt,
            loadingIcon: rt,
            expandByDefault: B,
            classNames: s,
            icons: P,
            closeButtonAriaLabel: nt = "Close toast",
            pauseWhenPageIsHidden: it,
          } = n,
          [Y, C] = React.useState(null),
          [lt, J] = React.useState(null),
          [W, H] = React.useState(false),
          [A, mt] = React.useState(false),
          [L, z] = React.useState(false),
          [ct, d] = React.useState(false),
          [h, y] = React.useState(false),
          [R, j] = React.useState(0),
          [p, _] = React.useState(0),
          O = React.useRef(t.duration || X || Wt),
          G = React.useRef(null),
          k = React.useRef(null),
          Vt = g === 0,
          Ut = g + 1 <= w,
          N = t.type,
          V = t.dismissible !== false,
          Kt = t.className || "",
          Xt = t.descriptionClassName || "",
          dt = React.useMemo(
            () => S.findIndex((r) => r.toastId === t.id) || 0,
            [S, t.id],
          ),
          Jt = React.useMemo(() => {
            var r;
            return (r = t.closeButton) != null ? r : et;
          }, [t.closeButton, et]),
          Tt = React.useMemo(() => t.duration || X || Wt, [t.duration, X]),
          gt = React.useRef(0),
          U = React.useRef(0),
          St = React.useRef(0),
          K = React.useRef(null),
          [Gt, Qt] = st.split("-"),
          Rt = React.useMemo(
            () => S.reduce((r, m, c) => (c >= dt ? r : r + m.height), 0),
            [S, dt],
          ),
          Et = Ft(),
          qt = t.invert || e,
          ht = N === "loading";
        ((U.current = React.useMemo(() => dt * pt + Rt, [dt, Rt])),
          React.useEffect(() => {
            O.current = Tt;
          }, [Tt]),
          React.useEffect(() => {
            H(true);
          }, []),
          React.useEffect(() => {
            let r = k.current;
            if (r) {
              let m = r.getBoundingClientRect().height;
              return (
                _(m),
                f((c) => [
                  { toastId: t.id, height: m, position: t.position },
                  ...c,
                ]),
                () => f((c) => c.filter((b) => b.toastId !== t.id))
              );
            }
          }, [f, t.id]),
          React.useLayoutEffect(() => {
            if (!W) return;
            let r = k.current,
              m = r.style.height;
            r.style.height = "auto";
            let c = r.getBoundingClientRect().height;
            ((r.style.height = m),
              _(c),
              f((b) =>
                b.find((x) => x.toastId === t.id)
                  ? b.map((x) => (x.toastId === t.id ? { ...x, height: c } : x))
                  : [{ toastId: t.id, height: c, position: t.position }, ...b],
              ));
          }, [W, t.title, t.description, f, t.id]));
        let $ = React.useCallback(() => {
          (mt(true),
            j(U.current),
            f((r) => r.filter((m) => m.toastId !== t.id)),
            setTimeout(() => {
              T(t);
            }, we));
        }, [t, T, f, U]);
        (React.useEffect(() => {
          if (
            (t.promise && N === "loading") ||
            t.duration === 1 / 0 ||
            t.type === "loading"
          )
            return;
          let r;
          return (
            D || u || (it && Et)
              ? (() => {
                  if (St.current < gt.current) {
                    let b = new Date().getTime() - gt.current;
                    O.current = O.current - b;
                  }
                  St.current = new Date().getTime();
                })()
              : (() => {
                  O.current !== 1 / 0 &&
                    ((gt.current = new Date().getTime()),
                    (r = setTimeout(() => {
                      var b;
                      ((b = t.onAutoClose) == null || b.call(t, t), $());
                    }, O.current)));
                })(),
            () => clearTimeout(r)
          );
        }, [D, u, t, N, it, Et, $]),
          React.useEffect(() => {
            t.delete && $();
          }, [$, t.delete]));
        function Zt() {
          var r, m, c;
          return P != null && P.loading
            ? React.createElement(
                "div",
                {
                  className: M(
                    s == null ? void 0 : s.loader,
                    (r = t == null ? void 0 : t.classNames) == null
                      ? void 0
                      : r.loader,
                    "sonner-loader",
                  ),
                  "data-visible": N === "loading",
                },
                P.loading,
              )
            : rt
              ? React.createElement(
                  "div",
                  {
                    className: M(
                      s == null ? void 0 : s.loader,
                      (m = t == null ? void 0 : t.classNames) == null
                        ? void 0
                        : m.loader,
                      "sonner-loader",
                    ),
                    "data-visible": N === "loading",
                  },
                  rt,
                )
              : React.createElement(Yt, {
                  className: M(
                    s == null ? void 0 : s.loader,
                    (c = t == null ? void 0 : t.classNames) == null
                      ? void 0
                      : c.loader,
                  ),
                  visible: N === "loading",
                });
        }
        return React.createElement(
          "li",
          {
            tabIndex: 0,
            ref: k,
            className: M(
              ot,
              Kt,
              s == null ? void 0 : s.toast,
              (Dt = t == null ? void 0 : t.classNames) == null
                ? void 0
                : Dt.toast,
              s == null ? void 0 : s.default,
              s == null ? void 0 : s[N],
              (Pt = t == null ? void 0 : t.classNames) == null ? void 0 : Pt[N],
            ),
            "data-sonner-toast": "",
            "data-rich-colors": (Nt = t.richColors) != null ? Nt : F,
            "data-styled": !(t.jsx || t.unstyled || a),
            "data-mounted": W,
            "data-promise": !!t.promise,
            "data-swiped": h,
            "data-removed": A,
            "data-visible": Ut,
            "data-y-position": Gt,
            "data-x-position": Qt,
            "data-index": g,
            "data-front": Vt,
            "data-swiping": L,
            "data-dismissible": V,
            "data-type": N,
            "data-invert": qt,
            "data-swipe-out": ct,
            "data-swipe-direction": lt,
            "data-expanded": !!(D || (B && W)),
            style: {
              "--index": g,
              "--toasts-before": g,
              "--z-index": i.length - g,
              "--offset": `${A ? R : U.current}px`,
              "--initial-height": B ? "auto" : `${p}px`,
              ...ut,
              ...t.style,
            },
            onDragEnd: () => {
              (z(false), C(null), (K.current = null));
            },
            onPointerDown: (r) => {
              ht ||
                !V ||
                ((G.current = new Date()),
                j(U.current),
                r.target.setPointerCapture(r.pointerId),
                r.target.tagName !== "BUTTON" &&
                  (z(true), (K.current = { x: r.clientX, y: r.clientY })));
            },
            onPointerUp: () => {
              var x, Q, q, Z;
              if (ct || !V) return;
              K.current = null;
              let r = Number(
                  ((x = k.current) == null
                    ? void 0
                    : x.style
                        .getPropertyValue("--swipe-amount-x")
                        .replace("px", "")) || 0,
                ),
                m = Number(
                  ((Q = k.current) == null
                    ? void 0
                    : Q.style
                        .getPropertyValue("--swipe-amount-y")
                        .replace("px", "")) || 0,
                ),
                c =
                  new Date().getTime() -
                  ((q = G.current) == null ? void 0 : q.getTime()),
                b = Y === "x" ? r : m,
                I = Math.abs(b) / c;
              if (Math.abs(b) >= ye || I > 0.11) {
                (j(U.current),
                  (Z = t.onDismiss) == null || Z.call(t, t),
                  J(
                    Y === "x"
                      ? r > 0
                        ? "right"
                        : "left"
                      : m > 0
                        ? "down"
                        : "up",
                  ),
                  $(),
                  d(true),
                  y(false));
                return;
              }
              (z(false), C(null));
            },
            onPointerMove: (r) => {
              var Q, q, Z, zt;
              if (
                !K.current ||
                !V ||
                ((Q = window.getSelection()) == null
                  ? void 0
                  : Q.toString().length) > 0
              )
                return;
              let c = r.clientY - K.current.y,
                b = r.clientX - K.current.x,
                I = (q = n.swipeDirections) != null ? q : xe(st);
              !Y &&
                (Math.abs(b) > 1 || Math.abs(c) > 1) &&
                C(Math.abs(b) > Math.abs(c) ? "x" : "y");
              let x = { x: 0, y: 0 };
              (Y === "y"
                ? (I.includes("top") || I.includes("bottom")) &&
                  ((I.includes("top") && c < 0) ||
                    (I.includes("bottom") && c > 0)) &&
                  (x.y = c)
                : Y === "x" &&
                  (I.includes("left") || I.includes("right")) &&
                  ((I.includes("left") && b < 0) ||
                    (I.includes("right") && b > 0)) &&
                  (x.x = b),
                (Math.abs(x.x) > 0 || Math.abs(x.y) > 0) && y(true),
                (Z = k.current) == null ||
                  Z.style.setProperty("--swipe-amount-x", `${x.x}px`),
                (zt = k.current) == null ||
                  zt.style.setProperty("--swipe-amount-y", `${x.y}px`));
            },
          },
          Jt && !t.jsx
            ? React.createElement(
                "button",
                {
                  "aria-label": nt,
                  "data-disabled": ht,
                  "data-close-button": true,
                  onClick:
                    ht || !V
                      ? () => {}
                      : () => {
                          var r;
                          ($(), (r = t.onDismiss) == null || r.call(t, t));
                        },
                  className: M(
                    s == null ? void 0 : s.closeButton,
                    (Bt = t == null ? void 0 : t.classNames) == null
                      ? void 0
                      : Bt.closeButton,
                  ),
                },
                (Ct = P == null ? void 0 : P.close) != null ? Ct : Ot,
              )
            : null,
          t.jsx || reactExports.isValidElement(t.title)
            ? t.jsx
              ? t.jsx
              : typeof t.title == "function"
                ? t.title()
                : t.title
            : React.createElement(
                React.Fragment,
                null,
                N || t.icon || t.promise
                  ? React.createElement(
                      "div",
                      {
                        "data-icon": "",
                        className: M(
                          s == null ? void 0 : s.icon,
                          (kt = t == null ? void 0 : t.classNames) == null
                            ? void 0
                            : kt.icon,
                        ),
                      },
                      t.promise || (t.type === "loading" && !t.icon)
                        ? t.icon || Zt()
                        : null,
                      t.type !== "loading"
                        ? t.icon || (P == null ? void 0 : P[N]) || jt(N)
                        : null,
                    )
                  : null,
                React.createElement(
                  "div",
                  {
                    "data-content": "",
                    className: M(
                      s == null ? void 0 : s.content,
                      (It = t == null ? void 0 : t.classNames) == null
                        ? void 0
                        : It.content,
                    ),
                  },
                  React.createElement(
                    "div",
                    {
                      "data-title": "",
                      className: M(
                        s == null ? void 0 : s.title,
                        (Mt = t == null ? void 0 : t.classNames) == null
                          ? void 0
                          : Mt.title,
                      ),
                    },
                    typeof t.title == "function" ? t.title() : t.title,
                  ),
                  t.description
                    ? React.createElement(
                        "div",
                        {
                          "data-description": "",
                          className: M(
                            at,
                            Xt,
                            s == null ? void 0 : s.description,
                            (Ht = t == null ? void 0 : t.classNames) == null
                              ? void 0
                              : Ht.description,
                          ),
                        },
                        typeof t.description == "function"
                          ? t.description()
                          : t.description,
                      )
                    : null,
                ),
                reactExports.isValidElement(t.cancel)
                  ? t.cancel
                  : t.cancel && tt(t.cancel)
                    ? React.createElement(
                        "button",
                        {
                          "data-button": true,
                          "data-cancel": true,
                          style: t.cancelButtonStyle || ft,
                          onClick: (r) => {
                            var m, c;
                            tt(t.cancel) &&
                              V &&
                              ((c = (m = t.cancel).onClick) == null ||
                                c.call(m, r),
                              $());
                          },
                          className: M(
                            s == null ? void 0 : s.cancelButton,
                            (At = t == null ? void 0 : t.classNames) == null
                              ? void 0
                              : At.cancelButton,
                          ),
                        },
                        t.cancel.label,
                      )
                    : null,
                reactExports.isValidElement(t.action)
                  ? t.action
                  : t.action && tt(t.action)
                    ? React.createElement(
                        "button",
                        {
                          "data-button": true,
                          "data-action": true,
                          style: t.actionButtonStyle || l,
                          onClick: (r) => {
                            var m, c;
                            tt(t.action) &&
                              ((c = (m = t.action).onClick) == null ||
                                c.call(m, r),
                              !r.defaultPrevented && $());
                          },
                          className: M(
                            s == null ? void 0 : s.actionButton,
                            (Lt = t == null ? void 0 : t.classNames) == null
                              ? void 0
                              : Lt.actionButton,
                          ),
                        },
                        t.action.label,
                      )
                    : null,
              ),
        );
      };
      function _t() {
        if (typeof window == "undefined" || typeof document == "undefined")
          return "ltr";
        let n = document.documentElement.getAttribute("dir");
        return n === "auto" || !n
          ? window.getComputedStyle(document.documentElement).direction
          : n;
      }
      function Te(n, e) {
        let t = {};
        return (
          [n, e].forEach((a, u) => {
            let f = u === 1,
              w = f ? "--mobile-offset" : "--offset",
              S = f ? ge : me;
            function g(i) {
              ["top", "right", "bottom", "left"].forEach((D) => {
                t[`${w}-${D}`] = typeof i == "number" ? `${i}px` : i;
              });
            }
            typeof a == "number" || typeof a == "string"
              ? g(a)
              : typeof a == "object"
                ? ["top", "right", "bottom", "left"].forEach((i) => {
                    a[i] === void 0
                      ? (t[`${w}-${i}`] = S)
                      : (t[`${w}-${i}`] =
                          typeof a[i] == "number" ? `${a[i]}px` : a[i]);
                  })
                : g(S);
          }),
          t
        );
      }
      var $e = reactExports.forwardRef(function (e, t) {
        let {
            invert: a,
            position: u = "bottom-right",
            hotkey: f = ["altKey", "KeyT"],
            expand: w,
            closeButton: S,
            className: g,
            offset: i,
            mobileOffset: D,
            theme: T = "light",
            richColors: F,
            duration: et,
            style: ut,
            visibleToasts: ft = pe,
            toastOptions: l,
            dir: ot = _t(),
            gap: at = be,
            loadingIcon: X,
            icons: st,
            containerAriaLabel: pt = "Notifications",
            pauseWhenPageIsHidden: rt,
          } = e,
          [B, s] = React.useState([]),
          P = React.useMemo(
            () =>
              Array.from(
                new Set(
                  [u].concat(
                    B.filter((d) => d.position).map((d) => d.position),
                  ),
                ),
              ),
            [B, u],
          ),
          [nt, it] = React.useState([]),
          [Y, C] = React.useState(false),
          [lt, J] = React.useState(false),
          [W, H] = React.useState(
            T !== "system"
              ? T
              : typeof window != "undefined" &&
                  window.matchMedia &&
                  window.matchMedia("(prefers-color-scheme: dark)").matches
                ? "dark"
                : "light",
          ),
          A = React.useRef(null),
          mt = f.join("+").replace(/Key/g, "").replace(/Digit/g, ""),
          L = React.useRef(null),
          z = React.useRef(false),
          ct = React.useCallback((d) => {
            s((h) => {
              var y;
              return (
                ((y = h.find((R) => R.id === d.id)) != null && y.delete) ||
                  v.dismiss(d.id),
                h.filter(({ id: R }) => R !== d.id)
              );
            });
          }, []);
        return (
          React.useEffect(
            () =>
              v.subscribe((d) => {
                if (d.dismiss) {
                  s((h) =>
                    h.map((y) => (y.id === d.id ? { ...y, delete: true } : y)),
                  );
                  return;
                }
                setTimeout(() => {
                  vt.flushSync(() => {
                    s((h) => {
                      let y = h.findIndex((R) => R.id === d.id);
                      return y !== -1
                        ? [
                            ...h.slice(0, y),
                            { ...h[y], ...d },
                            ...h.slice(y + 1),
                          ]
                        : [d, ...h];
                    });
                  });
                });
              }),
            [],
          ),
          React.useEffect(() => {
            if (T !== "system") {
              H(T);
              return;
            }
            if (
              (T === "system" &&
                (window.matchMedia &&
                window.matchMedia("(prefers-color-scheme: dark)").matches
                  ? H("dark")
                  : H("light")),
              typeof window == "undefined")
            )
              return;
            let d = window.matchMedia("(prefers-color-scheme: dark)");
            try {
              d.addEventListener("change", ({ matches: h }) => {
                H(h ? "dark" : "light");
              });
            } catch (h) {
              d.addListener(({ matches: y }) => {
                try {
                  H(y ? "dark" : "light");
                } catch (R) {
                  console.error(R);
                }
              });
            }
          }, [T]),
          React.useEffect(() => {
            B.length <= 1 && C(false);
          }, [B]),
          React.useEffect(() => {
            let d = (h) => {
              var R, j;
              (f.every((p) => h[p] || h.code === p) &&
                (C(true), (R = A.current) == null || R.focus()),
                h.code === "Escape" &&
                  (document.activeElement === A.current ||
                    ((j = A.current) != null &&
                      j.contains(document.activeElement))) &&
                  C(false));
            };
            return (
              document.addEventListener("keydown", d),
              () => document.removeEventListener("keydown", d)
            );
          }, [f]),
          React.useEffect(() => {
            if (A.current)
              return () => {
                L.current &&
                  (L.current.focus({ preventScroll: true }),
                  (L.current = null),
                  (z.current = false));
              };
          }, [A.current]),
          React.createElement(
            "section",
            {
              ref: t,
              "aria-label": `${pt} ${mt}`,
              tabIndex: -1,
              "aria-live": "polite",
              "aria-relevant": "additions text",
              "aria-atomic": "false",
              suppressHydrationWarning: true,
            },
            P.map((d, h) => {
              var j;
              let [y, R] = d.split("-");
              return B.length
                ? React.createElement(
                    "ol",
                    {
                      key: d,
                      dir: ot === "auto" ? _t() : ot,
                      tabIndex: -1,
                      ref: A,
                      className: g,
                      "data-sonner-toaster": true,
                      "data-theme": W,
                      "data-y-position": y,
                      "data-lifted": Y && B.length > 1 && !w,
                      "data-x-position": R,
                      style: {
                        "--front-toast-height": `${((j = nt[0]) == null ? void 0 : j.height) || 0}px`,
                        "--width": `${he}px`,
                        "--gap": `${at}px`,
                        ...ut,
                        ...Te(i, D),
                      },
                      onBlur: (p) => {
                        z.current &&
                          !p.currentTarget.contains(p.relatedTarget) &&
                          ((z.current = false),
                          L.current &&
                            (L.current.focus({ preventScroll: true }),
                            (L.current = null)));
                      },
                      onFocus: (p) => {
                        (p.target instanceof HTMLElement &&
                          p.target.dataset.dismissible === "false") ||
                          z.current ||
                          ((z.current = true), (L.current = p.relatedTarget));
                      },
                      onMouseEnter: () => C(true),
                      onMouseMove: () => C(true),
                      onMouseLeave: () => {
                        lt || C(false);
                      },
                      onDragEnd: () => C(false),
                      onPointerDown: (p) => {
                        (p.target instanceof HTMLElement &&
                          p.target.dataset.dismissible === "false") ||
                          J(true);
                      },
                      onPointerUp: () => J(false),
                    },
                    B.filter(
                      (p) => (!p.position && h === 0) || p.position === d,
                    ).map((p, _) => {
                      var O, G;
                      return React.createElement(ve, {
                        key: p.id,
                        icons: st,
                        index: _,
                        toast: p,
                        defaultRichColors: F,
                        duration:
                          (O = l == null ? void 0 : l.duration) != null
                            ? O
                            : et,
                        className: l == null ? void 0 : l.className,
                        descriptionClassName:
                          l == null ? void 0 : l.descriptionClassName,
                        invert: a,
                        visibleToasts: ft,
                        closeButton:
                          (G = l == null ? void 0 : l.closeButton) != null
                            ? G
                            : S,
                        interacting: lt,
                        position: d,
                        style: l == null ? void 0 : l.style,
                        unstyled: l == null ? void 0 : l.unstyled,
                        classNames: l == null ? void 0 : l.classNames,
                        cancelButtonStyle:
                          l == null ? void 0 : l.cancelButtonStyle,
                        actionButtonStyle:
                          l == null ? void 0 : l.actionButtonStyle,
                        removeToast: ct,
                        toasts: B.filter((k) => k.position == p.position),
                        heights: nt.filter((k) => k.position == p.position),
                        setHeights: it,
                        expandByDefault: w,
                        gap: at,
                        loadingIcon: X,
                        expanded: Y,
                        pauseWhenPageIsHidden: rt,
                        swipeDirections: e.swipeDirections,
                      });
                    }),
                  )
                : null;
            }),
          )
        );
      });

      const Toaster = ({ ...props }) => {
        const { theme = "system" } = j();
        return /* @__PURE__ */ jsxRuntimeExports.jsx($e, {
          theme,
          className: "toaster group",
          toastOptions: {
            classNames: {
              toast:
                "group toast group-[.toaster]:bg-background group-[.toaster]:text-foreground group-[.toaster]:border-border group-[.toaster]:shadow-lg",
              description: "group-[.toast]:text-muted-foreground",
              actionButton:
                "group-[.toast]:bg-primary group-[.toast]:text-primary-foreground",
              cancelButton:
                "group-[.toast]:bg-muted group-[.toast]:text-muted-foreground",
            },
          },
          ...props,
        });
      };

      const sides = ["top", "right", "bottom", "left"];
      const min = Math.min;
      const max = Math.max;
      const round = Math.round;
      const floor = Math.floor;
      const createCoords = (v) => ({
        x: v,
        y: v,
      });
      const oppositeSideMap = {
        left: "right",
        right: "left",
        bottom: "top",
        top: "bottom",
      };
      const oppositeAlignmentMap = {
        start: "end",
        end: "start",
      };
      function clamp$1(start, value, end) {
        return max(start, min(value, end));
      }
      function evaluate(value, param) {
        return typeof value === "function" ? value(param) : value;
      }
      function getSide(placement) {
        return placement.split("-")[0];
      }
      function getAlignment(placement) {
        return placement.split("-")[1];
      }
      function getOppositeAxis(axis) {
        return axis === "x" ? "y" : "x";
      }
      function getAxisLength(axis) {
        return axis === "y" ? "height" : "width";
      }
      const yAxisSides = /*#__PURE__*/ new Set(["top", "bottom"]);
      function getSideAxis(placement) {
        return yAxisSides.has(getSide(placement)) ? "y" : "x";
      }
      function getAlignmentAxis(placement) {
        return getOppositeAxis(getSideAxis(placement));
      }
      function getAlignmentSides(placement, rects, rtl) {
        if (rtl === void 0) {
          rtl = false;
        }
        const alignment = getAlignment(placement);
        const alignmentAxis = getAlignmentAxis(placement);
        const length = getAxisLength(alignmentAxis);
        let mainAlignmentSide =
          alignmentAxis === "x"
            ? alignment === (rtl ? "end" : "start")
              ? "right"
              : "left"
            : alignment === "start"
              ? "bottom"
              : "top";
        if (rects.reference[length] > rects.floating[length]) {
          mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
        }
        return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
      }
      function getExpandedPlacements(placement) {
        const oppositePlacement = getOppositePlacement(placement);
        return [
          getOppositeAlignmentPlacement(placement),
          oppositePlacement,
          getOppositeAlignmentPlacement(oppositePlacement),
        ];
      }
      function getOppositeAlignmentPlacement(placement) {
        return placement.replace(
          /start|end/g,
          (alignment) => oppositeAlignmentMap[alignment],
        );
      }
      const lrPlacement = ["left", "right"];
      const rlPlacement = ["right", "left"];
      const tbPlacement = ["top", "bottom"];
      const btPlacement = ["bottom", "top"];
      function getSideList(side, isStart, rtl) {
        switch (side) {
          case "top":
          case "bottom":
            if (rtl) return isStart ? rlPlacement : lrPlacement;
            return isStart ? lrPlacement : rlPlacement;
          case "left":
          case "right":
            return isStart ? tbPlacement : btPlacement;
          default:
            return [];
        }
      }
      function getOppositeAxisPlacements(
        placement,
        flipAlignment,
        direction,
        rtl,
      ) {
        const alignment = getAlignment(placement);
        let list = getSideList(getSide(placement), direction === "start", rtl);
        if (alignment) {
          list = list.map((side) => side + "-" + alignment);
          if (flipAlignment) {
            list = list.concat(list.map(getOppositeAlignmentPlacement));
          }
        }
        return list;
      }
      function getOppositePlacement(placement) {
        return placement.replace(
          /left|right|bottom|top/g,
          (side) => oppositeSideMap[side],
        );
      }
      function expandPaddingObject(padding) {
        return {
          top: 0,
          right: 0,
          bottom: 0,
          left: 0,
          ...padding,
        };
      }
      function getPaddingObject(padding) {
        return typeof padding !== "number"
          ? expandPaddingObject(padding)
          : {
              top: padding,
              right: padding,
              bottom: padding,
              left: padding,
            };
      }
      function rectToClientRect(rect) {
        const { x, y, width, height } = rect;
        return {
          width,
          height,
          top: y,
          left: x,
          right: x + width,
          bottom: y + height,
          x,
          y,
        };
      }

      function computeCoordsFromPlacement(_ref, placement, rtl) {
        let { reference, floating } = _ref;
        const sideAxis = getSideAxis(placement);
        const alignmentAxis = getAlignmentAxis(placement);
        const alignLength = getAxisLength(alignmentAxis);
        const side = getSide(placement);
        const isVertical = sideAxis === "y";
        const commonX = reference.x + reference.width / 2 - floating.width / 2;
        const commonY =
          reference.y + reference.height / 2 - floating.height / 2;
        const commonAlign =
          reference[alignLength] / 2 - floating[alignLength] / 2;
        let coords;
        switch (side) {
          case "top":
            coords = {
              x: commonX,
              y: reference.y - floating.height,
            };
            break;
          case "bottom":
            coords = {
              x: commonX,
              y: reference.y + reference.height,
            };
            break;
          case "right":
            coords = {
              x: reference.x + reference.width,
              y: commonY,
            };
            break;
          case "left":
            coords = {
              x: reference.x - floating.width,
              y: commonY,
            };
            break;
          default:
            coords = {
              x: reference.x,
              y: reference.y,
            };
        }
        switch (getAlignment(placement)) {
          case "start":
            coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
            break;
          case "end":
            coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
            break;
        }
        return coords;
      }

      const computePosition$1 = async (reference, floating, config) => {
        const {
          placement = "bottom",
          strategy = "absolute",
          middleware = [],
          platform,
        } = config;
        const validMiddleware = middleware.filter(Boolean);
        const rtl = await (platform.isRTL == null
          ? void 0
          : platform.isRTL(floating));
        let rects = await platform.getElementRects({
          reference,
          floating,
          strategy,
        });
        let { x, y } = computeCoordsFromPlacement(rects, placement, rtl);
        let statefulPlacement = placement;
        let middlewareData = {};
        let resetCount = 0;
        for (let i = 0; i < validMiddleware.length; i++) {
          const { name, fn } = validMiddleware[i];
          const {
            x: nextX,
            y: nextY,
            data,
            reset,
          } = await fn({
            x,
            y,
            initialPlacement: placement,
            placement: statefulPlacement,
            strategy,
            middlewareData,
            rects,
            platform,
            elements: {
              reference,
              floating,
            },
          });
          x = nextX != null ? nextX : x;
          y = nextY != null ? nextY : y;
          middlewareData = {
            ...middlewareData,
            [name]: {
              ...middlewareData[name],
              ...data,
            },
          };
          if (reset && resetCount <= 50) {
            resetCount++;
            if (typeof reset === "object") {
              if (reset.placement) {
                statefulPlacement = reset.placement;
              }
              if (reset.rects) {
                rects =
                  reset.rects === true
                    ? await platform.getElementRects({
                        reference,
                        floating,
                        strategy,
                      })
                    : reset.rects;
              }
              ({ x, y } = computeCoordsFromPlacement(
                rects,
                statefulPlacement,
                rtl,
              ));
            }
            i = -1;
          }
        }
        return {
          x,
          y,
          placement: statefulPlacement,
          strategy,
          middlewareData,
        };
      };

      async function detectOverflow(state, options) {
        var _await$platform$isEle;
        if (options === void 0) {
          options = {};
        }
        const { x, y, platform, rects, elements, strategy } = state;
        const {
          boundary = "clippingAncestors",
          rootBoundary = "viewport",
          elementContext = "floating",
          altBoundary = false,
          padding = 0,
        } = evaluate(options, state);
        const paddingObject = getPaddingObject(padding);
        const altContext =
          elementContext === "floating" ? "reference" : "floating";
        const element = elements[altBoundary ? altContext : elementContext];
        const clippingClientRect = rectToClientRect(
          await platform.getClippingRect({
            element: (
              (_await$platform$isEle = await (platform.isElement == null
                ? void 0
                : platform.isElement(element))) != null
                ? _await$platform$isEle
                : true
            )
              ? element
              : element.contextElement ||
                (await (platform.getDocumentElement == null
                  ? void 0
                  : platform.getDocumentElement(elements.floating))),
            boundary,
            rootBoundary,
            strategy,
          }),
        );
        const rect =
          elementContext === "floating"
            ? {
                x,
                y,
                width: rects.floating.width,
                height: rects.floating.height,
              }
            : rects.reference;
        const offsetParent = await (platform.getOffsetParent == null
          ? void 0
          : platform.getOffsetParent(elements.floating));
        const offsetScale = (await (platform.isElement == null
          ? void 0
          : platform.isElement(offsetParent)))
          ? (await (platform.getScale == null
              ? void 0
              : platform.getScale(offsetParent))) || {
              x: 1,
              y: 1,
            }
          : {
              x: 1,
              y: 1,
            };
        const elementClientRect = rectToClientRect(
          platform.convertOffsetParentRelativeRectToViewportRelativeRect
            ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect(
                {
                  elements,
                  rect,
                  offsetParent,
                  strategy,
                },
              )
            : rect,
        );
        return {
          top:
            (clippingClientRect.top -
              elementClientRect.top +
              paddingObject.top) /
            offsetScale.y,
          bottom:
            (elementClientRect.bottom -
              clippingClientRect.bottom +
              paddingObject.bottom) /
            offsetScale.y,
          left:
            (clippingClientRect.left -
              elementClientRect.left +
              paddingObject.left) /
            offsetScale.x,
          right:
            (elementClientRect.right -
              clippingClientRect.right +
              paddingObject.right) /
            offsetScale.x,
        };
      }

      const arrow$3 = (options) => ({
        name: "arrow",
        options,
        async fn(state) {
          const { x, y, placement, rects, platform, elements, middlewareData } =
            state;
          // Since `element` is required, we don't Partial<> the type.
          const { element, padding = 0 } = evaluate(options, state) || {};
          if (element == null) {
            return {};
          }
          const paddingObject = getPaddingObject(padding);
          const coords = {
            x,
            y,
          };
          const axis = getAlignmentAxis(placement);
          const length = getAxisLength(axis);
          const arrowDimensions = await platform.getDimensions(element);
          const isYAxis = axis === "y";
          const minProp = isYAxis ? "top" : "left";
          const maxProp = isYAxis ? "bottom" : "right";
          const clientProp = isYAxis ? "clientHeight" : "clientWidth";
          const endDiff =
            rects.reference[length] +
            rects.reference[axis] -
            coords[axis] -
            rects.floating[length];
          const startDiff = coords[axis] - rects.reference[axis];
          const arrowOffsetParent = await (platform.getOffsetParent == null
            ? void 0
            : platform.getOffsetParent(element));
          let clientSize = arrowOffsetParent
            ? arrowOffsetParent[clientProp]
            : 0;

          // DOM platform can return `window` as the `offsetParent`.
          if (
            !clientSize ||
            !(await (platform.isElement == null
              ? void 0
              : platform.isElement(arrowOffsetParent)))
          ) {
            clientSize =
              elements.floating[clientProp] || rects.floating[length];
          }
          const centerToReference = endDiff / 2 - startDiff / 2;

          // If the padding is large enough that it causes the arrow to no longer be
          // centered, modify the padding so that it is centered.
          const largestPossiblePadding =
            clientSize / 2 - arrowDimensions[length] / 2 - 1;
          const minPadding = min(
            paddingObject[minProp],
            largestPossiblePadding,
          );
          const maxPadding = min(
            paddingObject[maxProp],
            largestPossiblePadding,
          );

          // Make sure the arrow doesn't overflow the floating element if the center
          // point is outside the floating element's bounds.
          const min$1 = minPadding;
          const max = clientSize - arrowDimensions[length] - maxPadding;
          const center =
            clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
          const offset = clamp$1(min$1, center, max);

          // If the reference is small enough that the arrow's padding causes it to
          // to point to nothing for an aligned placement, adjust the offset of the
          // floating element itself. To ensure `shift()` continues to take action,
          // a single reset is performed when this is true.
          const shouldAddOffset =
            !middlewareData.arrow &&
            getAlignment(placement) != null &&
            center !== offset &&
            rects.reference[length] / 2 -
              (center < min$1 ? minPadding : maxPadding) -
              arrowDimensions[length] / 2 <
              0;
          const alignmentOffset = shouldAddOffset
            ? center < min$1
              ? center - min$1
              : center - max
            : 0;
          return {
            [axis]: coords[axis] + alignmentOffset,
            data: {
              [axis]: offset,
              centerOffset: center - offset - alignmentOffset,
              ...(shouldAddOffset && {
                alignmentOffset,
              }),
            },
            reset: shouldAddOffset,
          };
        },
      });

      const flip$2 = function (options) {
        if (options === void 0) {
          options = {};
        }
        return {
          name: "flip",
          options,
          async fn(state) {
            var _middlewareData$arrow, _middlewareData$flip;
            const {
              placement,
              middlewareData,
              rects,
              initialPlacement,
              platform,
              elements,
            } = state;
            const {
              mainAxis: checkMainAxis = true,
              crossAxis: checkCrossAxis = true,
              fallbackPlacements: specifiedFallbackPlacements,
              fallbackStrategy = "bestFit",
              fallbackAxisSideDirection = "none",
              flipAlignment = true,
              ...detectOverflowOptions
            } = evaluate(options, state);

            // If a reset by the arrow was caused due to an alignment offset being
            // added, we should skip any logic now since `flip()` has already done its
            // work.
            // https://github.com/floating-ui/floating-ui/issues/2549#issuecomment-1719601643
            if (
              (_middlewareData$arrow = middlewareData.arrow) != null &&
              _middlewareData$arrow.alignmentOffset
            ) {
              return {};
            }
            const side = getSide(placement);
            const initialSideAxis = getSideAxis(initialPlacement);
            const isBasePlacement =
              getSide(initialPlacement) === initialPlacement;
            const rtl = await (platform.isRTL == null
              ? void 0
              : platform.isRTL(elements.floating));
            const fallbackPlacements =
              specifiedFallbackPlacements ||
              (isBasePlacement || !flipAlignment
                ? [getOppositePlacement(initialPlacement)]
                : getExpandedPlacements(initialPlacement));
            const hasFallbackAxisSideDirection =
              fallbackAxisSideDirection !== "none";
            if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {
              fallbackPlacements.push(
                ...getOppositeAxisPlacements(
                  initialPlacement,
                  flipAlignment,
                  fallbackAxisSideDirection,
                  rtl,
                ),
              );
            }
            const placements = [initialPlacement, ...fallbackPlacements];
            const overflow = await detectOverflow(state, detectOverflowOptions);
            const overflows = [];
            let overflowsData =
              ((_middlewareData$flip = middlewareData.flip) == null
                ? void 0
                : _middlewareData$flip.overflows) || [];
            if (checkMainAxis) {
              overflows.push(overflow[side]);
            }
            if (checkCrossAxis) {
              const sides = getAlignmentSides(placement, rects, rtl);
              overflows.push(overflow[sides[0]], overflow[sides[1]]);
            }
            overflowsData = [
              ...overflowsData,
              {
                placement,
                overflows,
              },
            ];

            // One or more sides is overflowing.
            if (!overflows.every((side) => side <= 0)) {
              var _middlewareData$flip2, _overflowsData$filter;
              const nextIndex =
                (((_middlewareData$flip2 = middlewareData.flip) == null
                  ? void 0
                  : _middlewareData$flip2.index) || 0) + 1;
              const nextPlacement = placements[nextIndex];
              if (nextPlacement) {
                const ignoreCrossAxisOverflow =
                  checkCrossAxis === "alignment"
                    ? initialSideAxis !== getSideAxis(nextPlacement)
                    : false;
                if (
                  !ignoreCrossAxisOverflow ||
                  // We leave the current main axis only if every placement on that axis
                  // overflows the main axis.
                  overflowsData.every(
                    (d) =>
                      d.overflows[0] > 0 &&
                      getSideAxis(d.placement) === initialSideAxis,
                  )
                ) {
                  // Try next placement and re-run the lifecycle.
                  return {
                    data: {
                      index: nextIndex,
                      overflows: overflowsData,
                    },
                    reset: {
                      placement: nextPlacement,
                    },
                  };
                }
              }

              // First, find the candidates that fit on the mainAxis side of overflow,
              // then find the placement that fits the best on the main crossAxis side.
              let resetPlacement =
                (_overflowsData$filter = overflowsData
                  .filter((d) => d.overflows[0] <= 0)
                  .sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null
                  ? void 0
                  : _overflowsData$filter.placement;

              // Otherwise fallback.
              if (!resetPlacement) {
                switch (fallbackStrategy) {
                  case "bestFit": {
                    var _overflowsData$filter2;
                    const placement =
                      (_overflowsData$filter2 = overflowsData
                        .filter((d) => {
                          if (hasFallbackAxisSideDirection) {
                            const currentSideAxis = getSideAxis(d.placement);
                            return (
                              currentSideAxis === initialSideAxis ||
                              // Create a bias to the `y` side axis due to horizontal
                              // reading directions favoring greater width.
                              currentSideAxis === "y"
                            );
                          }
                          return true;
                        })
                        .map((d) => [
                          d.placement,
                          d.overflows
                            .filter((overflow) => overflow > 0)
                            .reduce((acc, overflow) => acc + overflow, 0),
                        ])
                        .sort((a, b) => a[1] - b[1])[0]) == null
                        ? void 0
                        : _overflowsData$filter2[0];
                    if (placement) {
                      resetPlacement = placement;
                    }
                    break;
                  }
                  case "initialPlacement":
                    resetPlacement = initialPlacement;
                    break;
                }
              }
              if (placement !== resetPlacement) {
                return {
                  reset: {
                    placement: resetPlacement,
                  },
                };
              }
            }
            return {};
          },
        };
      };

      function getSideOffsets(overflow, rect) {
        return {
          top: overflow.top - rect.height,
          right: overflow.right - rect.width,
          bottom: overflow.bottom - rect.height,
          left: overflow.left - rect.width,
        };
      }
      function isAnySideFullyClipped(overflow) {
        return sides.some((side) => overflow[side] >= 0);
      }

      const hide$2 = function (options) {
        if (options === void 0) {
          options = {};
        }
        return {
          name: "hide",
          options,
          async fn(state) {
            const { rects } = state;
            const { strategy = "referenceHidden", ...detectOverflowOptions } =
              evaluate(options, state);
            switch (strategy) {
              case "referenceHidden": {
                const overflow = await detectOverflow(state, {
                  ...detectOverflowOptions,
                  elementContext: "reference",
                });
                const offsets = getSideOffsets(overflow, rects.reference);
                return {
                  data: {
                    referenceHiddenOffsets: offsets,
                    referenceHidden: isAnySideFullyClipped(offsets),
                  },
                };
              }
              case "escaped": {
                const overflow = await detectOverflow(state, {
                  ...detectOverflowOptions,
                  altBoundary: true,
                });
                const offsets = getSideOffsets(overflow, rects.floating);
                return {
                  data: {
                    escapedOffsets: offsets,
                    escaped: isAnySideFullyClipped(offsets),
                  },
                };
              }
              default: {
                return {};
              }
            }
          },
        };
      };

      const originSides = /*#__PURE__*/ new Set(["left", "top"]);

      // For type backwards-compatibility, the `OffsetOptions` type was also
      // Derivable.

      async function convertValueToCoords(state, options) {
        const { placement, platform, elements } = state;
        const rtl = await (platform.isRTL == null
          ? void 0
          : platform.isRTL(elements.floating));
        const side = getSide(placement);
        const alignment = getAlignment(placement);
        const isVertical = getSideAxis(placement) === "y";
        const mainAxisMulti = originSides.has(side) ? -1 : 1;
        const crossAxisMulti = rtl && isVertical ? -1 : 1;
        const rawValue = evaluate(options, state);

        // eslint-disable-next-line prefer-const
        let { mainAxis, crossAxis, alignmentAxis } =
          typeof rawValue === "number"
            ? {
                mainAxis: rawValue,
                crossAxis: 0,
                alignmentAxis: null,
              }
            : {
                mainAxis: rawValue.mainAxis || 0,
                crossAxis: rawValue.crossAxis || 0,
                alignmentAxis: rawValue.alignmentAxis,
              };
        if (alignment && typeof alignmentAxis === "number") {
          crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
        }
        return isVertical
          ? {
              x: crossAxis * crossAxisMulti,
              y: mainAxis * mainAxisMulti,
            }
          : {
              x: mainAxis * mainAxisMulti,
              y: crossAxis * crossAxisMulti,
            };
      }

      const offset$2 = function (options) {
        if (options === void 0) {
          options = 0;
        }
        return {
          name: "offset",
          options,
          async fn(state) {
            var _middlewareData$offse, _middlewareData$arrow;
            const { x, y, placement, middlewareData } = state;
            const diffCoords = await convertValueToCoords(state, options);

            // If the placement is the same and the arrow caused an alignment offset
            // then we don't need to change the positioning coordinates.
            if (
              placement ===
                ((_middlewareData$offse = middlewareData.offset) == null
                  ? void 0
                  : _middlewareData$offse.placement) &&
              (_middlewareData$arrow = middlewareData.arrow) != null &&
              _middlewareData$arrow.alignmentOffset
            ) {
              return {};
            }
            return {
              x: x + diffCoords.x,
              y: y + diffCoords.y,
              data: {
                ...diffCoords,
                placement,
              },
            };
          },
        };
      };

      const shift$2 = function (options) {
        if (options === void 0) {
          options = {};
        }
        return {
          name: "shift",
          options,
          async fn(state) {
            const { x, y, placement } = state;
            const {
              mainAxis: checkMainAxis = true,
              crossAxis: checkCrossAxis = false,
              limiter = {
                fn: (_ref) => {
                  let { x, y } = _ref;
                  return {
                    x,
                    y,
                  };
                },
              },
              ...detectOverflowOptions
            } = evaluate(options, state);
            const coords = {
              x,
              y,
            };
            const overflow = await detectOverflow(state, detectOverflowOptions);
            const crossAxis = getSideAxis(getSide(placement));
            const mainAxis = getOppositeAxis(crossAxis);
            let mainAxisCoord = coords[mainAxis];
            let crossAxisCoord = coords[crossAxis];
            if (checkMainAxis) {
              const minSide = mainAxis === "y" ? "top" : "left";
              const maxSide = mainAxis === "y" ? "bottom" : "right";
              const min = mainAxisCoord + overflow[minSide];
              const max = mainAxisCoord - overflow[maxSide];
              mainAxisCoord = clamp$1(min, mainAxisCoord, max);
            }
            if (checkCrossAxis) {
              const minSide = crossAxis === "y" ? "top" : "left";
              const maxSide = crossAxis === "y" ? "bottom" : "right";
              const min = crossAxisCoord + overflow[minSide];
              const max = crossAxisCoord - overflow[maxSide];
              crossAxisCoord = clamp$1(min, crossAxisCoord, max);
            }
            const limitedCoords = limiter.fn({
              ...state,
              [mainAxis]: mainAxisCoord,
              [crossAxis]: crossAxisCoord,
            });
            return {
              ...limitedCoords,
              data: {
                x: limitedCoords.x - x,
                y: limitedCoords.y - y,
                enabled: {
                  [mainAxis]: checkMainAxis,
                  [crossAxis]: checkCrossAxis,
                },
              },
            };
          },
        };
      };

      const limitShift$2 = function (options) {
        if (options === void 0) {
          options = {};
        }
        return {
          options,
          fn(state) {
            const { x, y, placement, rects, middlewareData } = state;
            const {
              offset = 0,
              mainAxis: checkMainAxis = true,
              crossAxis: checkCrossAxis = true,
            } = evaluate(options, state);
            const coords = {
              x,
              y,
            };
            const crossAxis = getSideAxis(placement);
            const mainAxis = getOppositeAxis(crossAxis);
            let mainAxisCoord = coords[mainAxis];
            let crossAxisCoord = coords[crossAxis];
            const rawOffset = evaluate(offset, state);
            const computedOffset =
              typeof rawOffset === "number"
                ? {
                    mainAxis: rawOffset,
                    crossAxis: 0,
                  }
                : {
                    mainAxis: 0,
                    crossAxis: 0,
                    ...rawOffset,
                  };
            if (checkMainAxis) {
              const len = mainAxis === "y" ? "height" : "width";
              const limitMin =
                rects.reference[mainAxis] -
                rects.floating[len] +
                computedOffset.mainAxis;
              const limitMax =
                rects.reference[mainAxis] +
                rects.reference[len] -
                computedOffset.mainAxis;
              if (mainAxisCoord < limitMin) {
                mainAxisCoord = limitMin;
              } else if (mainAxisCoord > limitMax) {
                mainAxisCoord = limitMax;
              }
            }
            if (checkCrossAxis) {
              var _middlewareData$offse, _middlewareData$offse2;
              const len = mainAxis === "y" ? "width" : "height";
              const isOriginSide = originSides.has(getSide(placement));
              const limitMin =
                rects.reference[crossAxis] -
                rects.floating[len] +
                (isOriginSide
                  ? ((_middlewareData$offse = middlewareData.offset) == null
                      ? void 0
                      : _middlewareData$offse[crossAxis]) || 0
                  : 0) +
                (isOriginSide ? 0 : computedOffset.crossAxis);
              const limitMax =
                rects.reference[crossAxis] +
                rects.reference[len] +
                (isOriginSide
                  ? 0
                  : ((_middlewareData$offse2 = middlewareData.offset) == null
                      ? void 0
                      : _middlewareData$offse2[crossAxis]) || 0) -
                (isOriginSide ? computedOffset.crossAxis : 0);
              if (crossAxisCoord < limitMin) {
                crossAxisCoord = limitMin;
              } else if (crossAxisCoord > limitMax) {
                crossAxisCoord = limitMax;
              }
            }
            return {
              [mainAxis]: mainAxisCoord,
              [crossAxis]: crossAxisCoord,
            };
          },
        };
      };

      const size$2 = function (options) {
        if (options === void 0) {
          options = {};
        }
        return {
          name: "size",
          options,
          async fn(state) {
            var _state$middlewareData, _state$middlewareData2;
            const { placement, rects, platform, elements } = state;
            const { apply = () => {}, ...detectOverflowOptions } = evaluate(
              options,
              state,
            );
            const overflow = await detectOverflow(state, detectOverflowOptions);
            const side = getSide(placement);
            const alignment = getAlignment(placement);
            const isYAxis = getSideAxis(placement) === "y";
            const { width, height } = rects.floating;
            let heightSide;
            let widthSide;
            if (side === "top" || side === "bottom") {
              heightSide = side;
              widthSide =
                alignment ===
                ((await (platform.isRTL == null
                  ? void 0
                  : platform.isRTL(elements.floating)))
                  ? "start"
                  : "end")
                  ? "left"
                  : "right";
            } else {
              widthSide = side;
              heightSide = alignment === "end" ? "top" : "bottom";
            }
            const maximumClippingHeight =
              height - overflow.top - overflow.bottom;
            const maximumClippingWidth = width - overflow.left - overflow.right;
            const overflowAvailableHeight = min(
              height - overflow[heightSide],
              maximumClippingHeight,
            );
            const overflowAvailableWidth = min(
              width - overflow[widthSide],
              maximumClippingWidth,
            );
            const noShift = !state.middlewareData.shift;
            let availableHeight = overflowAvailableHeight;
            let availableWidth = overflowAvailableWidth;
            if (
              (_state$middlewareData = state.middlewareData.shift) != null &&
              _state$middlewareData.enabled.x
            ) {
              availableWidth = maximumClippingWidth;
            }
            if (
              (_state$middlewareData2 = state.middlewareData.shift) != null &&
              _state$middlewareData2.enabled.y
            ) {
              availableHeight = maximumClippingHeight;
            }
            if (noShift && !alignment) {
              const xMin = max(overflow.left, 0);
              const xMax = max(overflow.right, 0);
              const yMin = max(overflow.top, 0);
              const yMax = max(overflow.bottom, 0);
              if (isYAxis) {
                availableWidth =
                  width -
                  2 *
                    (xMin !== 0 || xMax !== 0
                      ? xMin + xMax
                      : max(overflow.left, overflow.right));
              } else {
                availableHeight =
                  height -
                  2 *
                    (yMin !== 0 || yMax !== 0
                      ? yMin + yMax
                      : max(overflow.top, overflow.bottom));
              }
            }
            await apply({
              ...state,
              availableWidth,
              availableHeight,
            });
            const nextDimensions = await platform.getDimensions(
              elements.floating,
            );
            if (
              width !== nextDimensions.width ||
              height !== nextDimensions.height
            ) {
              return {
                reset: {
                  rects: true,
                },
              };
            }
            return {};
          },
        };
      };

      function hasWindow() {
        return typeof window !== "undefined";
      }
      function getNodeName(node) {
        if (isNode(node)) {
          return (node.nodeName || "").toLowerCase();
        }
        // Mocked nodes in testing environments may not be instances of Node. By
        // returning `#document` an infinite loop won't occur.
        // https://github.com/floating-ui/floating-ui/issues/2317
        return "#document";
      }
      function getWindow(node) {
        var _node$ownerDocument;
        return (
          (node == null || (_node$ownerDocument = node.ownerDocument) == null
            ? void 0
            : _node$ownerDocument.defaultView) || window
        );
      }
      function getDocumentElement(node) {
        var _ref;
        return (_ref =
          (isNode(node) ? node.ownerDocument : node.document) ||
          window.document) == null
          ? void 0
          : _ref.documentElement;
      }
      function isNode(value) {
        if (!hasWindow()) {
          return false;
        }
        return value instanceof Node || value instanceof getWindow(value).Node;
      }
      function isElement(value) {
        if (!hasWindow()) {
          return false;
        }
        return (
          value instanceof Element || value instanceof getWindow(value).Element
        );
      }
      function isHTMLElement$1(value) {
        if (!hasWindow()) {
          return false;
        }
        return (
          value instanceof HTMLElement ||
          value instanceof getWindow(value).HTMLElement
        );
      }
      function isShadowRoot(value) {
        if (!hasWindow() || typeof ShadowRoot === "undefined") {
          return false;
        }
        return (
          value instanceof ShadowRoot ||
          value instanceof getWindow(value).ShadowRoot
        );
      }
      const invalidOverflowDisplayValues = /*#__PURE__*/ new Set([
        "inline",
        "contents",
      ]);
      function isOverflowElement(element) {
        const { overflow, overflowX, overflowY, display } =
          getComputedStyle$2(element);
        return (
          /auto|scroll|overlay|hidden|clip/.test(
            overflow + overflowY + overflowX,
          ) && !invalidOverflowDisplayValues.has(display)
        );
      }
      const tableElements = /*#__PURE__*/ new Set(["table", "td", "th"]);
      function isTableElement(element) {
        return tableElements.has(getNodeName(element));
      }
      const topLayerSelectors = [":popover-open", ":modal"];
      function isTopLayer(element) {
        return topLayerSelectors.some((selector) => {
          try {
            return element.matches(selector);
          } catch (_e) {
            return false;
          }
        });
      }
      const transformProperties = [
        "transform",
        "translate",
        "scale",
        "rotate",
        "perspective",
      ];
      const willChangeValues = [
        "transform",
        "translate",
        "scale",
        "rotate",
        "perspective",
        "filter",
      ];
      const containValues = ["paint", "layout", "strict", "content"];
      function isContainingBlock(elementOrCss) {
        const webkit = isWebKit();
        const css = isElement(elementOrCss)
          ? getComputedStyle$2(elementOrCss)
          : elementOrCss;

        // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block
        // https://drafts.csswg.org/css-transforms-2/#individual-transforms
        return (
          transformProperties.some((value) =>
            css[value] ? css[value] !== "none" : false,
          ) ||
          (css.containerType ? css.containerType !== "normal" : false) ||
          (!webkit &&
            (css.backdropFilter ? css.backdropFilter !== "none" : false)) ||
          (!webkit && (css.filter ? css.filter !== "none" : false)) ||
          willChangeValues.some((value) =>
            (css.willChange || "").includes(value),
          ) ||
          containValues.some((value) => (css.contain || "").includes(value))
        );
      }
      function getContainingBlock(element) {
        let currentNode = getParentNode(element);
        while (
          isHTMLElement$1(currentNode) &&
          !isLastTraversableNode(currentNode)
        ) {
          if (isContainingBlock(currentNode)) {
            return currentNode;
          } else if (isTopLayer(currentNode)) {
            return null;
          }
          currentNode = getParentNode(currentNode);
        }
        return null;
      }
      function isWebKit() {
        if (typeof CSS === "undefined" || !CSS.supports) return false;
        return CSS.supports("-webkit-backdrop-filter", "none");
      }
      const lastTraversableNodeNames = /*#__PURE__*/ new Set([
        "html",
        "body",
        "#document",
      ]);
      function isLastTraversableNode(node) {
        return lastTraversableNodeNames.has(getNodeName(node));
      }
      function getComputedStyle$2(element) {
        return getWindow(element).getComputedStyle(element);
      }
      function getNodeScroll(element) {
        if (isElement(element)) {
          return {
            scrollLeft: element.scrollLeft,
            scrollTop: element.scrollTop,
          };
        }
        return {
          scrollLeft: element.scrollX,
          scrollTop: element.scrollY,
        };
      }
      function getParentNode(node) {
        if (getNodeName(node) === "html") {
          return node;
        }
        const result =
          // Step into the shadow DOM of the parent of a slotted node.
          node.assignedSlot ||
          // DOM Element detected.
          node.parentNode ||
          // ShadowRoot detected.
          (isShadowRoot(node) && node.host) ||
          // Fallback.
          getDocumentElement(node);
        return isShadowRoot(result) ? result.host : result;
      }
      function getNearestOverflowAncestor(node) {
        const parentNode = getParentNode(node);
        if (isLastTraversableNode(parentNode)) {
          return node.ownerDocument ? node.ownerDocument.body : node.body;
        }
        if (isHTMLElement$1(parentNode) && isOverflowElement(parentNode)) {
          return parentNode;
        }
        return getNearestOverflowAncestor(parentNode);
      }
      function getOverflowAncestors(node, list, traverseIframes) {
        var _node$ownerDocument2;
        if (list === void 0) {
          list = [];
        }
        if (traverseIframes === void 0) {
          traverseIframes = true;
        }
        const scrollableAncestor = getNearestOverflowAncestor(node);
        const isBody =
          scrollableAncestor ===
          ((_node$ownerDocument2 = node.ownerDocument) == null
            ? void 0
            : _node$ownerDocument2.body);
        const win = getWindow(scrollableAncestor);
        if (isBody) {
          const frameElement = getFrameElement(win);
          return list.concat(
            win,
            win.visualViewport || [],
            isOverflowElement(scrollableAncestor) ? scrollableAncestor : [],
            frameElement && traverseIframes
              ? getOverflowAncestors(frameElement)
              : [],
          );
        }
        return list.concat(
          scrollableAncestor,
          getOverflowAncestors(scrollableAncestor, [], traverseIframes),
        );
      }
      function getFrameElement(win) {
        return win.parent && Object.getPrototypeOf(win.parent)
          ? win.frameElement
          : null;
      }

      function getCssDimensions(element) {
        const css = getComputedStyle$2(element);
        // In testing environments, the `width` and `height` properties are empty
        // strings for SVG elements, returning NaN. Fallback to `0` in this case.
        let width = parseFloat(css.width) || 0;
        let height = parseFloat(css.height) || 0;
        const hasOffset = isHTMLElement$1(element);
        const offsetWidth = hasOffset ? element.offsetWidth : width;
        const offsetHeight = hasOffset ? element.offsetHeight : height;
        const shouldFallback =
          round(width) !== offsetWidth || round(height) !== offsetHeight;
        if (shouldFallback) {
          width = offsetWidth;
          height = offsetHeight;
        }
        return {
          width,
          height,
          $: shouldFallback,
        };
      }

      function unwrapElement(element) {
        return !isElement(element) ? element.contextElement : element;
      }

      function getScale(element) {
        const domElement = unwrapElement(element);
        if (!isHTMLElement$1(domElement)) {
          return createCoords(1);
        }
        const rect = domElement.getBoundingClientRect();
        const { width, height, $ } = getCssDimensions(domElement);
        let x = ($ ? round(rect.width) : rect.width) / width;
        let y = ($ ? round(rect.height) : rect.height) / height;

        // 0, NaN, or Infinity should always fallback to 1.

        if (!x || !Number.isFinite(x)) {
          x = 1;
        }
        if (!y || !Number.isFinite(y)) {
          y = 1;
        }
        return {
          x,
          y,
        };
      }

      const noOffsets = /*#__PURE__*/ createCoords(0);
      function getVisualOffsets(element) {
        const win = getWindow(element);
        if (!isWebKit() || !win.visualViewport) {
          return noOffsets;
        }
        return {
          x: win.visualViewport.offsetLeft,
          y: win.visualViewport.offsetTop,
        };
      }
      function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
        if (isFixed === void 0) {
          isFixed = false;
        }
        if (
          !floatingOffsetParent ||
          (isFixed && floatingOffsetParent !== getWindow(element))
        ) {
          return false;
        }
        return isFixed;
      }

      function getBoundingClientRect(
        element,
        includeScale,
        isFixedStrategy,
        offsetParent,
      ) {
        if (includeScale === void 0) {
          includeScale = false;
        }
        if (isFixedStrategy === void 0) {
          isFixedStrategy = false;
        }
        const clientRect = element.getBoundingClientRect();
        const domElement = unwrapElement(element);
        let scale = createCoords(1);
        if (includeScale) {
          if (offsetParent) {
            if (isElement(offsetParent)) {
              scale = getScale(offsetParent);
            }
          } else {
            scale = getScale(element);
          }
        }
        const visualOffsets = shouldAddVisualOffsets(
          domElement,
          isFixedStrategy,
          offsetParent,
        )
          ? getVisualOffsets(domElement)
          : createCoords(0);
        let x = (clientRect.left + visualOffsets.x) / scale.x;
        let y = (clientRect.top + visualOffsets.y) / scale.y;
        let width = clientRect.width / scale.x;
        let height = clientRect.height / scale.y;
        if (domElement) {
          const win = getWindow(domElement);
          const offsetWin =
            offsetParent && isElement(offsetParent)
              ? getWindow(offsetParent)
              : offsetParent;
          let currentWin = win;
          let currentIFrame = getFrameElement(currentWin);
          while (currentIFrame && offsetParent && offsetWin !== currentWin) {
            const iframeScale = getScale(currentIFrame);
            const iframeRect = currentIFrame.getBoundingClientRect();
            const css = getComputedStyle$2(currentIFrame);
            const left =
              iframeRect.left +
              (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) *
                iframeScale.x;
            const top =
              iframeRect.top +
              (currentIFrame.clientTop + parseFloat(css.paddingTop)) *
                iframeScale.y;
            x *= iframeScale.x;
            y *= iframeScale.y;
            width *= iframeScale.x;
            height *= iframeScale.y;
            x += left;
            y += top;
            currentWin = getWindow(currentIFrame);
            currentIFrame = getFrameElement(currentWin);
          }
        }
        return rectToClientRect({
          width,
          height,
          x,
          y,
        });
      }

      // If <html> has a CSS width greater than the viewport, then this will be
      // incorrect for RTL.
      function getWindowScrollBarX(element, rect) {
        const leftScroll = getNodeScroll(element).scrollLeft;
        if (!rect) {
          return (
            getBoundingClientRect(getDocumentElement(element)).left + leftScroll
          );
        }
        return rect.left + leftScroll;
      }

      function getHTMLOffset(documentElement, scroll, ignoreScrollbarX) {
        if (ignoreScrollbarX === void 0) {
          ignoreScrollbarX = false;
        }
        const htmlRect = documentElement.getBoundingClientRect();
        const x =
          htmlRect.left +
          scroll.scrollLeft -
          (ignoreScrollbarX
            ? 0
            : // RTL <body> scrollbar.
              getWindowScrollBarX(documentElement, htmlRect));
        const y = htmlRect.top + scroll.scrollTop;
        return {
          x,
          y,
        };
      }

      function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
        let { elements, rect, offsetParent, strategy } = _ref;
        const isFixed = strategy === "fixed";
        const documentElement = getDocumentElement(offsetParent);
        const topLayer = elements ? isTopLayer(elements.floating) : false;
        if (offsetParent === documentElement || (topLayer && isFixed)) {
          return rect;
        }
        let scroll = {
          scrollLeft: 0,
          scrollTop: 0,
        };
        let scale = createCoords(1);
        const offsets = createCoords(0);
        const isOffsetParentAnElement = isHTMLElement$1(offsetParent);
        if (isOffsetParentAnElement || (!isOffsetParentAnElement && !isFixed)) {
          if (
            getNodeName(offsetParent) !== "body" ||
            isOverflowElement(documentElement)
          ) {
            scroll = getNodeScroll(offsetParent);
          }
          if (isHTMLElement$1(offsetParent)) {
            const offsetRect = getBoundingClientRect(offsetParent);
            scale = getScale(offsetParent);
            offsets.x = offsetRect.x + offsetParent.clientLeft;
            offsets.y = offsetRect.y + offsetParent.clientTop;
          }
        }
        const htmlOffset =
          documentElement && !isOffsetParentAnElement && !isFixed
            ? getHTMLOffset(documentElement, scroll, true)
            : createCoords(0);
        return {
          width: rect.width * scale.x,
          height: rect.height * scale.y,
          x:
            rect.x * scale.x -
            scroll.scrollLeft * scale.x +
            offsets.x +
            htmlOffset.x,
          y:
            rect.y * scale.y -
            scroll.scrollTop * scale.y +
            offsets.y +
            htmlOffset.y,
        };
      }

      function getClientRects(element) {
        return Array.from(element.getClientRects());
      }

      // Gets the entire size of the scrollable document area, even extending outside
      // of the `<html>` and `<body>` rect bounds if horizontally scrollable.
      function getDocumentRect(element) {
        const html = getDocumentElement(element);
        const scroll = getNodeScroll(element);
        const body = element.ownerDocument.body;
        const width = max(
          html.scrollWidth,
          html.clientWidth,
          body.scrollWidth,
          body.clientWidth,
        );
        const height = max(
          html.scrollHeight,
          html.clientHeight,
          body.scrollHeight,
          body.clientHeight,
        );
        let x = -scroll.scrollLeft + getWindowScrollBarX(element);
        const y = -scroll.scrollTop;
        if (getComputedStyle$2(body).direction === "rtl") {
          x += max(html.clientWidth, body.clientWidth) - width;
        }
        return {
          width,
          height,
          x,
          y,
        };
      }

      function getViewportRect(element, strategy) {
        const win = getWindow(element);
        const html = getDocumentElement(element);
        const visualViewport = win.visualViewport;
        let width = html.clientWidth;
        let height = html.clientHeight;
        let x = 0;
        let y = 0;
        if (visualViewport) {
          width = visualViewport.width;
          height = visualViewport.height;
          const visualViewportBased = isWebKit();
          if (
            !visualViewportBased ||
            (visualViewportBased && strategy === "fixed")
          ) {
            x = visualViewport.offsetLeft;
            y = visualViewport.offsetTop;
          }
        }
        return {
          width,
          height,
          x,
          y,
        };
      }

      const absoluteOrFixed = /*#__PURE__*/ new Set(["absolute", "fixed"]);
      // Returns the inner client rect, subtracting scrollbars if present.
      function getInnerBoundingClientRect(element, strategy) {
        const clientRect = getBoundingClientRect(
          element,
          true,
          strategy === "fixed",
        );
        const top = clientRect.top + element.clientTop;
        const left = clientRect.left + element.clientLeft;
        const scale = isHTMLElement$1(element)
          ? getScale(element)
          : createCoords(1);
        const width = element.clientWidth * scale.x;
        const height = element.clientHeight * scale.y;
        const x = left * scale.x;
        const y = top * scale.y;
        return {
          width,
          height,
          x,
          y,
        };
      }
      function getClientRectFromClippingAncestor(
        element,
        clippingAncestor,
        strategy,
      ) {
        let rect;
        if (clippingAncestor === "viewport") {
          rect = getViewportRect(element, strategy);
        } else if (clippingAncestor === "document") {
          rect = getDocumentRect(getDocumentElement(element));
        } else if (isElement(clippingAncestor)) {
          rect = getInnerBoundingClientRect(clippingAncestor, strategy);
        } else {
          const visualOffsets = getVisualOffsets(element);
          rect = {
            x: clippingAncestor.x - visualOffsets.x,
            y: clippingAncestor.y - visualOffsets.y,
            width: clippingAncestor.width,
            height: clippingAncestor.height,
          };
        }
        return rectToClientRect(rect);
      }
      function hasFixedPositionAncestor(element, stopNode) {
        const parentNode = getParentNode(element);
        if (
          parentNode === stopNode ||
          !isElement(parentNode) ||
          isLastTraversableNode(parentNode)
        ) {
          return false;
        }
        return (
          getComputedStyle$2(parentNode).position === "fixed" ||
          hasFixedPositionAncestor(parentNode, stopNode)
        );
      }

      // A "clipping ancestor" is an `overflow` element with the characteristic of
      // clipping (or hiding) child elements. This returns all clipping ancestors
      // of the given element up the tree.
      function getClippingElementAncestors(element, cache) {
        const cachedResult = cache.get(element);
        if (cachedResult) {
          return cachedResult;
        }
        let result = getOverflowAncestors(element, [], false).filter(
          (el) => isElement(el) && getNodeName(el) !== "body",
        );
        let currentContainingBlockComputedStyle = null;
        const elementIsFixed = getComputedStyle$2(element).position === "fixed";
        let currentNode = elementIsFixed ? getParentNode(element) : element;

        // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block
        while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {
          const computedStyle = getComputedStyle$2(currentNode);
          const currentNodeIsContaining = isContainingBlock(currentNode);
          if (!currentNodeIsContaining && computedStyle.position === "fixed") {
            currentContainingBlockComputedStyle = null;
          }
          const shouldDropCurrentNode = elementIsFixed
            ? !currentNodeIsContaining && !currentContainingBlockComputedStyle
            : (!currentNodeIsContaining &&
                computedStyle.position === "static" &&
                !!currentContainingBlockComputedStyle &&
                absoluteOrFixed.has(
                  currentContainingBlockComputedStyle.position,
                )) ||
              (isOverflowElement(currentNode) &&
                !currentNodeIsContaining &&
                hasFixedPositionAncestor(element, currentNode));
          if (shouldDropCurrentNode) {
            // Drop non-containing blocks.
            result = result.filter((ancestor) => ancestor !== currentNode);
          } else {
            // Record last containing block for next iteration.
            currentContainingBlockComputedStyle = computedStyle;
          }
          currentNode = getParentNode(currentNode);
        }
        cache.set(element, result);
        return result;
      }

      // Gets the maximum area that the element is visible in due to any number of
      // clipping ancestors.
      function getClippingRect(_ref) {
        let { element, boundary, rootBoundary, strategy } = _ref;
        const elementClippingAncestors =
          boundary === "clippingAncestors"
            ? isTopLayer(element)
              ? []
              : getClippingElementAncestors(element, this._c)
            : [].concat(boundary);
        const clippingAncestors = [...elementClippingAncestors, rootBoundary];
        const firstClippingAncestor = clippingAncestors[0];
        const clippingRect = clippingAncestors.reduce(
          (accRect, clippingAncestor) => {
            const rect = getClientRectFromClippingAncestor(
              element,
              clippingAncestor,
              strategy,
            );
            accRect.top = max(rect.top, accRect.top);
            accRect.right = min(rect.right, accRect.right);
            accRect.bottom = min(rect.bottom, accRect.bottom);
            accRect.left = max(rect.left, accRect.left);
            return accRect;
          },
          getClientRectFromClippingAncestor(
            element,
            firstClippingAncestor,
            strategy,
          ),
        );
        return {
          width: clippingRect.right - clippingRect.left,
          height: clippingRect.bottom - clippingRect.top,
          x: clippingRect.left,
          y: clippingRect.top,
        };
      }

      function getDimensions(element) {
        const { width, height } = getCssDimensions(element);
        return {
          width,
          height,
        };
      }

      function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
        const isOffsetParentAnElement = isHTMLElement$1(offsetParent);
        const documentElement = getDocumentElement(offsetParent);
        const isFixed = strategy === "fixed";
        const rect = getBoundingClientRect(
          element,
          true,
          isFixed,
          offsetParent,
        );
        let scroll = {
          scrollLeft: 0,
          scrollTop: 0,
        };
        const offsets = createCoords(0);

        // If the <body> scrollbar appears on the left (e.g. RTL systems). Use
        // Firefox with layout.scrollbar.side = 3 in about:config to test this.
        function setLeftRTLScrollbarOffset() {
          offsets.x = getWindowScrollBarX(documentElement);
        }
        if (isOffsetParentAnElement || (!isOffsetParentAnElement && !isFixed)) {
          if (
            getNodeName(offsetParent) !== "body" ||
            isOverflowElement(documentElement)
          ) {
            scroll = getNodeScroll(offsetParent);
          }
          if (isOffsetParentAnElement) {
            const offsetRect = getBoundingClientRect(
              offsetParent,
              true,
              isFixed,
              offsetParent,
            );
            offsets.x = offsetRect.x + offsetParent.clientLeft;
            offsets.y = offsetRect.y + offsetParent.clientTop;
          } else if (documentElement) {
            setLeftRTLScrollbarOffset();
          }
        }
        if (isFixed && !isOffsetParentAnElement && documentElement) {
          setLeftRTLScrollbarOffset();
        }
        const htmlOffset =
          documentElement && !isOffsetParentAnElement && !isFixed
            ? getHTMLOffset(documentElement, scroll)
            : createCoords(0);
        const x = rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x;
        const y = rect.top + scroll.scrollTop - offsets.y - htmlOffset.y;
        return {
          x,
          y,
          width: rect.width,
          height: rect.height,
        };
      }

      function isStaticPositioned(element) {
        return getComputedStyle$2(element).position === "static";
      }

      function getTrueOffsetParent(element, polyfill) {
        if (
          !isHTMLElement$1(element) ||
          getComputedStyle$2(element).position === "fixed"
        ) {
          return null;
        }
        if (polyfill) {
          return polyfill(element);
        }
        let rawOffsetParent = element.offsetParent;

        // Firefox returns the <html> element as the offsetParent if it's non-static,
        // while Chrome and Safari return the <body> element. The <body> element must
        // be used to perform the correct calculations even if the <html> element is
        // non-static.
        if (getDocumentElement(element) === rawOffsetParent) {
          rawOffsetParent = rawOffsetParent.ownerDocument.body;
        }
        return rawOffsetParent;
      }

      // Gets the closest ancestor positioned element. Handles some edge cases,
      // such as table ancestors and cross browser bugs.
      function getOffsetParent(element, polyfill) {
        const win = getWindow(element);
        if (isTopLayer(element)) {
          return win;
        }
        if (!isHTMLElement$1(element)) {
          let svgOffsetParent = getParentNode(element);
          while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {
            if (
              isElement(svgOffsetParent) &&
              !isStaticPositioned(svgOffsetParent)
            ) {
              return svgOffsetParent;
            }
            svgOffsetParent = getParentNode(svgOffsetParent);
          }
          return win;
        }
        let offsetParent = getTrueOffsetParent(element, polyfill);
        while (
          offsetParent &&
          isTableElement(offsetParent) &&
          isStaticPositioned(offsetParent)
        ) {
          offsetParent = getTrueOffsetParent(offsetParent, polyfill);
        }
        if (
          offsetParent &&
          isLastTraversableNode(offsetParent) &&
          isStaticPositioned(offsetParent) &&
          !isContainingBlock(offsetParent)
        ) {
          return win;
        }
        return offsetParent || getContainingBlock(element) || win;
      }

      const getElementRects = async function (data) {
        const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
        const getDimensionsFn = this.getDimensions;
        const floatingDimensions = await getDimensionsFn(data.floating);
        return {
          reference: getRectRelativeToOffsetParent(
            data.reference,
            await getOffsetParentFn(data.floating),
            data.strategy,
          ),
          floating: {
            x: 0,
            y: 0,
            width: floatingDimensions.width,
            height: floatingDimensions.height,
          },
        };
      };

      function isRTL(element) {
        return getComputedStyle$2(element).direction === "rtl";
      }

      const platform = {
        convertOffsetParentRelativeRectToViewportRelativeRect,
        getDocumentElement,
        getClippingRect,
        getOffsetParent,
        getElementRects,
        getClientRects,
        getDimensions,
        getScale,
        isElement,
        isRTL,
      };

      function rectsAreEqual(a, b) {
        return (
          a.x === b.x &&
          a.y === b.y &&
          a.width === b.width &&
          a.height === b.height
        );
      }

      // https://samthor.au/2021/observing-dom/
      function observeMove(element, onMove) {
        let io = null;
        let timeoutId;
        const root = getDocumentElement(element);
        function cleanup() {
          var _io;
          clearTimeout(timeoutId);
          (_io = io) == null || _io.disconnect();
          io = null;
        }
        function refresh(skip, threshold) {
          if (skip === void 0) {
            skip = false;
          }
          if (threshold === void 0) {
            threshold = 1;
          }
          cleanup();
          const elementRectForRootMargin = element.getBoundingClientRect();
          const { left, top, width, height } = elementRectForRootMargin;
          if (!skip) {
            onMove();
          }
          if (!width || !height) {
            return;
          }
          const insetTop = floor(top);
          const insetRight = floor(root.clientWidth - (left + width));
          const insetBottom = floor(root.clientHeight - (top + height));
          const insetLeft = floor(left);
          const rootMargin =
            -insetTop +
            "px " +
            -insetRight +
            "px " +
            -insetBottom +
            "px " +
            -insetLeft +
            "px";
          const options = {
            rootMargin,
            threshold: max(0, min(1, threshold)) || 1,
          };
          let isFirstUpdate = true;
          function handleObserve(entries) {
            const ratio = entries[0].intersectionRatio;
            if (ratio !== threshold) {
              if (!isFirstUpdate) {
                return refresh();
              }
              if (!ratio) {
                // If the reference is clipped, the ratio is 0. Throttle the refresh
                // to prevent an infinite loop of updates.
                timeoutId = setTimeout(() => {
                  refresh(false, 1e-7);
                }, 1000);
              } else {
                refresh(false, ratio);
              }
            }
            if (
              ratio === 1 &&
              !rectsAreEqual(
                elementRectForRootMargin,
                element.getBoundingClientRect(),
              )
            ) {
              // It's possible that even though the ratio is reported as 1, the
              // element is not actually fully within the IntersectionObserver's root
              // area anymore. This can happen under performance constraints. This may
              // be a bug in the browser's IntersectionObserver implementation. To
              // work around this, we compare the element's bounding rect now with
              // what it was at the time we created the IntersectionObserver. If they
              // are not equal then the element moved, so we refresh.
              refresh();
            }
            isFirstUpdate = false;
          }

          // Older browsers don't support a `document` as the root and will throw an
          // error.
          try {
            io = new IntersectionObserver(handleObserve, {
              ...options,
              // Handle <iframe>s
              root: root.ownerDocument,
            });
          } catch (_e) {
            io = new IntersectionObserver(handleObserve, options);
          }
          io.observe(element);
        }
        refresh(true);
        return cleanup;
      }

      function autoUpdate(reference, floating, update, options) {
        if (options === void 0) {
          options = {};
        }
        const {
          ancestorScroll = true,
          ancestorResize = true,
          elementResize = typeof ResizeObserver === "function",
          layoutShift = typeof IntersectionObserver === "function",
          animationFrame = false,
        } = options;
        const referenceEl = unwrapElement(reference);
        const ancestors =
          ancestorScroll || ancestorResize
            ? [
                ...(referenceEl ? getOverflowAncestors(referenceEl) : []),
                ...getOverflowAncestors(floating),
              ]
            : [];
        ancestors.forEach((ancestor) => {
          ancestorScroll &&
            ancestor.addEventListener("scroll", update, {
              passive: true,
            });
          ancestorResize && ancestor.addEventListener("resize", update);
        });
        const cleanupIo =
          referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
        let reobserveFrame = -1;
        let resizeObserver = null;
        if (elementResize) {
          resizeObserver = new ResizeObserver((_ref) => {
            let [firstEntry] = _ref;
            if (
              firstEntry &&
              firstEntry.target === referenceEl &&
              resizeObserver
            ) {
              // Prevent update loops when using the `size` middleware.
              // https://github.com/floating-ui/floating-ui/issues/1740
              resizeObserver.unobserve(floating);
              cancelAnimationFrame(reobserveFrame);
              reobserveFrame = requestAnimationFrame(() => {
                var _resizeObserver;
                (_resizeObserver = resizeObserver) == null ||
                  _resizeObserver.observe(floating);
              });
            }
            update();
          });
          if (referenceEl && !animationFrame) {
            resizeObserver.observe(referenceEl);
          }
          resizeObserver.observe(floating);
        }
        let frameId;
        let prevRefRect = animationFrame
          ? getBoundingClientRect(reference)
          : null;
        if (animationFrame) {
          frameLoop();
        }
        function frameLoop() {
          const nextRefRect = getBoundingClientRect(reference);
          if (prevRefRect && !rectsAreEqual(prevRefRect, nextRefRect)) {
            update();
          }
          prevRefRect = nextRefRect;
          frameId = requestAnimationFrame(frameLoop);
        }
        update();
        return () => {
          var _resizeObserver2;
          ancestors.forEach((ancestor) => {
            ancestorScroll && ancestor.removeEventListener("scroll", update);
            ancestorResize && ancestor.removeEventListener("resize", update);
          });
          cleanupIo == null || cleanupIo();
          (_resizeObserver2 = resizeObserver) == null ||
            _resizeObserver2.disconnect();
          resizeObserver = null;
          if (animationFrame) {
            cancelAnimationFrame(frameId);
          }
        };
      }

      const offset$1 = offset$2;

      const shift$1 = shift$2;

      const flip$1 = flip$2;

      const size$1 = size$2;

      const hide$1 = hide$2;

      const arrow$2 = arrow$3;

      const limitShift$1 = limitShift$2;

      const computePosition = (reference, floating, options) => {
        // This caches the expensive `getClippingElementAncestors` function so that
        // multiple lifecycle resets re-use the same result. It only lives for a
        // single call. If other functions become expensive, we can add them as well.
        const cache = new Map();
        const mergedOptions = {
          platform,
          ...options,
        };
        const platformWithCache = {
          ...mergedOptions.platform,
          _c: cache,
        };
        return computePosition$1(reference, floating, {
          ...mergedOptions,
          platform: platformWithCache,
        });
      };

      var isClient = typeof document !== "undefined";

      var noop$2 = function noop() {};
      var index = isClient ? reactExports.useLayoutEffect : noop$2;

      // Fork of `fast-deep-equal` that only does the comparisons we need and compares
      // functions
      function deepEqual(a, b) {
        if (a === b) {
          return true;
        }
        if (typeof a !== typeof b) {
          return false;
        }
        if (typeof a === "function" && a.toString() === b.toString()) {
          return true;
        }
        let length;
        let i;
        let keys;
        if (a && b && typeof a === "object") {
          if (Array.isArray(a)) {
            length = a.length;
            if (length !== b.length) return false;
            for (i = length; i-- !== 0; ) {
              if (!deepEqual(a[i], b[i])) {
                return false;
              }
            }
            return true;
          }
          keys = Object.keys(a);
          length = keys.length;
          if (length !== Object.keys(b).length) {
            return false;
          }
          for (i = length; i-- !== 0; ) {
            if (!{}.hasOwnProperty.call(b, keys[i])) {
              return false;
            }
          }
          for (i = length; i-- !== 0; ) {
            const key = keys[i];
            if (key === "_owner" && a.$$typeof) {
              continue;
            }
            if (!deepEqual(a[key], b[key])) {
              return false;
            }
          }
          return true;
        }
        return a !== a && b !== b;
      }

      function getDPR(element) {
        if (typeof window === "undefined") {
          return 1;
        }
        const win = element.ownerDocument.defaultView || window;
        return win.devicePixelRatio || 1;
      }

      function roundByDPR(element, value) {
        const dpr = getDPR(element);
        return Math.round(value * dpr) / dpr;
      }

      function useLatestRef(value) {
        const ref = reactExports.useRef(value);
        index(() => {
          ref.current = value;
        });
        return ref;
      }

      function useFloating(options) {
        if (options === void 0) {
          options = {};
        }
        const {
          placement = "bottom",
          strategy = "absolute",
          middleware = [],
          platform,
          elements: {
            reference: externalReference,
            floating: externalFloating,
          } = {},
          transform = true,
          whileElementsMounted,
          open,
        } = options;
        const [data, setData] = reactExports.useState({
          x: 0,
          y: 0,
          strategy,
          placement,
          middlewareData: {},
          isPositioned: false,
        });
        const [latestMiddleware, setLatestMiddleware] =
          reactExports.useState(middleware);
        if (!deepEqual(latestMiddleware, middleware)) {
          setLatestMiddleware(middleware);
        }
        const [_reference, _setReference] = reactExports.useState(null);
        const [_floating, _setFloating] = reactExports.useState(null);
        const setReference = reactExports.useCallback((node) => {
          if (node !== referenceRef.current) {
            referenceRef.current = node;
            _setReference(node);
          }
        }, []);
        const setFloating = reactExports.useCallback((node) => {
          if (node !== floatingRef.current) {
            floatingRef.current = node;
            _setFloating(node);
          }
        }, []);
        const referenceEl = externalReference || _reference;
        const floatingEl = externalFloating || _floating;
        const referenceRef = reactExports.useRef(null);
        const floatingRef = reactExports.useRef(null);
        const dataRef = reactExports.useRef(data);
        const hasWhileElementsMounted = whileElementsMounted != null;
        const whileElementsMountedRef = useLatestRef(whileElementsMounted);
        const platformRef = useLatestRef(platform);
        const openRef = useLatestRef(open);
        const update = reactExports.useCallback(() => {
          if (!referenceRef.current || !floatingRef.current) {
            return;
          }
          const config = {
            placement,
            strategy,
            middleware: latestMiddleware,
          };
          if (platformRef.current) {
            config.platform = platformRef.current;
          }
          computePosition(
            referenceRef.current,
            floatingRef.current,
            config,
          ).then((data) => {
            const fullData = {
              ...data,
              // The floating element's position may be recomputed while it's closed
              // but still mounted (such as when transitioning out). To ensure
              // `isPositioned` will be `false` initially on the next open, avoid
              // setting it to `true` when `open === false` (must be specified).
              isPositioned: openRef.current !== false,
            };
            if (isMountedRef.current && !deepEqual(dataRef.current, fullData)) {
              dataRef.current = fullData;
              reactDomExports.flushSync(() => {
                setData(fullData);
              });
            }
          });
        }, [latestMiddleware, placement, strategy, platformRef, openRef]);
        index(() => {
          if (open === false && dataRef.current.isPositioned) {
            dataRef.current.isPositioned = false;
            setData((data) => ({
              ...data,
              isPositioned: false,
            }));
          }
        }, [open]);
        const isMountedRef = reactExports.useRef(false);
        index(() => {
          isMountedRef.current = true;
          return () => {
            isMountedRef.current = false;
          };
        }, []);
        index(() => {
          if (referenceEl) referenceRef.current = referenceEl;
          if (floatingEl) floatingRef.current = floatingEl;
          if (referenceEl && floatingEl) {
            if (whileElementsMountedRef.current) {
              return whileElementsMountedRef.current(
                referenceEl,
                floatingEl,
                update,
              );
            }
            update();
          }
        }, [
          referenceEl,
          floatingEl,
          update,
          whileElementsMountedRef,
          hasWhileElementsMounted,
        ]);
        const refs = reactExports.useMemo(
          () => ({
            reference: referenceRef,
            floating: floatingRef,
            setReference,
            setFloating,
          }),
          [setReference, setFloating],
        );
        const elements = reactExports.useMemo(
          () => ({
            reference: referenceEl,
            floating: floatingEl,
          }),
          [referenceEl, floatingEl],
        );
        const floatingStyles = reactExports.useMemo(() => {
          const initialStyles = {
            position: strategy,
            left: 0,
            top: 0,
          };
          if (!elements.floating) {
            return initialStyles;
          }
          const x = roundByDPR(elements.floating, data.x);
          const y = roundByDPR(elements.floating, data.y);
          if (transform) {
            return {
              ...initialStyles,
              transform: "translate(" + x + "px, " + y + "px)",
              ...(getDPR(elements.floating) >= 1.5 && {
                willChange: "transform",
              }),
            };
          }
          return {
            position: strategy,
            left: x,
            top: y,
          };
        }, [strategy, transform, elements.floating, data.x, data.y]);
        return reactExports.useMemo(
          () => ({
            ...data,
            update,
            refs,
            elements,
            floatingStyles,
          }),
          [data, update, refs, elements, floatingStyles],
        );
      }

      const arrow$1 = (options) => {
        function isRef(value) {
          return {}.hasOwnProperty.call(value, "current");
        }
        return {
          name: "arrow",
          options,
          fn(state) {
            const { element, padding } =
              typeof options === "function" ? options(state) : options;
            if (element && isRef(element)) {
              if (element.current != null) {
                return arrow$2({
                  element: element.current,
                  padding,
                }).fn(state);
              }
              return {};
            }
            if (element) {
              return arrow$2({
                element,
                padding,
              }).fn(state);
            }
            return {};
          },
        };
      };

      const offset = (options, deps) => ({
        ...offset$1(options),
        options: [options, deps],
      });

      const shift = (options, deps) => ({
        ...shift$1(options),
        options: [options, deps],
      });

      const limitShift = (options, deps) => ({
        ...limitShift$1(options),
        options: [options, deps],
      });

      const flip = (options, deps) => ({
        ...flip$1(options),
        options: [options, deps],
      });

      const size = (options, deps) => ({
        ...size$1(options),
        options: [options, deps],
      });

      const hide = (options, deps) => ({
        ...hide$1(options),
        options: [options, deps],
      });

      const arrow = (options, deps) => ({
        ...arrow$1(options),
        options: [options, deps],
      });

      // src/arrow.tsx
      var NAME = "Arrow";
      var Arrow$1 = reactExports.forwardRef((props, forwardedRef) => {
        const { children, width = 10, height = 5, ...arrowProps } = props;
        return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.svg, {
          ...arrowProps,
          ref: forwardedRef,
          width,
          height,
          viewBox: "0 0 30 10",
          preserveAspectRatio: "none",
          children: props.asChild
            ? children
            : /* @__PURE__ */ jsxRuntimeExports.jsx("polygon", {
                points: "0,0 30,0 15,10",
              }),
        });
      });
      Arrow$1.displayName = NAME;
      var Root = Arrow$1;

      // packages/react/use-size/src/use-size.tsx
      function useSize(element) {
        const [size, setSize] = reactExports.useState(void 0);
        useLayoutEffect2(() => {
          if (element) {
            setSize({
              width: element.offsetWidth,
              height: element.offsetHeight,
            });
            const resizeObserver = new ResizeObserver((entries) => {
              if (!Array.isArray(entries)) {
                return;
              }
              if (!entries.length) {
                return;
              }
              const entry = entries[0];
              let width;
              let height;
              if ("borderBoxSize" in entry) {
                const borderSizeEntry = entry["borderBoxSize"];
                const borderSize = Array.isArray(borderSizeEntry)
                  ? borderSizeEntry[0]
                  : borderSizeEntry;
                width = borderSize["inlineSize"];
                height = borderSize["blockSize"];
              } else {
                width = element.offsetWidth;
                height = element.offsetHeight;
              }
              setSize({ width, height });
            });
            resizeObserver.observe(element, { box: "border-box" });
            return () => resizeObserver.unobserve(element);
          } else {
            setSize(void 0);
          }
        }, [element]);
        return size;
      }

      var POPPER_NAME = "Popper";
      var [createPopperContext, createPopperScope] =
        createContextScope(POPPER_NAME);
      var [PopperProvider, usePopperContext] = createPopperContext(POPPER_NAME);
      var ANCHOR_NAME = "PopperAnchor";
      var PopperAnchor = reactExports.forwardRef((props, forwardedRef) => {
        const { __scopePopper, virtualRef, ...anchorProps } = props;
        const context = usePopperContext(ANCHOR_NAME, __scopePopper);
        const ref = reactExports.useRef(null);
        const composedRefs = useComposedRefs$1(forwardedRef, ref);
        reactExports.useEffect(() => {
          context.onAnchorChange(virtualRef?.current || ref.current);
        });
        return virtualRef
          ? null
          : /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.div, {
              ...anchorProps,
              ref: composedRefs,
            });
      });
      PopperAnchor.displayName = ANCHOR_NAME;
      var CONTENT_NAME$1 = "PopperContent";
      var [PopperContentProvider, useContentContext] =
        createPopperContext(CONTENT_NAME$1);
      var PopperContent = reactExports.forwardRef((props, forwardedRef) => {
        const {
          __scopePopper,
          side = "bottom",
          sideOffset = 0,
          align = "center",
          alignOffset = 0,
          arrowPadding = 0,
          avoidCollisions = true,
          collisionBoundary = [],
          collisionPadding: collisionPaddingProp = 0,
          sticky = "partial",
          hideWhenDetached = false,
          updatePositionStrategy = "optimized",
          onPlaced,
          ...contentProps
        } = props;
        const context = usePopperContext(CONTENT_NAME$1, __scopePopper);
        const [content, setContent] = reactExports.useState(null);
        const composedRefs = useComposedRefs$1(forwardedRef, (node) =>
          setContent(node),
        );
        const [arrow$1, setArrow] = reactExports.useState(null);
        const arrowSize = useSize(arrow$1);
        const arrowWidth = arrowSize?.width ?? 0;
        const arrowHeight = arrowSize?.height ?? 0;
        const desiredPlacement = side + (align !== "center" ? "-" + align : "");
        const collisionPadding =
          typeof collisionPaddingProp === "number"
            ? collisionPaddingProp
            : { top: 0, right: 0, bottom: 0, left: 0, ...collisionPaddingProp };
        const boundary = Array.isArray(collisionBoundary)
          ? collisionBoundary
          : [collisionBoundary];
        const hasExplicitBoundaries = boundary.length > 0;
        const detectOverflowOptions = {
          padding: collisionPadding,
          boundary: boundary.filter(isNotNull$2),
          // with `strategy: 'fixed'`, this is the only way to get it to respect boundaries
          altBoundary: hasExplicitBoundaries,
        };
        const {
          refs,
          floatingStyles,
          placement,
          isPositioned,
          middlewareData,
        } = useFloating({
          // default to `fixed` strategy so users don't have to pick and we also avoid focus scroll issues
          strategy: "fixed",
          placement: desiredPlacement,
          whileElementsMounted: (...args) => {
            const cleanup = autoUpdate(...args, {
              animationFrame: updatePositionStrategy === "always",
            });
            return cleanup;
          },
          elements: {
            reference: context.anchor,
          },
          middleware: [
            offset({
              mainAxis: sideOffset + arrowHeight,
              alignmentAxis: alignOffset,
            }),
            avoidCollisions &&
              shift({
                mainAxis: true,
                crossAxis: false,
                limiter: sticky === "partial" ? limitShift() : void 0,
                ...detectOverflowOptions,
              }),
            avoidCollisions && flip({ ...detectOverflowOptions }),
            size({
              ...detectOverflowOptions,
              apply: ({ elements, rects, availableWidth, availableHeight }) => {
                const { width: anchorWidth, height: anchorHeight } =
                  rects.reference;
                const contentStyle = elements.floating.style;
                contentStyle.setProperty(
                  "--radix-popper-available-width",
                  `${availableWidth}px`,
                );
                contentStyle.setProperty(
                  "--radix-popper-available-height",
                  `${availableHeight}px`,
                );
                contentStyle.setProperty(
                  "--radix-popper-anchor-width",
                  `${anchorWidth}px`,
                );
                contentStyle.setProperty(
                  "--radix-popper-anchor-height",
                  `${anchorHeight}px`,
                );
              },
            }),
            arrow$1 && arrow({ element: arrow$1, padding: arrowPadding }),
            transformOrigin({ arrowWidth, arrowHeight }),
            hideWhenDetached &&
              hide({ strategy: "referenceHidden", ...detectOverflowOptions }),
          ],
        });
        const [placedSide, placedAlign] =
          getSideAndAlignFromPlacement(placement);
        const handlePlaced = useCallbackRef(onPlaced);
        useLayoutEffect2(() => {
          if (isPositioned) {
            handlePlaced?.();
          }
        }, [isPositioned, handlePlaced]);
        const arrowX = middlewareData.arrow?.x;
        const arrowY = middlewareData.arrow?.y;
        const cannotCenterArrow = middlewareData.arrow?.centerOffset !== 0;
        const [contentZIndex, setContentZIndex] = reactExports.useState();
        useLayoutEffect2(() => {
          if (content)
            setContentZIndex(window.getComputedStyle(content).zIndex);
        }, [content]);
        return /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
          ref: refs.setFloating,
          "data-radix-popper-content-wrapper": "",
          style: {
            ...floatingStyles,
            transform: isPositioned
              ? floatingStyles.transform
              : "translate(0, -200%)",
            // keep off the page when measuring
            minWidth: "max-content",
            zIndex: contentZIndex,
            ["--radix-popper-transform-origin"]: [
              middlewareData.transformOrigin?.x,
              middlewareData.transformOrigin?.y,
            ].join(" "),
            // hide the content if using the hide middleware and should be hidden
            // set visibility to hidden and disable pointer events so the UI behaves
            // as if the PopperContent isn't there at all
            ...(middlewareData.hide?.referenceHidden && {
              visibility: "hidden",
              pointerEvents: "none",
            }),
          },
          dir: props.dir,
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            PopperContentProvider,
            {
              scope: __scopePopper,
              placedSide,
              onArrowChange: setArrow,
              arrowX,
              arrowY,
              shouldHideArrow: cannotCenterArrow,
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.div, {
                "data-side": placedSide,
                "data-align": placedAlign,
                ...contentProps,
                ref: composedRefs,
                style: {
                  ...contentProps.style,
                  // if the PopperContent hasn't been placed yet (not all measurements done)
                  // we prevent animations so that users's animation don't kick in too early referring wrong sides
                  animation: !isPositioned ? "none" : void 0,
                },
              }),
            },
          ),
        });
      });
      PopperContent.displayName = CONTENT_NAME$1;
      var ARROW_NAME$1 = "PopperArrow";
      var OPPOSITE_SIDE = {
        top: "bottom",
        right: "left",
        bottom: "top",
        left: "right",
      };
      var PopperArrow = reactExports.forwardRef(
        function PopperArrow2(props, forwardedRef) {
          const { __scopePopper, ...arrowProps } = props;
          const contentContext = useContentContext(ARROW_NAME$1, __scopePopper);
          const baseSide = OPPOSITE_SIDE[contentContext.placedSide];
          return (
            // we have to use an extra wrapper because `ResizeObserver` (used by `useSize`)
            // doesn't report size as we'd expect on SVG elements.
            // it reports their bounding box which is effectively the largest path inside the SVG.
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
              ref: contentContext.onArrowChange,
              style: {
                position: "absolute",
                left: contentContext.arrowX,
                top: contentContext.arrowY,
                [baseSide]: 0,
                transformOrigin: {
                  top: "",
                  right: "0 0",
                  bottom: "center 0",
                  left: "100% 0",
                }[contentContext.placedSide],
                transform: {
                  top: "translateY(100%)",
                  right: "translateY(50%) rotate(90deg) translateX(-50%)",
                  bottom: `rotate(180deg)`,
                  left: "translateY(50%) rotate(-90deg) translateX(50%)",
                }[contentContext.placedSide],
                visibility: contentContext.shouldHideArrow ? "hidden" : void 0,
              },
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(Root, {
                ...arrowProps,
                ref: forwardedRef,
                style: {
                  ...arrowProps.style,
                  // ensures the element can be measured correctly (mostly for if SVG)
                  display: "block",
                },
              }),
            })
          );
        },
      );
      PopperArrow.displayName = ARROW_NAME$1;
      function isNotNull$2(value) {
        return value !== null;
      }
      var transformOrigin = (options) => ({
        name: "transformOrigin",
        options,
        fn(data) {
          const { placement, rects, middlewareData } = data;
          const cannotCenterArrow = middlewareData.arrow?.centerOffset !== 0;
          const isArrowHidden = cannotCenterArrow;
          const arrowWidth = isArrowHidden ? 0 : options.arrowWidth;
          const arrowHeight = isArrowHidden ? 0 : options.arrowHeight;
          const [placedSide, placedAlign] =
            getSideAndAlignFromPlacement(placement);
          const noArrowAlign = { start: "0%", center: "50%", end: "100%" }[
            placedAlign
          ];
          const arrowXCenter = (middlewareData.arrow?.x ?? 0) + arrowWidth / 2;
          const arrowYCenter = (middlewareData.arrow?.y ?? 0) + arrowHeight / 2;
          let x = "";
          let y = "";
          if (placedSide === "bottom") {
            x = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;
            y = `${-arrowHeight}px`;
          } else if (placedSide === "top") {
            x = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;
            y = `${rects.floating.height + arrowHeight}px`;
          } else if (placedSide === "right") {
            x = `${-arrowHeight}px`;
            y = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;
          } else if (placedSide === "left") {
            x = `${rects.floating.width + arrowHeight}px`;
            y = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;
          }
          return { data: { x, y } };
        },
      });
      function getSideAndAlignFromPlacement(placement) {
        const [side, align = "center"] = placement.split("-");
        return [side, align];
      }
      var Anchor = PopperAnchor;
      var Content = PopperContent;
      var Arrow = PopperArrow;

      var [createTooltipContext] = createContextScope("Tooltip", [
        createPopperScope,
      ]);
      var usePopperScope = createPopperScope();
      var PROVIDER_NAME = "TooltipProvider";
      var DEFAULT_DELAY_DURATION = 700;
      var TOOLTIP_OPEN = "tooltip.open";
      var [TooltipProviderContextProvider, useTooltipProviderContext] =
        createTooltipContext(PROVIDER_NAME);
      var TooltipProvider$1 = (props) => {
        const {
          __scopeTooltip,
          delayDuration = DEFAULT_DELAY_DURATION,
          skipDelayDuration = 300,
          disableHoverableContent = false,
          children,
        } = props;
        const isOpenDelayedRef = reactExports.useRef(true);
        const isPointerInTransitRef = reactExports.useRef(false);
        const skipDelayTimerRef = reactExports.useRef(0);
        reactExports.useEffect(() => {
          const skipDelayTimer = skipDelayTimerRef.current;
          return () => window.clearTimeout(skipDelayTimer);
        }, []);
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          TooltipProviderContextProvider,
          {
            scope: __scopeTooltip,
            isOpenDelayedRef,
            delayDuration,
            onOpen: reactExports.useCallback(() => {
              window.clearTimeout(skipDelayTimerRef.current);
              isOpenDelayedRef.current = false;
            }, []),
            onClose: reactExports.useCallback(() => {
              window.clearTimeout(skipDelayTimerRef.current);
              skipDelayTimerRef.current = window.setTimeout(
                () => (isOpenDelayedRef.current = true),
                skipDelayDuration,
              );
            }, [skipDelayDuration]),
            isPointerInTransitRef,
            onPointerInTransitChange: reactExports.useCallback((inTransit) => {
              isPointerInTransitRef.current = inTransit;
            }, []),
            disableHoverableContent,
            children,
          },
        );
      };
      TooltipProvider$1.displayName = PROVIDER_NAME;
      var TOOLTIP_NAME = "Tooltip";
      var [TooltipContextProvider, useTooltipContext] =
        createTooltipContext(TOOLTIP_NAME);
      var TRIGGER_NAME = "TooltipTrigger";
      var TooltipTrigger = reactExports.forwardRef((props, forwardedRef) => {
        const { __scopeTooltip, ...triggerProps } = props;
        const context = useTooltipContext(TRIGGER_NAME, __scopeTooltip);
        const providerContext = useTooltipProviderContext(
          TRIGGER_NAME,
          __scopeTooltip,
        );
        const popperScope = usePopperScope(__scopeTooltip);
        const ref = reactExports.useRef(null);
        const composedRefs = useComposedRefs$1(
          forwardedRef,
          ref,
          context.onTriggerChange,
        );
        const isPointerDownRef = reactExports.useRef(false);
        const hasPointerMoveOpenedRef = reactExports.useRef(false);
        const handlePointerUp = reactExports.useCallback(
          () => (isPointerDownRef.current = false),
          [],
        );
        reactExports.useEffect(() => {
          return () =>
            document.removeEventListener("pointerup", handlePointerUp);
        }, [handlePointerUp]);
        return /* @__PURE__ */ jsxRuntimeExports.jsx(Anchor, {
          asChild: true,
          ...popperScope,
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.button, {
            "aria-describedby": context.open ? context.contentId : void 0,
            "data-state": context.stateAttribute,
            ...triggerProps,
            ref: composedRefs,
            onPointerMove: composeEventHandlers(
              props.onPointerMove,
              (event) => {
                if (event.pointerType === "touch") return;
                if (
                  !hasPointerMoveOpenedRef.current &&
                  !providerContext.isPointerInTransitRef.current
                ) {
                  context.onTriggerEnter();
                  hasPointerMoveOpenedRef.current = true;
                }
              },
            ),
            onPointerLeave: composeEventHandlers(props.onPointerLeave, () => {
              context.onTriggerLeave();
              hasPointerMoveOpenedRef.current = false;
            }),
            onPointerDown: composeEventHandlers(props.onPointerDown, () => {
              if (context.open) {
                context.onClose();
              }
              isPointerDownRef.current = true;
              document.addEventListener("pointerup", handlePointerUp, {
                once: true,
              });
            }),
            onFocus: composeEventHandlers(props.onFocus, () => {
              if (!isPointerDownRef.current) context.onOpen();
            }),
            onBlur: composeEventHandlers(props.onBlur, context.onClose),
            onClick: composeEventHandlers(props.onClick, context.onClose),
          }),
        });
      });
      TooltipTrigger.displayName = TRIGGER_NAME;
      var PORTAL_NAME = "TooltipPortal";
      var [PortalProvider, usePortalContext] = createTooltipContext(
        PORTAL_NAME,
        {
          forceMount: void 0,
        },
      );
      var CONTENT_NAME = "TooltipContent";
      var TooltipContent$1 = reactExports.forwardRef((props, forwardedRef) => {
        const portalContext = usePortalContext(
          CONTENT_NAME,
          props.__scopeTooltip,
        );
        const {
          forceMount = portalContext.forceMount,
          side = "top",
          ...contentProps
        } = props;
        const context = useTooltipContext(CONTENT_NAME, props.__scopeTooltip);
        return /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, {
          present: forceMount || context.open,
          children: context.disableHoverableContent
            ? /* @__PURE__ */ jsxRuntimeExports.jsx(TooltipContentImpl, {
                side,
                ...contentProps,
                ref: forwardedRef,
              })
            : /* @__PURE__ */ jsxRuntimeExports.jsx(TooltipContentHoverable, {
                side,
                ...contentProps,
                ref: forwardedRef,
              }),
        });
      });
      var TooltipContentHoverable = reactExports.forwardRef(
        (props, forwardedRef) => {
          const context = useTooltipContext(CONTENT_NAME, props.__scopeTooltip);
          const providerContext = useTooltipProviderContext(
            CONTENT_NAME,
            props.__scopeTooltip,
          );
          const ref = reactExports.useRef(null);
          const composedRefs = useComposedRefs$1(forwardedRef, ref);
          const [pointerGraceArea, setPointerGraceArea] =
            reactExports.useState(null);
          const { trigger, onClose } = context;
          const content = ref.current;
          const { onPointerInTransitChange } = providerContext;
          const handleRemoveGraceArea = reactExports.useCallback(() => {
            setPointerGraceArea(null);
            onPointerInTransitChange(false);
          }, [onPointerInTransitChange]);
          const handleCreateGraceArea = reactExports.useCallback(
            (event, hoverTarget) => {
              const currentTarget = event.currentTarget;
              const exitPoint = { x: event.clientX, y: event.clientY };
              const exitSide = getExitSideFromRect(
                exitPoint,
                currentTarget.getBoundingClientRect(),
              );
              const paddedExitPoints = getPaddedExitPoints(exitPoint, exitSide);
              const hoverTargetPoints = getPointsFromRect(
                hoverTarget.getBoundingClientRect(),
              );
              const graceArea = getHull([
                ...paddedExitPoints,
                ...hoverTargetPoints,
              ]);
              setPointerGraceArea(graceArea);
              onPointerInTransitChange(true);
            },
            [onPointerInTransitChange],
          );
          reactExports.useEffect(() => {
            return () => handleRemoveGraceArea();
          }, [handleRemoveGraceArea]);
          reactExports.useEffect(() => {
            if (trigger && content) {
              const handleTriggerLeave = (event) =>
                handleCreateGraceArea(event, content);
              const handleContentLeave = (event) =>
                handleCreateGraceArea(event, trigger);
              trigger.addEventListener("pointerleave", handleTriggerLeave);
              content.addEventListener("pointerleave", handleContentLeave);
              return () => {
                trigger.removeEventListener("pointerleave", handleTriggerLeave);
                content.removeEventListener("pointerleave", handleContentLeave);
              };
            }
          }, [trigger, content, handleCreateGraceArea, handleRemoveGraceArea]);
          reactExports.useEffect(() => {
            if (pointerGraceArea) {
              const handleTrackPointerGrace = (event) => {
                const target = event.target;
                const pointerPosition = { x: event.clientX, y: event.clientY };
                const hasEnteredTarget =
                  trigger?.contains(target) || content?.contains(target);
                const isPointerOutsideGraceArea = !isPointInPolygon(
                  pointerPosition,
                  pointerGraceArea,
                );
                if (hasEnteredTarget) {
                  handleRemoveGraceArea();
                } else if (isPointerOutsideGraceArea) {
                  handleRemoveGraceArea();
                  onClose();
                }
              };
              document.addEventListener("pointermove", handleTrackPointerGrace);
              return () =>
                document.removeEventListener(
                  "pointermove",
                  handleTrackPointerGrace,
                );
            }
          }, [
            trigger,
            content,
            pointerGraceArea,
            onClose,
            handleRemoveGraceArea,
          ]);
          return /* @__PURE__ */ jsxRuntimeExports.jsx(TooltipContentImpl, {
            ...props,
            ref: composedRefs,
          });
        },
      );
      var [
        VisuallyHiddenContentContextProvider,
        useVisuallyHiddenContentContext,
      ] = createTooltipContext(TOOLTIP_NAME, { isInside: false });
      var Slottable = createSlottable("TooltipContent");
      var TooltipContentImpl = reactExports.forwardRef(
        (props, forwardedRef) => {
          const {
            __scopeTooltip,
            children,
            "aria-label": ariaLabel,
            onEscapeKeyDown,
            onPointerDownOutside,
            ...contentProps
          } = props;
          const context = useTooltipContext(CONTENT_NAME, __scopeTooltip);
          const popperScope = usePopperScope(__scopeTooltip);
          const { onClose } = context;
          reactExports.useEffect(() => {
            document.addEventListener(TOOLTIP_OPEN, onClose);
            return () => document.removeEventListener(TOOLTIP_OPEN, onClose);
          }, [onClose]);
          reactExports.useEffect(() => {
            if (context.trigger) {
              const handleScroll = (event) => {
                const target = event.target;
                if (target?.contains(context.trigger)) onClose();
              };
              window.addEventListener("scroll", handleScroll, {
                capture: true,
              });
              return () =>
                window.removeEventListener("scroll", handleScroll, {
                  capture: true,
                });
            }
          }, [context.trigger, onClose]);
          return /* @__PURE__ */ jsxRuntimeExports.jsx(DismissableLayer, {
            asChild: true,
            disableOutsidePointerEvents: false,
            onEscapeKeyDown,
            onPointerDownOutside,
            onFocusOutside: (event) => event.preventDefault(),
            onDismiss: onClose,
            children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Content, {
              "data-state": context.stateAttribute,
              ...popperScope,
              ...contentProps,
              ref: forwardedRef,
              style: {
                ...contentProps.style,
                // re-namespace exposed content custom properties
                ...{
                  "--radix-tooltip-content-transform-origin":
                    "var(--radix-popper-transform-origin)",
                  "--radix-tooltip-content-available-width":
                    "var(--radix-popper-available-width)",
                  "--radix-tooltip-content-available-height":
                    "var(--radix-popper-available-height)",
                  "--radix-tooltip-trigger-width":
                    "var(--radix-popper-anchor-width)",
                  "--radix-tooltip-trigger-height":
                    "var(--radix-popper-anchor-height)",
                },
              },
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Slottable, { children }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  VisuallyHiddenContentContextProvider,
                  {
                    scope: __scopeTooltip,
                    isInside: true,
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx(Root$1, {
                      id: context.contentId,
                      role: "tooltip",
                      children: ariaLabel || children,
                    }),
                  },
                ),
              ],
            }),
          });
        },
      );
      TooltipContent$1.displayName = CONTENT_NAME;
      var ARROW_NAME = "TooltipArrow";
      var TooltipArrow = reactExports.forwardRef((props, forwardedRef) => {
        const { __scopeTooltip, ...arrowProps } = props;
        const popperScope = usePopperScope(__scopeTooltip);
        const visuallyHiddenContentContext = useVisuallyHiddenContentContext(
          ARROW_NAME,
          __scopeTooltip,
        );
        return visuallyHiddenContentContext.isInside
          ? null
          : /* @__PURE__ */ jsxRuntimeExports.jsx(Arrow, {
              ...popperScope,
              ...arrowProps,
              ref: forwardedRef,
            });
      });
      TooltipArrow.displayName = ARROW_NAME;
      function getExitSideFromRect(point, rect) {
        const top = Math.abs(rect.top - point.y);
        const bottom = Math.abs(rect.bottom - point.y);
        const right = Math.abs(rect.right - point.x);
        const left = Math.abs(rect.left - point.x);
        switch (Math.min(top, bottom, right, left)) {
          case left:
            return "left";
          case right:
            return "right";
          case top:
            return "top";
          case bottom:
            return "bottom";
          default:
            throw new Error("unreachable");
        }
      }
      function getPaddedExitPoints(exitPoint, exitSide, padding = 5) {
        const paddedExitPoints = [];
        switch (exitSide) {
          case "top":
            paddedExitPoints.push(
              { x: exitPoint.x - padding, y: exitPoint.y + padding },
              { x: exitPoint.x + padding, y: exitPoint.y + padding },
            );
            break;
          case "bottom":
            paddedExitPoints.push(
              { x: exitPoint.x - padding, y: exitPoint.y - padding },
              { x: exitPoint.x + padding, y: exitPoint.y - padding },
            );
            break;
          case "left":
            paddedExitPoints.push(
              { x: exitPoint.x + padding, y: exitPoint.y - padding },
              { x: exitPoint.x + padding, y: exitPoint.y + padding },
            );
            break;
          case "right":
            paddedExitPoints.push(
              { x: exitPoint.x - padding, y: exitPoint.y - padding },
              { x: exitPoint.x - padding, y: exitPoint.y + padding },
            );
            break;
        }
        return paddedExitPoints;
      }
      function getPointsFromRect(rect) {
        const { top, right, bottom, left } = rect;
        return [
          { x: left, y: top },
          { x: right, y: top },
          { x: right, y: bottom },
          { x: left, y: bottom },
        ];
      }
      function isPointInPolygon(point, polygon) {
        const { x, y } = point;
        let inside = false;
        for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
          const ii = polygon[i];
          const jj = polygon[j];
          const xi = ii.x;
          const yi = ii.y;
          const xj = jj.x;
          const yj = jj.y;
          const intersect =
            yi > y !== yj > y && x < ((xj - xi) * (y - yi)) / (yj - yi) + xi;
          if (intersect) inside = !inside;
        }
        return inside;
      }
      function getHull(points) {
        const newPoints = points.slice();
        newPoints.sort((a, b) => {
          if (a.x < b.x) return -1;
          else if (a.x > b.x) return 1;
          else if (a.y < b.y) return -1;
          else if (a.y > b.y) return 1;
          else return 0;
        });
        return getHullPresorted(newPoints);
      }
      function getHullPresorted(points) {
        if (points.length <= 1) return points.slice();
        const upperHull = [];
        for (let i = 0; i < points.length; i++) {
          const p = points[i];
          while (upperHull.length >= 2) {
            const q = upperHull[upperHull.length - 1];
            const r = upperHull[upperHull.length - 2];
            if ((q.x - r.x) * (p.y - r.y) >= (q.y - r.y) * (p.x - r.x))
              upperHull.pop();
            else break;
          }
          upperHull.push(p);
        }
        upperHull.pop();
        const lowerHull = [];
        for (let i = points.length - 1; i >= 0; i--) {
          const p = points[i];
          while (lowerHull.length >= 2) {
            const q = lowerHull[lowerHull.length - 1];
            const r = lowerHull[lowerHull.length - 2];
            if ((q.x - r.x) * (p.y - r.y) >= (q.y - r.y) * (p.x - r.x))
              lowerHull.pop();
            else break;
          }
          lowerHull.push(p);
        }
        lowerHull.pop();
        if (
          upperHull.length === 1 &&
          lowerHull.length === 1 &&
          upperHull[0].x === lowerHull[0].x &&
          upperHull[0].y === lowerHull[0].y
        ) {
          return upperHull;
        } else {
          return upperHull.concat(lowerHull);
        }
      }
      var Provider = TooltipProvider$1;
      var Content2 = TooltipContent$1;

      const TooltipProvider = Provider;
      const TooltipContent = reactExports.forwardRef(
        ({ className, sideOffset = 4, ...props }, ref) =>
          /* @__PURE__ */ jsxRuntimeExports.jsx(Content2, {
            ref,
            sideOffset,
            className: cn(
              "z-50 overflow-hidden rounded-md border bg-popover px-3 py-1.5 text-sm text-popover-foreground shadow-md animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
              className,
            ),
            ...props,
          }),
      );
      TooltipContent.displayName = Content2.displayName;

      // src/subscribable.ts
      var Subscribable = class {
        constructor() {
          this.listeners = /* @__PURE__ */ new Set();
          this.subscribe = this.subscribe.bind(this);
        }
        subscribe(listener) {
          this.listeners.add(listener);
          this.onSubscribe();
          return () => {
            this.listeners.delete(listener);
            this.onUnsubscribe();
          };
        }
        hasListeners() {
          return this.listeners.size > 0;
        }
        onSubscribe() {}
        onUnsubscribe() {}
      };

      var isServer = typeof window === "undefined" || "Deno" in globalThis;
      function noop$1() {}
      function functionalUpdate(updater, input) {
        return typeof updater === "function" ? updater(input) : updater;
      }
      function isValidTimeout(value) {
        return typeof value === "number" && value >= 0 && value !== Infinity;
      }
      function timeUntilStale(updatedAt, staleTime) {
        return Math.max(updatedAt + (staleTime || 0) - Date.now(), 0);
      }
      function resolveStaleTime(staleTime, query) {
        return typeof staleTime === "function" ? staleTime(query) : staleTime;
      }
      function resolveEnabled(enabled, query) {
        return typeof enabled === "function" ? enabled(query) : enabled;
      }
      function matchQuery(filters, query) {
        const {
          type = "all",
          exact,
          fetchStatus,
          predicate,
          queryKey,
          stale,
        } = filters;
        if (queryKey) {
          if (exact) {
            if (
              query.queryHash !== hashQueryKeyByOptions(queryKey, query.options)
            ) {
              return false;
            }
          } else if (!partialMatchKey(query.queryKey, queryKey)) {
            return false;
          }
        }
        if (type !== "all") {
          const isActive = query.isActive();
          if (type === "active" && !isActive) {
            return false;
          }
          if (type === "inactive" && isActive) {
            return false;
          }
        }
        if (typeof stale === "boolean" && query.isStale() !== stale) {
          return false;
        }
        if (fetchStatus && fetchStatus !== query.state.fetchStatus) {
          return false;
        }
        if (predicate && !predicate(query)) {
          return false;
        }
        return true;
      }
      function matchMutation(filters, mutation) {
        const { exact, status, predicate, mutationKey } = filters;
        if (mutationKey) {
          if (!mutation.options.mutationKey) {
            return false;
          }
          if (exact) {
            if (
              hashKey(mutation.options.mutationKey) !== hashKey(mutationKey)
            ) {
              return false;
            }
          } else if (
            !partialMatchKey(mutation.options.mutationKey, mutationKey)
          ) {
            return false;
          }
        }
        if (status && mutation.state.status !== status) {
          return false;
        }
        if (predicate && !predicate(mutation)) {
          return false;
        }
        return true;
      }
      function hashQueryKeyByOptions(queryKey, options) {
        const hashFn = options?.queryKeyHashFn || hashKey;
        return hashFn(queryKey);
      }
      function hashKey(queryKey) {
        return JSON.stringify(queryKey, (_, val) =>
          isPlainObject(val)
            ? Object.keys(val)
                .sort()
                .reduce((result, key) => {
                  result[key] = val[key];
                  return result;
                }, {})
            : val,
        );
      }
      function partialMatchKey(a, b) {
        if (a === b) {
          return true;
        }
        if (typeof a !== typeof b) {
          return false;
        }
        if (a && b && typeof a === "object" && typeof b === "object") {
          return Object.keys(b).every((key) => partialMatchKey(a[key], b[key]));
        }
        return false;
      }
      function replaceEqualDeep(a, b) {
        if (a === b) {
          return a;
        }
        const array = isPlainArray(a) && isPlainArray(b);
        if (array || (isPlainObject(a) && isPlainObject(b))) {
          const aItems = array ? a : Object.keys(a);
          const aSize = aItems.length;
          const bItems = array ? b : Object.keys(b);
          const bSize = bItems.length;
          const copy = array ? [] : {};
          const aItemsSet = new Set(aItems);
          let equalItems = 0;
          for (let i = 0; i < bSize; i++) {
            const key = array ? i : bItems[i];
            if (
              ((!array && aItemsSet.has(key)) || array) &&
              a[key] === void 0 &&
              b[key] === void 0
            ) {
              copy[key] = void 0;
              equalItems++;
            } else {
              copy[key] = replaceEqualDeep(a[key], b[key]);
              if (copy[key] === a[key] && a[key] !== void 0) {
                equalItems++;
              }
            }
          }
          return aSize === bSize && equalItems === aSize ? a : copy;
        }
        return b;
      }
      function isPlainArray(value) {
        return (
          Array.isArray(value) && value.length === Object.keys(value).length
        );
      }
      function isPlainObject(o) {
        if (!hasObjectPrototype(o)) {
          return false;
        }
        const ctor = o.constructor;
        if (ctor === void 0) {
          return true;
        }
        const prot = ctor.prototype;
        if (!hasObjectPrototype(prot)) {
          return false;
        }
        if (!prot.hasOwnProperty("isPrototypeOf")) {
          return false;
        }
        if (Object.getPrototypeOf(o) !== Object.prototype) {
          return false;
        }
        return true;
      }
      function hasObjectPrototype(o) {
        return Object.prototype.toString.call(o) === "[object Object]";
      }
      function sleep(timeout) {
        return new Promise((resolve) => {
          setTimeout(resolve, timeout);
        });
      }
      function replaceData(prevData, data, options) {
        if (typeof options.structuralSharing === "function") {
          return options.structuralSharing(prevData, data);
        } else if (options.structuralSharing !== false) {
          return replaceEqualDeep(prevData, data);
        }
        return data;
      }
      function addToEnd(items, item, max = 0) {
        const newItems = [...items, item];
        return max && newItems.length > max ? newItems.slice(1) : newItems;
      }
      function addToStart(items, item, max = 0) {
        const newItems = [item, ...items];
        return max && newItems.length > max ? newItems.slice(0, -1) : newItems;
      }
      var skipToken = Symbol();
      function ensureQueryFn(options, fetchOptions) {
        if (!options.queryFn && fetchOptions?.initialPromise) {
          return () => fetchOptions.initialPromise;
        }
        if (!options.queryFn || options.queryFn === skipToken) {
          return () =>
            Promise.reject(
              new Error(`Missing queryFn: '${options.queryHash}'`),
            );
        }
        return options.queryFn;
      }

      // src/focusManager.ts
      var FocusManager = class extends Subscribable {
        #focused;
        #cleanup;
        #setup;
        constructor() {
          super();
          this.#setup = (onFocus) => {
            if (!isServer && window.addEventListener) {
              const listener = () => onFocus();
              window.addEventListener("visibilitychange", listener, false);
              return () => {
                window.removeEventListener("visibilitychange", listener);
              };
            }
            return;
          };
        }
        onSubscribe() {
          if (!this.#cleanup) {
            this.setEventListener(this.#setup);
          }
        }
        onUnsubscribe() {
          if (!this.hasListeners()) {
            this.#cleanup?.();
            this.#cleanup = void 0;
          }
        }
        setEventListener(setup) {
          this.#setup = setup;
          this.#cleanup?.();
          this.#cleanup = setup((focused) => {
            if (typeof focused === "boolean") {
              this.setFocused(focused);
            } else {
              this.onFocus();
            }
          });
        }
        setFocused(focused) {
          const changed = this.#focused !== focused;
          if (changed) {
            this.#focused = focused;
            this.onFocus();
          }
        }
        onFocus() {
          const isFocused = this.isFocused();
          this.listeners.forEach((listener) => {
            listener(isFocused);
          });
        }
        isFocused() {
          if (typeof this.#focused === "boolean") {
            return this.#focused;
          }
          return globalThis.document?.visibilityState !== "hidden";
        }
      };
      var focusManager = new FocusManager();

      // src/onlineManager.ts
      var OnlineManager = class extends Subscribable {
        #online = true;
        #cleanup;
        #setup;
        constructor() {
          super();
          this.#setup = (onOnline) => {
            if (!isServer && window.addEventListener) {
              const onlineListener = () => onOnline(true);
              const offlineListener = () => onOnline(false);
              window.addEventListener("online", onlineListener, false);
              window.addEventListener("offline", offlineListener, false);
              return () => {
                window.removeEventListener("online", onlineListener);
                window.removeEventListener("offline", offlineListener);
              };
            }
            return;
          };
        }
        onSubscribe() {
          if (!this.#cleanup) {
            this.setEventListener(this.#setup);
          }
        }
        onUnsubscribe() {
          if (!this.hasListeners()) {
            this.#cleanup?.();
            this.#cleanup = void 0;
          }
        }
        setEventListener(setup) {
          this.#setup = setup;
          this.#cleanup?.();
          this.#cleanup = setup(this.setOnline.bind(this));
        }
        setOnline(online) {
          const changed = this.#online !== online;
          if (changed) {
            this.#online = online;
            this.listeners.forEach((listener) => {
              listener(online);
            });
          }
        }
        isOnline() {
          return this.#online;
        }
      };
      var onlineManager = new OnlineManager();

      // src/thenable.ts
      function pendingThenable() {
        let resolve;
        let reject;
        const thenable = new Promise((_resolve, _reject) => {
          resolve = _resolve;
          reject = _reject;
        });
        thenable.status = "pending";
        thenable.catch(() => {});
        function finalize(data) {
          Object.assign(thenable, data);
          delete thenable.resolve;
          delete thenable.reject;
        }
        thenable.resolve = (value) => {
          finalize({
            status: "fulfilled",
            value,
          });
          resolve(value);
        };
        thenable.reject = (reason) => {
          finalize({
            status: "rejected",
            reason,
          });
          reject(reason);
        };
        return thenable;
      }

      // src/retryer.ts
      function defaultRetryDelay(failureCount) {
        return Math.min(1e3 * 2 ** failureCount, 3e4);
      }
      function canFetch(networkMode) {
        return (networkMode ?? "online") === "online"
          ? onlineManager.isOnline()
          : true;
      }
      var CancelledError = class extends Error {
        constructor(options) {
          super("CancelledError");
          this.revert = options?.revert;
          this.silent = options?.silent;
        }
      };
      function isCancelledError(value) {
        return value instanceof CancelledError;
      }
      function createRetryer(config) {
        let isRetryCancelled = false;
        let failureCount = 0;
        let isResolved = false;
        let continueFn;
        const thenable = pendingThenable();
        const cancel = (cancelOptions) => {
          if (!isResolved) {
            reject(new CancelledError(cancelOptions));
            config.abort?.();
          }
        };
        const cancelRetry = () => {
          isRetryCancelled = true;
        };
        const continueRetry = () => {
          isRetryCancelled = false;
        };
        const canContinue = () =>
          focusManager.isFocused() &&
          (config.networkMode === "always" || onlineManager.isOnline()) &&
          config.canRun();
        const canStart = () => canFetch(config.networkMode) && config.canRun();
        const resolve = (value) => {
          if (!isResolved) {
            isResolved = true;
            config.onSuccess?.(value);
            continueFn?.();
            thenable.resolve(value);
          }
        };
        const reject = (value) => {
          if (!isResolved) {
            isResolved = true;
            config.onError?.(value);
            continueFn?.();
            thenable.reject(value);
          }
        };
        const pause = () => {
          return new Promise((continueResolve) => {
            continueFn = (value) => {
              if (isResolved || canContinue()) {
                continueResolve(value);
              }
            };
            config.onPause?.();
          }).then(() => {
            continueFn = void 0;
            if (!isResolved) {
              config.onContinue?.();
            }
          });
        };
        const run = () => {
          if (isResolved) {
            return;
          }
          let promiseOrValue;
          const initialPromise =
            failureCount === 0 ? config.initialPromise : void 0;
          try {
            promiseOrValue = initialPromise ?? config.fn();
          } catch (error) {
            promiseOrValue = Promise.reject(error);
          }
          Promise.resolve(promiseOrValue)
            .then(resolve)
            .catch((error) => {
              if (isResolved) {
                return;
              }
              const retry = config.retry ?? (isServer ? 0 : 3);
              const retryDelay = config.retryDelay ?? defaultRetryDelay;
              const delay =
                typeof retryDelay === "function"
                  ? retryDelay(failureCount, error)
                  : retryDelay;
              const shouldRetry =
                retry === true ||
                (typeof retry === "number" && failureCount < retry) ||
                (typeof retry === "function" && retry(failureCount, error));
              if (isRetryCancelled || !shouldRetry) {
                reject(error);
                return;
              }
              failureCount++;
              config.onFail?.(failureCount, error);
              sleep(delay)
                .then(() => {
                  return canContinue() ? void 0 : pause();
                })
                .then(() => {
                  if (isRetryCancelled) {
                    reject(error);
                  } else {
                    run();
                  }
                });
            });
        };
        return {
          promise: thenable,
          cancel,
          continue: () => {
            continueFn?.();
            return thenable;
          },
          cancelRetry,
          continueRetry,
          canStart,
          start: () => {
            if (canStart()) {
              run();
            } else {
              pause().then(run);
            }
            return thenable;
          },
        };
      }

      // src/notifyManager.ts
      var defaultScheduler = (cb) => setTimeout(cb, 0);
      function createNotifyManager() {
        let queue = [];
        let transactions = 0;
        let notifyFn = (callback) => {
          callback();
        };
        let batchNotifyFn = (callback) => {
          callback();
        };
        let scheduleFn = defaultScheduler;
        const schedule = (callback) => {
          if (transactions) {
            queue.push(callback);
          } else {
            scheduleFn(() => {
              notifyFn(callback);
            });
          }
        };
        const flush = () => {
          const originalQueue = queue;
          queue = [];
          if (originalQueue.length) {
            scheduleFn(() => {
              batchNotifyFn(() => {
                originalQueue.forEach((callback) => {
                  notifyFn(callback);
                });
              });
            });
          }
        };
        return {
          batch: (callback) => {
            let result;
            transactions++;
            try {
              result = callback();
            } finally {
              transactions--;
              if (!transactions) {
                flush();
              }
            }
            return result;
          },

          batchCalls: (callback) => {
            return (...args) => {
              schedule(() => {
                callback(...args);
              });
            };
          },
          schedule,

          setNotifyFunction: (fn) => {
            notifyFn = fn;
          },

          setBatchNotifyFunction: (fn) => {
            batchNotifyFn = fn;
          },
          setScheduler: (fn) => {
            scheduleFn = fn;
          },
        };
      }
      var notifyManager = createNotifyManager();

      // src/removable.ts
      var Removable = class {
        #gcTimeout;
        destroy() {
          this.clearGcTimeout();
        }
        scheduleGc() {
          this.clearGcTimeout();
          if (isValidTimeout(this.gcTime)) {
            this.#gcTimeout = setTimeout(() => {
              this.optionalRemove();
            }, this.gcTime);
          }
        }
        updateGcTime(newGcTime) {
          this.gcTime = Math.max(
            this.gcTime || 0,
            newGcTime ?? (isServer ? Infinity : 5 * 60 * 1e3),
          );
        }
        clearGcTimeout() {
          if (this.#gcTimeout) {
            clearTimeout(this.#gcTimeout);
            this.#gcTimeout = void 0;
          }
        }
      };

      var Query = class extends Removable {
        #initialState;
        #revertState;
        #cache;
        #client;
        #retryer;
        #defaultOptions;
        #abortSignalConsumed;
        constructor(config) {
          super();
          this.#abortSignalConsumed = false;
          this.#defaultOptions = config.defaultOptions;
          this.setOptions(config.options);
          this.observers = [];
          this.#client = config.client;
          this.#cache = this.#client.getQueryCache();
          this.queryKey = config.queryKey;
          this.queryHash = config.queryHash;
          this.#initialState = getDefaultState$1(this.options);
          this.state = config.state ?? this.#initialState;
          this.scheduleGc();
        }
        get meta() {
          return this.options.meta;
        }
        get promise() {
          return this.#retryer?.promise;
        }
        setOptions(options) {
          this.options = { ...this.#defaultOptions, ...options };
          this.updateGcTime(this.options.gcTime);
        }
        optionalRemove() {
          if (!this.observers.length && this.state.fetchStatus === "idle") {
            this.#cache.remove(this);
          }
        }
        setData(newData, options) {
          const data = replaceData(this.state.data, newData, this.options);
          this.#dispatch({
            data,
            type: "success",
            dataUpdatedAt: options?.updatedAt,
            manual: options?.manual,
          });
          return data;
        }
        setState(state, setStateOptions) {
          this.#dispatch({ type: "setState", state, setStateOptions });
        }
        cancel(options) {
          const promise = this.#retryer?.promise;
          this.#retryer?.cancel(options);
          return promise
            ? promise.then(noop$1).catch(noop$1)
            : Promise.resolve();
        }
        destroy() {
          super.destroy();
          this.cancel({ silent: true });
        }
        reset() {
          this.destroy();
          this.setState(this.#initialState);
        }
        isActive() {
          return this.observers.some(
            (observer) =>
              resolveEnabled(observer.options.enabled, this) !== false,
          );
        }
        isDisabled() {
          if (this.getObserversCount() > 0) {
            return !this.isActive();
          }
          return (
            this.options.queryFn === skipToken ||
            this.state.dataUpdateCount + this.state.errorUpdateCount === 0
          );
        }
        isStatic() {
          if (this.getObserversCount() > 0) {
            return this.observers.some(
              (observer) =>
                resolveStaleTime(observer.options.staleTime, this) === "static",
            );
          }
          return false;
        }
        isStale() {
          if (this.getObserversCount() > 0) {
            return this.observers.some(
              (observer) => observer.getCurrentResult().isStale,
            );
          }
          return this.state.data === void 0 || this.state.isInvalidated;
        }
        isStaleByTime(staleTime = 0) {
          if (this.state.data === void 0) {
            return true;
          }
          if (staleTime === "static") {
            return false;
          }
          if (this.state.isInvalidated) {
            return true;
          }
          return !timeUntilStale(this.state.dataUpdatedAt, staleTime);
        }
        onFocus() {
          const observer = this.observers.find((x) =>
            x.shouldFetchOnWindowFocus(),
          );
          observer?.refetch({ cancelRefetch: false });
          this.#retryer?.continue();
        }
        onOnline() {
          const observer = this.observers.find((x) =>
            x.shouldFetchOnReconnect(),
          );
          observer?.refetch({ cancelRefetch: false });
          this.#retryer?.continue();
        }
        addObserver(observer) {
          if (!this.observers.includes(observer)) {
            this.observers.push(observer);
            this.clearGcTimeout();
            this.#cache.notify({
              type: "observerAdded",
              query: this,
              observer,
            });
          }
        }
        removeObserver(observer) {
          if (this.observers.includes(observer)) {
            this.observers = this.observers.filter((x) => x !== observer);
            if (!this.observers.length) {
              if (this.#retryer) {
                if (this.#abortSignalConsumed) {
                  this.#retryer.cancel({ revert: true });
                } else {
                  this.#retryer.cancelRetry();
                }
              }
              this.scheduleGc();
            }
            this.#cache.notify({
              type: "observerRemoved",
              query: this,
              observer,
            });
          }
        }
        getObserversCount() {
          return this.observers.length;
        }
        invalidate() {
          if (!this.state.isInvalidated) {
            this.#dispatch({ type: "invalidate" });
          }
        }
        fetch(options, fetchOptions) {
          if (this.state.fetchStatus !== "idle") {
            if (this.state.data !== void 0 && fetchOptions?.cancelRefetch) {
              this.cancel({ silent: true });
            } else if (this.#retryer) {
              this.#retryer.continueRetry();
              return this.#retryer.promise;
            }
          }
          if (options) {
            this.setOptions(options);
          }
          if (!this.options.queryFn) {
            const observer = this.observers.find((x) => x.options.queryFn);
            if (observer) {
              this.setOptions(observer.options);
            }
          }
          const abortController = new AbortController();
          const addSignalProperty = (object) => {
            Object.defineProperty(object, "signal", {
              enumerable: true,
              get: () => {
                this.#abortSignalConsumed = true;
                return abortController.signal;
              },
            });
          };
          const fetchFn = () => {
            const queryFn = ensureQueryFn(this.options, fetchOptions);
            const createQueryFnContext = () => {
              const queryFnContext2 = {
                client: this.#client,
                queryKey: this.queryKey,
                meta: this.meta,
              };
              addSignalProperty(queryFnContext2);
              return queryFnContext2;
            };
            const queryFnContext = createQueryFnContext();
            this.#abortSignalConsumed = false;
            if (this.options.persister) {
              return this.options.persister(queryFn, queryFnContext, this);
            }
            return queryFn(queryFnContext);
          };
          const createFetchContext = () => {
            const context2 = {
              fetchOptions,
              options: this.options,
              queryKey: this.queryKey,
              client: this.#client,
              state: this.state,
              fetchFn,
            };
            addSignalProperty(context2);
            return context2;
          };
          const context = createFetchContext();
          this.options.behavior?.onFetch(context, this);
          this.#revertState = this.state;
          if (
            this.state.fetchStatus === "idle" ||
            this.state.fetchMeta !== context.fetchOptions?.meta
          ) {
            this.#dispatch({ type: "fetch", meta: context.fetchOptions?.meta });
          }
          const onError = (error) => {
            if (!(isCancelledError(error) && error.silent)) {
              this.#dispatch({
                type: "error",
                error,
              });
            }
            if (!isCancelledError(error)) {
              this.#cache.config.onError?.(error, this);
              this.#cache.config.onSettled?.(this.state.data, error, this);
            }
            this.scheduleGc();
          };
          this.#retryer = createRetryer({
            initialPromise: fetchOptions?.initialPromise,
            fn: context.fetchFn,
            abort: abortController.abort.bind(abortController),
            onSuccess: (data) => {
              if (data === void 0) {
                onError(new Error(`${this.queryHash} data is undefined`));
                return;
              }
              try {
                this.setData(data);
              } catch (error) {
                onError(error);
                return;
              }
              this.#cache.config.onSuccess?.(data, this);
              this.#cache.config.onSettled?.(data, this.state.error, this);
              this.scheduleGc();
            },
            onError,
            onFail: (failureCount, error) => {
              this.#dispatch({ type: "failed", failureCount, error });
            },
            onPause: () => {
              this.#dispatch({ type: "pause" });
            },
            onContinue: () => {
              this.#dispatch({ type: "continue" });
            },
            retry: context.options.retry,
            retryDelay: context.options.retryDelay,
            networkMode: context.options.networkMode,
            canRun: () => true,
          });
          return this.#retryer.start();
        }
        #dispatch(action) {
          const reducer = (state) => {
            switch (action.type) {
              case "failed":
                return {
                  ...state,
                  fetchFailureCount: action.failureCount,
                  fetchFailureReason: action.error,
                };
              case "pause":
                return {
                  ...state,
                  fetchStatus: "paused",
                };
              case "continue":
                return {
                  ...state,
                  fetchStatus: "fetching",
                };
              case "fetch":
                return {
                  ...state,
                  ...fetchState(state.data, this.options),
                  fetchMeta: action.meta ?? null,
                };
              case "success":
                this.#revertState = void 0;
                return {
                  ...state,
                  data: action.data,
                  dataUpdateCount: state.dataUpdateCount + 1,
                  dataUpdatedAt: action.dataUpdatedAt ?? Date.now(),
                  error: null,
                  isInvalidated: false,
                  status: "success",
                  ...(!action.manual && {
                    fetchStatus: "idle",
                    fetchFailureCount: 0,
                    fetchFailureReason: null,
                  }),
                };
              case "error":
                const error = action.error;
                if (
                  isCancelledError(error) &&
                  error.revert &&
                  this.#revertState
                ) {
                  return { ...this.#revertState, fetchStatus: "idle" };
                }
                return {
                  ...state,
                  error,
                  errorUpdateCount: state.errorUpdateCount + 1,
                  errorUpdatedAt: Date.now(),
                  fetchFailureCount: state.fetchFailureCount + 1,
                  fetchFailureReason: error,
                  fetchStatus: "idle",
                  status: "error",
                };
              case "invalidate":
                return {
                  ...state,
                  isInvalidated: true,
                };
              case "setState":
                return {
                  ...state,
                  ...action.state,
                };
            }
          };
          this.state = reducer(this.state);
          notifyManager.batch(() => {
            this.observers.forEach((observer) => {
              observer.onQueryUpdate();
            });
            this.#cache.notify({ query: this, type: "updated", action });
          });
        }
      };
      function fetchState(data, options) {
        return {
          fetchFailureCount: 0,
          fetchFailureReason: null,
          fetchStatus: canFetch(options.networkMode) ? "fetching" : "paused",
          ...(data === void 0 && {
            error: null,
            status: "pending",
          }),
        };
      }
      function getDefaultState$1(options) {
        const data =
          typeof options.initialData === "function"
            ? options.initialData()
            : options.initialData;
        const hasData = data !== void 0;
        const initialDataUpdatedAt = hasData
          ? typeof options.initialDataUpdatedAt === "function"
            ? options.initialDataUpdatedAt()
            : options.initialDataUpdatedAt
          : 0;
        return {
          data,
          dataUpdateCount: 0,
          dataUpdatedAt: hasData ? (initialDataUpdatedAt ?? Date.now()) : 0,
          error: null,
          errorUpdateCount: 0,
          errorUpdatedAt: 0,
          fetchFailureCount: 0,
          fetchFailureReason: null,
          fetchMeta: null,
          isInvalidated: false,
          status: hasData ? "success" : "pending",
          fetchStatus: "idle",
        };
      }

      // src/queryCache.ts
      var QueryCache = class extends Subscribable {
        constructor(config = {}) {
          super();
          this.config = config;
          this.#queries = /* @__PURE__ */ new Map();
        }
        #queries;
        build(client, options, state) {
          const queryKey = options.queryKey;
          const queryHash =
            options.queryHash ?? hashQueryKeyByOptions(queryKey, options);
          let query = this.get(queryHash);
          if (!query) {
            query = new Query({
              client,
              queryKey,
              queryHash,
              options: client.defaultQueryOptions(options),
              state,
              defaultOptions: client.getQueryDefaults(queryKey),
            });
            this.add(query);
          }
          return query;
        }
        add(query) {
          if (!this.#queries.has(query.queryHash)) {
            this.#queries.set(query.queryHash, query);
            this.notify({
              type: "added",
              query,
            });
          }
        }
        remove(query) {
          const queryInMap = this.#queries.get(query.queryHash);
          if (queryInMap) {
            query.destroy();
            if (queryInMap === query) {
              this.#queries.delete(query.queryHash);
            }
            this.notify({ type: "removed", query });
          }
        }
        clear() {
          notifyManager.batch(() => {
            this.getAll().forEach((query) => {
              this.remove(query);
            });
          });
        }
        get(queryHash) {
          return this.#queries.get(queryHash);
        }
        getAll() {
          return [...this.#queries.values()];
        }
        find(filters) {
          const defaultedFilters = { exact: true, ...filters };
          return this.getAll().find((query) =>
            matchQuery(defaultedFilters, query),
          );
        }
        findAll(filters = {}) {
          const queries = this.getAll();
          return Object.keys(filters).length > 0
            ? queries.filter((query) => matchQuery(filters, query))
            : queries;
        }
        notify(event) {
          notifyManager.batch(() => {
            this.listeners.forEach((listener) => {
              listener(event);
            });
          });
        }
        onFocus() {
          notifyManager.batch(() => {
            this.getAll().forEach((query) => {
              query.onFocus();
            });
          });
        }
        onOnline() {
          notifyManager.batch(() => {
            this.getAll().forEach((query) => {
              query.onOnline();
            });
          });
        }
      };

      // src/mutation.ts
      var Mutation = class extends Removable {
        #observers;
        #mutationCache;
        #retryer;
        constructor(config) {
          super();
          this.mutationId = config.mutationId;
          this.#mutationCache = config.mutationCache;
          this.#observers = [];
          this.state = config.state || getDefaultState();
          this.setOptions(config.options);
          this.scheduleGc();
        }
        setOptions(options) {
          this.options = options;
          this.updateGcTime(this.options.gcTime);
        }
        get meta() {
          return this.options.meta;
        }
        addObserver(observer) {
          if (!this.#observers.includes(observer)) {
            this.#observers.push(observer);
            this.clearGcTimeout();
            this.#mutationCache.notify({
              type: "observerAdded",
              mutation: this,
              observer,
            });
          }
        }
        removeObserver(observer) {
          this.#observers = this.#observers.filter((x) => x !== observer);
          this.scheduleGc();
          this.#mutationCache.notify({
            type: "observerRemoved",
            mutation: this,
            observer,
          });
        }
        optionalRemove() {
          if (!this.#observers.length) {
            if (this.state.status === "pending") {
              this.scheduleGc();
            } else {
              this.#mutationCache.remove(this);
            }
          }
        }
        continue() {
          return (
            this.#retryer?.continue() ?? // continuing a mutation assumes that variables are set, mutation must have been dehydrated before
            this.execute(this.state.variables)
          );
        }
        async execute(variables) {
          const onContinue = () => {
            this.#dispatch({ type: "continue" });
          };
          this.#retryer = createRetryer({
            fn: () => {
              if (!this.options.mutationFn) {
                return Promise.reject(new Error("No mutationFn found"));
              }
              return this.options.mutationFn(variables);
            },
            onFail: (failureCount, error) => {
              this.#dispatch({ type: "failed", failureCount, error });
            },
            onPause: () => {
              this.#dispatch({ type: "pause" });
            },
            onContinue,
            retry: this.options.retry ?? 0,
            retryDelay: this.options.retryDelay,
            networkMode: this.options.networkMode,
            canRun: () => this.#mutationCache.canRun(this),
          });
          const restored = this.state.status === "pending";
          const isPaused = !this.#retryer.canStart();
          try {
            if (restored) {
              onContinue();
            } else {
              this.#dispatch({ type: "pending", variables, isPaused });
              await this.#mutationCache.config.onMutate?.(variables, this);
              const context = await this.options.onMutate?.(variables);
              if (context !== this.state.context) {
                this.#dispatch({
                  type: "pending",
                  context,
                  variables,
                  isPaused,
                });
              }
            }
            const data = await this.#retryer.start();
            await this.#mutationCache.config.onSuccess?.(
              data,
              variables,
              this.state.context,
              this,
            );
            await this.options.onSuccess?.(data, variables, this.state.context);
            await this.#mutationCache.config.onSettled?.(
              data,
              null,
              this.state.variables,
              this.state.context,
              this,
            );
            await this.options.onSettled?.(
              data,
              null,
              variables,
              this.state.context,
            );
            this.#dispatch({ type: "success", data });
            return data;
          } catch (error) {
            try {
              await this.#mutationCache.config.onError?.(
                error,
                variables,
                this.state.context,
                this,
              );
              await this.options.onError?.(
                error,
                variables,
                this.state.context,
              );
              await this.#mutationCache.config.onSettled?.(
                void 0,
                error,
                this.state.variables,
                this.state.context,
                this,
              );
              await this.options.onSettled?.(
                void 0,
                error,
                variables,
                this.state.context,
              );
              throw error;
            } finally {
              this.#dispatch({ type: "error", error });
            }
          } finally {
            this.#mutationCache.runNext(this);
          }
        }
        #dispatch(action) {
          const reducer = (state) => {
            switch (action.type) {
              case "failed":
                return {
                  ...state,
                  failureCount: action.failureCount,
                  failureReason: action.error,
                };
              case "pause":
                return {
                  ...state,
                  isPaused: true,
                };
              case "continue":
                return {
                  ...state,
                  isPaused: false,
                };
              case "pending":
                return {
                  ...state,
                  context: action.context,
                  data: void 0,
                  failureCount: 0,
                  failureReason: null,
                  error: null,
                  isPaused: action.isPaused,
                  status: "pending",
                  variables: action.variables,
                  submittedAt: Date.now(),
                };
              case "success":
                return {
                  ...state,
                  data: action.data,
                  failureCount: 0,
                  failureReason: null,
                  error: null,
                  status: "success",
                  isPaused: false,
                };
              case "error":
                return {
                  ...state,
                  data: void 0,
                  error: action.error,
                  failureCount: state.failureCount + 1,
                  failureReason: action.error,
                  isPaused: false,
                  status: "error",
                };
            }
          };
          this.state = reducer(this.state);
          notifyManager.batch(() => {
            this.#observers.forEach((observer) => {
              observer.onMutationUpdate(action);
            });
            this.#mutationCache.notify({
              mutation: this,
              type: "updated",
              action,
            });
          });
        }
      };
      function getDefaultState() {
        return {
          context: void 0,
          data: void 0,
          error: null,
          failureCount: 0,
          failureReason: null,
          isPaused: false,
          status: "idle",
          variables: void 0,
          submittedAt: 0,
        };
      }

      // src/mutationCache.ts
      var MutationCache = class extends Subscribable {
        constructor(config = {}) {
          super();
          this.config = config;
          this.#mutations = /* @__PURE__ */ new Set();
          this.#scopes = /* @__PURE__ */ new Map();
          this.#mutationId = 0;
        }
        #mutations;
        #scopes;
        #mutationId;
        build(client, options, state) {
          const mutation = new Mutation({
            mutationCache: this,
            mutationId: ++this.#mutationId,
            options: client.defaultMutationOptions(options),
            state,
          });
          this.add(mutation);
          return mutation;
        }
        add(mutation) {
          this.#mutations.add(mutation);
          const scope = scopeFor(mutation);
          if (typeof scope === "string") {
            const scopedMutations = this.#scopes.get(scope);
            if (scopedMutations) {
              scopedMutations.push(mutation);
            } else {
              this.#scopes.set(scope, [mutation]);
            }
          }
          this.notify({ type: "added", mutation });
        }
        remove(mutation) {
          if (this.#mutations.delete(mutation)) {
            const scope = scopeFor(mutation);
            if (typeof scope === "string") {
              const scopedMutations = this.#scopes.get(scope);
              if (scopedMutations) {
                if (scopedMutations.length > 1) {
                  const index = scopedMutations.indexOf(mutation);
                  if (index !== -1) {
                    scopedMutations.splice(index, 1);
                  }
                } else if (scopedMutations[0] === mutation) {
                  this.#scopes.delete(scope);
                }
              }
            }
          }
          this.notify({ type: "removed", mutation });
        }
        canRun(mutation) {
          const scope = scopeFor(mutation);
          if (typeof scope === "string") {
            const mutationsWithSameScope = this.#scopes.get(scope);
            const firstPendingMutation = mutationsWithSameScope?.find(
              (m) => m.state.status === "pending",
            );
            return !firstPendingMutation || firstPendingMutation === mutation;
          } else {
            return true;
          }
        }
        runNext(mutation) {
          const scope = scopeFor(mutation);
          if (typeof scope === "string") {
            const foundMutation = this.#scopes
              .get(scope)
              ?.find((m) => m !== mutation && m.state.isPaused);
            return foundMutation?.continue() ?? Promise.resolve();
          } else {
            return Promise.resolve();
          }
        }
        clear() {
          notifyManager.batch(() => {
            this.#mutations.forEach((mutation) => {
              this.notify({ type: "removed", mutation });
            });
            this.#mutations.clear();
            this.#scopes.clear();
          });
        }
        getAll() {
          return Array.from(this.#mutations);
        }
        find(filters) {
          const defaultedFilters = { exact: true, ...filters };
          return this.getAll().find((mutation) =>
            matchMutation(defaultedFilters, mutation),
          );
        }
        findAll(filters = {}) {
          return this.getAll().filter((mutation) =>
            matchMutation(filters, mutation),
          );
        }
        notify(event) {
          notifyManager.batch(() => {
            this.listeners.forEach((listener) => {
              listener(event);
            });
          });
        }
        resumePausedMutations() {
          const pausedMutations = this.getAll().filter((x) => x.state.isPaused);
          return notifyManager.batch(() =>
            Promise.all(
              pausedMutations.map((mutation) =>
                mutation.continue().catch(noop$1),
              ),
            ),
          );
        }
      };
      function scopeFor(mutation) {
        return mutation.options.scope?.id;
      }

      // src/infiniteQueryBehavior.ts
      function infiniteQueryBehavior(pages) {
        return {
          onFetch: (context, query) => {
            const options = context.options;
            const direction = context.fetchOptions?.meta?.fetchMore?.direction;
            const oldPages = context.state.data?.pages || [];
            const oldPageParams = context.state.data?.pageParams || [];
            let result = { pages: [], pageParams: [] };
            let currentPage = 0;
            const fetchFn = async () => {
              let cancelled = false;
              const addSignalProperty = (object) => {
                Object.defineProperty(object, "signal", {
                  enumerable: true,
                  get: () => {
                    if (context.signal.aborted) {
                      cancelled = true;
                    } else {
                      context.signal.addEventListener("abort", () => {
                        cancelled = true;
                      });
                    }
                    return context.signal;
                  },
                });
              };
              const queryFn = ensureQueryFn(
                context.options,
                context.fetchOptions,
              );
              const fetchPage = async (data, param, previous) => {
                if (cancelled) {
                  return Promise.reject();
                }
                if (param == null && data.pages.length) {
                  return Promise.resolve(data);
                }
                const createQueryFnContext = () => {
                  const queryFnContext2 = {
                    client: context.client,
                    queryKey: context.queryKey,
                    pageParam: param,
                    direction: previous ? "backward" : "forward",
                    meta: context.options.meta,
                  };
                  addSignalProperty(queryFnContext2);
                  return queryFnContext2;
                };
                const queryFnContext = createQueryFnContext();
                const page = await queryFn(queryFnContext);
                const { maxPages } = context.options;
                const addTo = previous ? addToStart : addToEnd;
                return {
                  pages: addTo(data.pages, page, maxPages),
                  pageParams: addTo(data.pageParams, param, maxPages),
                };
              };
              if (direction && oldPages.length) {
                const previous = direction === "backward";
                const pageParamFn = previous
                  ? getPreviousPageParam
                  : getNextPageParam;
                const oldData = {
                  pages: oldPages,
                  pageParams: oldPageParams,
                };
                const param = pageParamFn(options, oldData);
                result = await fetchPage(oldData, param, previous);
              } else {
                const remainingPages = pages ?? oldPages.length;
                do {
                  const param =
                    currentPage === 0
                      ? (oldPageParams[0] ?? options.initialPageParam)
                      : getNextPageParam(options, result);
                  if (currentPage > 0 && param == null) {
                    break;
                  }
                  result = await fetchPage(result, param);
                  currentPage++;
                } while (currentPage < remainingPages);
              }
              return result;
            };
            if (context.options.persister) {
              context.fetchFn = () => {
                return context.options.persister?.(
                  fetchFn,
                  {
                    client: context.client,
                    queryKey: context.queryKey,
                    meta: context.options.meta,
                    signal: context.signal,
                  },
                  query,
                );
              };
            } else {
              context.fetchFn = fetchFn;
            }
          },
        };
      }
      function getNextPageParam(options, { pages, pageParams }) {
        const lastIndex = pages.length - 1;
        return pages.length > 0
          ? options.getNextPageParam(
              pages[lastIndex],
              pages,
              pageParams[lastIndex],
              pageParams,
            )
          : void 0;
      }
      function getPreviousPageParam(options, { pages, pageParams }) {
        return pages.length > 0
          ? options.getPreviousPageParam?.(
              pages[0],
              pages,
              pageParams[0],
              pageParams,
            )
          : void 0;
      }

      // src/queryClient.ts
      var QueryClient = class {
        #queryCache;
        #mutationCache;
        #defaultOptions;
        #queryDefaults;
        #mutationDefaults;
        #mountCount;
        #unsubscribeFocus;
        #unsubscribeOnline;
        constructor(config = {}) {
          this.#queryCache = config.queryCache || new QueryCache();
          this.#mutationCache = config.mutationCache || new MutationCache();
          this.#defaultOptions = config.defaultOptions || {};
          this.#queryDefaults = /* @__PURE__ */ new Map();
          this.#mutationDefaults = /* @__PURE__ */ new Map();
          this.#mountCount = 0;
        }
        mount() {
          this.#mountCount++;
          if (this.#mountCount !== 1) return;
          this.#unsubscribeFocus = focusManager.subscribe(async (focused) => {
            if (focused) {
              await this.resumePausedMutations();
              this.#queryCache.onFocus();
            }
          });
          this.#unsubscribeOnline = onlineManager.subscribe(async (online) => {
            if (online) {
              await this.resumePausedMutations();
              this.#queryCache.onOnline();
            }
          });
        }
        unmount() {
          this.#mountCount--;
          if (this.#mountCount !== 0) return;
          this.#unsubscribeFocus?.();
          this.#unsubscribeFocus = void 0;
          this.#unsubscribeOnline?.();
          this.#unsubscribeOnline = void 0;
        }
        isFetching(filters) {
          return this.#queryCache.findAll({
            ...filters,
            fetchStatus: "fetching",
          }).length;
        }
        isMutating(filters) {
          return this.#mutationCache.findAll({ ...filters, status: "pending" })
            .length;
        }

        getQueryData(queryKey) {
          const options = this.defaultQueryOptions({ queryKey });
          return this.#queryCache.get(options.queryHash)?.state.data;
        }
        ensureQueryData(options) {
          const defaultedOptions = this.defaultQueryOptions(options);
          const query = this.#queryCache.build(this, defaultedOptions);
          const cachedData = query.state.data;
          if (cachedData === void 0) {
            return this.fetchQuery(options);
          }
          if (
            options.revalidateIfStale &&
            query.isStaleByTime(
              resolveStaleTime(defaultedOptions.staleTime, query),
            )
          ) {
            void this.prefetchQuery(defaultedOptions);
          }
          return Promise.resolve(cachedData);
        }
        getQueriesData(filters) {
          return this.#queryCache
            .findAll(filters)
            .map(({ queryKey, state }) => {
              const data = state.data;
              return [queryKey, data];
            });
        }
        setQueryData(queryKey, updater, options) {
          const defaultedOptions = this.defaultQueryOptions({ queryKey });
          const query = this.#queryCache.get(defaultedOptions.queryHash);
          const prevData = query?.state.data;
          const data = functionalUpdate(updater, prevData);
          if (data === void 0) {
            return void 0;
          }
          return this.#queryCache
            .build(this, defaultedOptions)
            .setData(data, { ...options, manual: true });
        }
        setQueriesData(filters, updater, options) {
          return notifyManager.batch(() =>
            this.#queryCache
              .findAll(filters)
              .map(({ queryKey }) => [
                queryKey,
                this.setQueryData(queryKey, updater, options),
              ]),
          );
        }
        getQueryState(queryKey) {
          const options = this.defaultQueryOptions({ queryKey });
          return this.#queryCache.get(options.queryHash)?.state;
        }
        removeQueries(filters) {
          const queryCache = this.#queryCache;
          notifyManager.batch(() => {
            queryCache.findAll(filters).forEach((query) => {
              queryCache.remove(query);
            });
          });
        }
        resetQueries(filters, options) {
          const queryCache = this.#queryCache;
          return notifyManager.batch(() => {
            queryCache.findAll(filters).forEach((query) => {
              query.reset();
            });
            return this.refetchQueries(
              {
                type: "active",
                ...filters,
              },
              options,
            );
          });
        }
        cancelQueries(filters, cancelOptions = {}) {
          const defaultedCancelOptions = { revert: true, ...cancelOptions };
          const promises = notifyManager.batch(() =>
            this.#queryCache
              .findAll(filters)
              .map((query) => query.cancel(defaultedCancelOptions)),
          );
          return Promise.all(promises).then(noop$1).catch(noop$1);
        }
        invalidateQueries(filters, options = {}) {
          return notifyManager.batch(() => {
            this.#queryCache.findAll(filters).forEach((query) => {
              query.invalidate();
            });
            if (filters?.refetchType === "none") {
              return Promise.resolve();
            }
            return this.refetchQueries(
              {
                ...filters,
                type: filters?.refetchType ?? filters?.type ?? "active",
              },
              options,
            );
          });
        }
        refetchQueries(filters, options = {}) {
          const fetchOptions = {
            ...options,
            cancelRefetch: options.cancelRefetch ?? true,
          };
          const promises = notifyManager.batch(() =>
            this.#queryCache
              .findAll(filters)
              .filter((query) => !query.isDisabled() && !query.isStatic())
              .map((query) => {
                let promise = query.fetch(void 0, fetchOptions);
                if (!fetchOptions.throwOnError) {
                  promise = promise.catch(noop$1);
                }
                return query.state.fetchStatus === "paused"
                  ? Promise.resolve()
                  : promise;
              }),
          );
          return Promise.all(promises).then(noop$1);
        }
        fetchQuery(options) {
          const defaultedOptions = this.defaultQueryOptions(options);
          if (defaultedOptions.retry === void 0) {
            defaultedOptions.retry = false;
          }
          const query = this.#queryCache.build(this, defaultedOptions);
          return query.isStaleByTime(
            resolveStaleTime(defaultedOptions.staleTime, query),
          )
            ? query.fetch(defaultedOptions)
            : Promise.resolve(query.state.data);
        }
        prefetchQuery(options) {
          return this.fetchQuery(options).then(noop$1).catch(noop$1);
        }
        fetchInfiniteQuery(options) {
          options.behavior = infiniteQueryBehavior(options.pages);
          return this.fetchQuery(options);
        }
        prefetchInfiniteQuery(options) {
          return this.fetchInfiniteQuery(options).then(noop$1).catch(noop$1);
        }
        ensureInfiniteQueryData(options) {
          options.behavior = infiniteQueryBehavior(options.pages);
          return this.ensureQueryData(options);
        }
        resumePausedMutations() {
          if (onlineManager.isOnline()) {
            return this.#mutationCache.resumePausedMutations();
          }
          return Promise.resolve();
        }
        getQueryCache() {
          return this.#queryCache;
        }
        getMutationCache() {
          return this.#mutationCache;
        }
        getDefaultOptions() {
          return this.#defaultOptions;
        }
        setDefaultOptions(options) {
          this.#defaultOptions = options;
        }
        setQueryDefaults(queryKey, options) {
          this.#queryDefaults.set(hashKey(queryKey), {
            queryKey,
            defaultOptions: options,
          });
        }
        getQueryDefaults(queryKey) {
          const defaults = [...this.#queryDefaults.values()];
          const result = {};
          defaults.forEach((queryDefault) => {
            if (partialMatchKey(queryKey, queryDefault.queryKey)) {
              Object.assign(result, queryDefault.defaultOptions);
            }
          });
          return result;
        }
        setMutationDefaults(mutationKey, options) {
          this.#mutationDefaults.set(hashKey(mutationKey), {
            mutationKey,
            defaultOptions: options,
          });
        }
        getMutationDefaults(mutationKey) {
          const defaults = [...this.#mutationDefaults.values()];
          const result = {};
          defaults.forEach((queryDefault) => {
            if (partialMatchKey(mutationKey, queryDefault.mutationKey)) {
              Object.assign(result, queryDefault.defaultOptions);
            }
          });
          return result;
        }
        defaultQueryOptions(options) {
          if (options._defaulted) {
            return options;
          }
          const defaultedOptions = {
            ...this.#defaultOptions.queries,
            ...this.getQueryDefaults(options.queryKey),
            ...options,
            _defaulted: true,
          };
          if (!defaultedOptions.queryHash) {
            defaultedOptions.queryHash = hashQueryKeyByOptions(
              defaultedOptions.queryKey,
              defaultedOptions,
            );
          }
          if (defaultedOptions.refetchOnReconnect === void 0) {
            defaultedOptions.refetchOnReconnect =
              defaultedOptions.networkMode !== "always";
          }
          if (defaultedOptions.throwOnError === void 0) {
            defaultedOptions.throwOnError = !!defaultedOptions.suspense;
          }
          if (!defaultedOptions.networkMode && defaultedOptions.persister) {
            defaultedOptions.networkMode = "offlineFirst";
          }
          if (defaultedOptions.queryFn === skipToken) {
            defaultedOptions.enabled = false;
          }
          return defaultedOptions;
        }
        defaultMutationOptions(options) {
          if (options?._defaulted) {
            return options;
          }
          return {
            ...this.#defaultOptions.mutations,
            ...(options?.mutationKey &&
              this.getMutationDefaults(options.mutationKey)),
            ...options,
            _defaulted: true,
          };
        }
        clear() {
          this.#queryCache.clear();
          this.#mutationCache.clear();
        }
      };

      var QueryClientContext = reactExports.createContext(void 0);
      var QueryClientProvider = ({ client, children }) => {
        reactExports.useEffect(() => {
          client.mount();
          return () => {
            client.unmount();
          };
        }, [client]);
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          QueryClientContext.Provider,
          { value: client, children },
        );
      };

      function _extends$1() {
        _extends$1 = Object.assign
          ? Object.assign.bind()
          : function (target) {
              for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i];
                for (var key in source) {
                  if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                  }
                }
              }
              return target;
            };
        return _extends$1.apply(this, arguments);
      }

      ////////////////////////////////////////////////////////////////////////////////
      //#region Types and Constants
      ////////////////////////////////////////////////////////////////////////////////

      var Action;
      (function (Action) {
        Action["Pop"] = "POP";

        Action["Push"] = "PUSH";

        Action["Replace"] = "REPLACE";
      })(Action || (Action = {}));
      const PopStateEventType = "popstate";

      function createHashHistory(options) {
        if (options === void 0) {
          options = {};
        }
        function createHashLocation(window, globalHistory) {
          let {
            pathname = "/",
            search = "",
            hash = "",
          } = parsePath(window.location.hash.substr(1));
          // Hash URL should always have a leading / just like window.location.pathname
          // does, so if an app ends up at a route like /#something then we add a
          // leading slash so all of our path-matching behaves the same as if it would
          // in a browser router.  This is particularly important when there exists a
          // root splat route (<Route path="*">) since that matches internally against
          // "/*" and we'd expect /#something to 404 in a hash router app.
          if (!pathname.startsWith("/") && !pathname.startsWith(".")) {
            pathname = "/" + pathname;
          }
          return createLocation(
            "",
            {
              pathname,
              search,
              hash,
            },
            // state defaults to `null` because `window.history.state` does
            (globalHistory.state && globalHistory.state.usr) || null,
            (globalHistory.state && globalHistory.state.key) || "default",
          );
        }
        function createHashHref(window, to) {
          let base = window.document.querySelector("base");
          let href = "";
          if (base && base.getAttribute("href")) {
            let url = window.location.href;
            let hashIndex = url.indexOf("#");
            href = hashIndex === -1 ? url : url.slice(0, hashIndex);
          }
          return href + "#" + (typeof to === "string" ? to : createPath(to));
        }
        function validateHashLocation(location, to) {
          warning(
            location.pathname.charAt(0) === "/",
            "relative pathnames are not supported in hash history.push(" +
              JSON.stringify(to) +
              ")",
          );
        }
        return getUrlBasedHistory(
          createHashLocation,
          createHashHref,
          validateHashLocation,
          options,
        );
      }
      function invariant$1(value, message) {
        if (value === false || value === null || typeof value === "undefined") {
          throw new Error(message);
        }
      }
      function warning(cond, message) {
        if (!cond) {
          // eslint-disable-next-line no-console
          if (typeof console !== "undefined") console.warn(message);
          try {
            // Welcome to debugging history!
            //
            // This error is thrown as a convenience, so you can more easily
            // find the source for a warning that appears in the console by
            // enabling "pause on exceptions" in your JavaScript debugger.
            throw new Error(message);
            // eslint-disable-next-line no-empty
          } catch (e) {}
        }
      }
      function createKey() {
        return Math.random().toString(36).substr(2, 8);
      }

      function getHistoryState(location, index) {
        return {
          usr: location.state,
          key: location.key,
          idx: index,
        };
      }

      function createLocation(current, to, state, key) {
        if (state === void 0) {
          state = null;
        }
        let location = _extends$1(
          {
            pathname: typeof current === "string" ? current : current.pathname,
            search: "",
            hash: "",
          },
          typeof to === "string" ? parsePath(to) : to,
          {
            state,
            // TODO: This could be cleaned up.  push/replace should probably just take
            // full Locations now and avoid the need to run through this flow at all
            // But that's a pretty big refactor to the current test suite so going to
            // keep as is for the time being and just let any incoming keys take precedence
            key: (to && to.key) || key || createKey(),
          },
        );
        return location;
      }

      function createPath(_ref) {
        let { pathname = "/", search = "", hash = "" } = _ref;
        if (search && search !== "?")
          pathname += search.charAt(0) === "?" ? search : "?" + search;
        if (hash && hash !== "#")
          pathname += hash.charAt(0) === "#" ? hash : "#" + hash;
        return pathname;
      }

      function parsePath(path) {
        let parsedPath = {};
        if (path) {
          let hashIndex = path.indexOf("#");
          if (hashIndex >= 0) {
            parsedPath.hash = path.substr(hashIndex);
            path = path.substr(0, hashIndex);
          }
          let searchIndex = path.indexOf("?");
          if (searchIndex >= 0) {
            parsedPath.search = path.substr(searchIndex);
            path = path.substr(0, searchIndex);
          }
          if (path) {
            parsedPath.pathname = path;
          }
        }
        return parsedPath;
      }
      function getUrlBasedHistory(
        getLocation,
        createHref,
        validateLocation,
        options,
      ) {
        if (options === void 0) {
          options = {};
        }
        let { window = document.defaultView, v5Compat = false } = options;
        let globalHistory = window.history;
        let action = Action.Pop;
        let listener = null;
        let index = getIndex();
        // Index should only be null when we initialize. If not, it's because the
        // user called history.pushState or history.replaceState directly, in which
        // case we should log a warning as it will result in bugs.
        if (index == null) {
          index = 0;
          globalHistory.replaceState(
            _extends$1({}, globalHistory.state, {
              idx: index,
            }),
            "",
          );
        }
        function getIndex() {
          let state = globalHistory.state || {
            idx: null,
          };
          return state.idx;
        }
        function handlePop() {
          action = Action.Pop;
          let nextIndex = getIndex();
          let delta = nextIndex == null ? null : nextIndex - index;
          index = nextIndex;
          if (listener) {
            listener({
              action,
              location: history.location,
              delta,
            });
          }
        }
        function push(to, state) {
          action = Action.Push;
          let location = createLocation(history.location, to, state);
          if (validateLocation) validateLocation(location, to);
          index = getIndex() + 1;
          let historyState = getHistoryState(location, index);
          let url = history.createHref(location);
          // try...catch because iOS limits us to 100 pushState calls :/
          try {
            globalHistory.pushState(historyState, "", url);
          } catch (error) {
            // If the exception is because `state` can't be serialized, let that throw
            // outwards just like a replace call would so the dev knows the cause
            // https://html.spec.whatwg.org/multipage/nav-history-apis.html#shared-history-push/replace-state-steps
            // https://html.spec.whatwg.org/multipage/structured-data.html#structuredserializeinternal
            if (
              error instanceof DOMException &&
              error.name === "DataCloneError"
            ) {
              throw error;
            }
            // They are going to lose state here, but there is no real
            // way to warn them about it since the page will refresh...
            window.location.assign(url);
          }
          if (v5Compat && listener) {
            listener({
              action,
              location: history.location,
              delta: 1,
            });
          }
        }
        function replace(to, state) {
          action = Action.Replace;
          let location = createLocation(history.location, to, state);
          if (validateLocation) validateLocation(location, to);
          index = getIndex();
          let historyState = getHistoryState(location, index);
          let url = history.createHref(location);
          globalHistory.replaceState(historyState, "", url);
          if (v5Compat && listener) {
            listener({
              action,
              location: history.location,
              delta: 0,
            });
          }
        }
        function createURL(to) {
          // window.location.origin is "null" (the literal string value) in Firefox
          // under certain conditions, notably when serving from a local HTML file
          // See https://bugzilla.mozilla.org/show_bug.cgi?id=878297
          let base =
            window.location.origin !== "null"
              ? window.location.origin
              : window.location.href;
          let href = typeof to === "string" ? to : createPath(to);
          // Treating this as a full URL will strip any trailing spaces so we need to
          // pre-encode them since they might be part of a matching splat param from
          // an ancestor route
          href = href.replace(/ $/, "%20");
          invariant$1(
            base,
            "No window.location.(origin|href) available to create URL for href: " +
              href,
          );
          return new URL(href, base);
        }
        let history = {
          get action() {
            return action;
          },
          get location() {
            return getLocation(window, globalHistory);
          },
          listen(fn) {
            if (listener) {
              throw new Error("A history only accepts one active listener");
            }
            window.addEventListener(PopStateEventType, handlePop);
            listener = fn;
            return () => {
              window.removeEventListener(PopStateEventType, handlePop);
              listener = null;
            };
          },
          createHref(to) {
            return createHref(window, to);
          },
          createURL,
          encodeLocation(to) {
            // Encode a Location the same way window.location would
            let url = createURL(to);
            return {
              pathname: url.pathname,
              search: url.search,
              hash: url.hash,
            };
          },
          push,
          replace,
          go(n) {
            return globalHistory.go(n);
          },
        };
        return history;
      }
      //#endregion

      var ResultType;
      (function (ResultType) {
        ResultType["data"] = "data";
        ResultType["deferred"] = "deferred";
        ResultType["redirect"] = "redirect";
        ResultType["error"] = "error";
      })(ResultType || (ResultType = {}));

      function matchRoutes(routes, locationArg, basename) {
        if (basename === void 0) {
          basename = "/";
        }
        return matchRoutesImpl(routes, locationArg, basename);
      }
      function matchRoutesImpl(routes, locationArg, basename, allowPartial) {
        let location =
          typeof locationArg === "string"
            ? parsePath(locationArg)
            : locationArg;
        let pathname = stripBasename(location.pathname || "/", basename);
        if (pathname == null) {
          return null;
        }
        let branches = flattenRoutes(routes);
        rankRouteBranches(branches);
        let matches = null;
        for (let i = 0; matches == null && i < branches.length; ++i) {
          // Incoming pathnames are generally encoded from either window.location
          // or from router.navigate, but we want to match against the unencoded
          // paths in the route definitions.  Memory router locations won't be
          // encoded here but there also shouldn't be anything to decode so this
          // should be a safe operation.  This avoids needing matchRoutes to be
          // history-aware.
          let decoded = decodePath(pathname);
          matches = matchRouteBranch(branches[i], decoded);
        }
        return matches;
      }
      function flattenRoutes(routes, branches, parentsMeta, parentPath) {
        if (branches === void 0) {
          branches = [];
        }
        if (parentsMeta === void 0) {
          parentsMeta = [];
        }
        if (parentPath === void 0) {
          parentPath = "";
        }
        let flattenRoute = (route, index, relativePath) => {
          let meta = {
            relativePath:
              relativePath === undefined ? route.path || "" : relativePath,
            caseSensitive: route.caseSensitive === true,
            childrenIndex: index,
            route,
          };
          if (meta.relativePath.startsWith("/")) {
            invariant$1(
              meta.relativePath.startsWith(parentPath),
              'Absolute route path "' +
                meta.relativePath +
                '" nested under path ' +
                ('"' +
                  parentPath +
                  '" is not valid. An absolute child route path ') +
                "must start with the combined path of all its parent routes.",
            );
            meta.relativePath = meta.relativePath.slice(parentPath.length);
          }
          let path = joinPaths([parentPath, meta.relativePath]);
          let routesMeta = parentsMeta.concat(meta);
          // Add the children before adding this route to the array, so we traverse the
          // route tree depth-first and child routes appear before their parents in
          // the "flattened" version.
          if (route.children && route.children.length > 0) {
            invariant$1(
              // Our types know better, but runtime JS may not!
              // @ts-expect-error
              route.index !== true,
              "Index routes must not have child routes. Please remove " +
                ('all child routes from route path "' + path + '".'),
            );
            flattenRoutes(route.children, branches, routesMeta, path);
          }
          // Routes without a path shouldn't ever match by themselves unless they are
          // index routes, so don't add them to the list of possible branches.
          if (route.path == null && !route.index) {
            return;
          }
          branches.push({
            path,
            score: computeScore(path, route.index),
            routesMeta,
          });
        };
        routes.forEach((route, index) => {
          var _route$path;
          // coarse-grain check for optional params
          if (
            route.path === "" ||
            !((_route$path = route.path) != null && _route$path.includes("?"))
          ) {
            flattenRoute(route, index);
          } else {
            for (let exploded of explodeOptionalSegments(route.path)) {
              flattenRoute(route, index, exploded);
            }
          }
        });
        return branches;
      }

      function explodeOptionalSegments(path) {
        let segments = path.split("/");
        if (segments.length === 0) return [];
        let [first, ...rest] = segments;
        // Optional path segments are denoted by a trailing `?`
        let isOptional = first.endsWith("?");
        // Compute the corresponding required segment: `foo?` -> `foo`
        let required = first.replace(/\?$/, "");
        if (rest.length === 0) {
          // Intepret empty string as omitting an optional segment
          // `["one", "", "three"]` corresponds to omitting `:two` from `/one/:two?/three` -> `/one/three`
          return isOptional ? [required, ""] : [required];
        }
        let restExploded = explodeOptionalSegments(rest.join("/"));
        let result = [];
        // All child paths with the prefix.  Do this for all children before the
        // optional version for all children, so we get consistent ordering where the
        // parent optional aspect is preferred as required.  Otherwise, we can get
        // child sections interspersed where deeper optional segments are higher than
        // parent optional segments, where for example, /:two would explode _earlier_
        // then /:one.  By always including the parent as required _for all children_
        // first, we avoid this issue
        result.push(
          ...restExploded.map((subpath) =>
            subpath === "" ? required : [required, subpath].join("/"),
          ),
        );
        // Then, if this is an optional value, add all child versions without
        if (isOptional) {
          result.push(...restExploded);
        }
        // for absolute paths, ensure `/` instead of empty segment
        return result.map((exploded) =>
          path.startsWith("/") && exploded === "" ? "/" : exploded,
        );
      }
      function rankRouteBranches(branches) {
        branches.sort((a, b) =>
          a.score !== b.score
            ? b.score - a.score // Higher score first
            : compareIndexes(
                a.routesMeta.map((meta) => meta.childrenIndex),
                b.routesMeta.map((meta) => meta.childrenIndex),
              ),
        );
      }
      const paramRe = /^:[\w-]+$/;
      const dynamicSegmentValue = 3;
      const indexRouteValue = 2;
      const emptySegmentValue = 1;
      const staticSegmentValue = 10;
      const splatPenalty = -2;
      const isSplat = (s) => s === "*";
      function computeScore(path, index) {
        let segments = path.split("/");
        let initialScore = segments.length;
        if (segments.some(isSplat)) {
          initialScore += splatPenalty;
        }
        if (index) {
          initialScore += indexRouteValue;
        }
        return segments
          .filter((s) => !isSplat(s))
          .reduce(
            (score, segment) =>
              score +
              (paramRe.test(segment)
                ? dynamicSegmentValue
                : segment === ""
                  ? emptySegmentValue
                  : staticSegmentValue),
            initialScore,
          );
      }
      function compareIndexes(a, b) {
        let siblings =
          a.length === b.length && a.slice(0, -1).every((n, i) => n === b[i]);
        return siblings
          ? // If two routes are siblings, we should try to match the earlier sibling
            // first. This allows people to have fine-grained control over the matching
            // behavior by simply putting routes with identical paths in the order they
            // want them tried.
            a[a.length - 1] - b[b.length - 1]
          : // Otherwise, it doesn't really make sense to rank non-siblings by index,
            // so they sort equally.
            0;
      }
      function matchRouteBranch(branch, pathname, allowPartial) {
        let { routesMeta } = branch;
        let matchedParams = {};
        let matchedPathname = "/";
        let matches = [];
        for (let i = 0; i < routesMeta.length; ++i) {
          let meta = routesMeta[i];
          let end = i === routesMeta.length - 1;
          let remainingPathname =
            matchedPathname === "/"
              ? pathname
              : pathname.slice(matchedPathname.length) || "/";
          let match = matchPath(
            {
              path: meta.relativePath,
              caseSensitive: meta.caseSensitive,
              end,
            },
            remainingPathname,
          );
          let route = meta.route;
          if (!match) {
            return null;
          }
          Object.assign(matchedParams, match.params);
          matches.push({
            // TODO: Can this as be avoided?
            params: matchedParams,
            pathname: joinPaths([matchedPathname, match.pathname]),
            pathnameBase: normalizePathname(
              joinPaths([matchedPathname, match.pathnameBase]),
            ),
            route,
          });
          if (match.pathnameBase !== "/") {
            matchedPathname = joinPaths([matchedPathname, match.pathnameBase]);
          }
        }
        return matches;
      }

      function matchPath(pattern, pathname) {
        if (typeof pattern === "string") {
          pattern = {
            path: pattern,
            caseSensitive: false,
            end: true,
          };
        }
        let [matcher, compiledParams] = compilePath(
          pattern.path,
          pattern.caseSensitive,
          pattern.end,
        );
        let match = pathname.match(matcher);
        if (!match) return null;
        let matchedPathname = match[0];
        let pathnameBase = matchedPathname.replace(/(.)\/+$/, "$1");
        let captureGroups = match.slice(1);
        let params = compiledParams.reduce((memo, _ref, index) => {
          let { paramName, isOptional } = _ref;
          // We need to compute the pathnameBase here using the raw splat value
          // instead of using params["*"] later because it will be decoded then
          if (paramName === "*") {
            let splatValue = captureGroups[index] || "";
            pathnameBase = matchedPathname
              .slice(0, matchedPathname.length - splatValue.length)
              .replace(/(.)\/+$/, "$1");
          }
          const value = captureGroups[index];
          if (isOptional && !value) {
            memo[paramName] = undefined;
          } else {
            memo[paramName] = (value || "").replace(/%2F/g, "/");
          }
          return memo;
        }, {});
        return {
          params,
          pathname: matchedPathname,
          pathnameBase,
          pattern,
        };
      }
      function compilePath(path, caseSensitive, end) {
        if (caseSensitive === void 0) {
          caseSensitive = false;
        }
        if (end === void 0) {
          end = true;
        }
        warning(
          path === "*" || !path.endsWith("*") || path.endsWith("/*"),
          'Route path "' +
            path +
            '" will be treated as if it were ' +
            ('"' +
              path.replace(/\*$/, "/*") +
              '" because the `*` character must ') +
            "always follow a `/` in the pattern. To get rid of this warning, " +
            ('please change the route path to "' +
              path.replace(/\*$/, "/*") +
              '".'),
        );
        let params = [];
        let regexpSource =
          "^" +
          path
            .replace(/\/*\*?$/, "") // Ignore trailing / and /*, we'll handle it below
            .replace(/^\/*/, "/") // Make sure it has a leading /
            .replace(/[\\.*+^${}|()[\]]/g, "\\$&") // Escape special regex chars
            .replace(/\/:([\w-]+)(\?)?/g, (_, paramName, isOptional) => {
              params.push({
                paramName,
                isOptional: isOptional != null,
              });
              return isOptional ? "/?([^\\/]+)?" : "/([^\\/]+)";
            });
        if (path.endsWith("*")) {
          params.push({
            paramName: "*",
          });
          regexpSource +=
            path === "*" || path === "/*"
              ? "(.*)$" // Already matched the initial /, just match the rest
              : "(?:\\/(.+)|\\/*)$"; // Don't include the / in params["*"]
        } else if (end) {
          // When matching to the end, ignore trailing slashes
          regexpSource += "\\/*$";
        } else if (path !== "" && path !== "/") {
          // If our path is non-empty and contains anything beyond an initial slash,
          // then we have _some_ form of path in our regex, so we should expect to
          // match only if we find the end of this path segment.  Look for an optional
          // non-captured trailing slash (to match a portion of the URL) or the end
          // of the path (if we've matched to the end).  We used to do this with a
          // word boundary but that gives false positives on routes like
          // /user-preferences since `-` counts as a word boundary.
          regexpSource += "(?:(?=\\/|$))";
        } else;
        let matcher = new RegExp(regexpSource, caseSensitive ? undefined : "i");
        return [matcher, params];
      }
      function decodePath(value) {
        try {
          return value
            .split("/")
            .map((v) => decodeURIComponent(v).replace(/\//g, "%2F"))
            .join("/");
        } catch (error) {
          warning(
            false,
            'The URL path "' +
              value +
              '" could not be decoded because it is is a ' +
              "malformed URL segment. This is probably due to a bad percent " +
              ("encoding (" + error + ")."),
          );
          return value;
        }
      }

      function stripBasename(pathname, basename) {
        if (basename === "/") return pathname;
        if (!pathname.toLowerCase().startsWith(basename.toLowerCase())) {
          return null;
        }
        // We want to leave trailing slash behavior in the user's control, so if they
        // specify a basename with a trailing slash, we should support it
        let startIndex = basename.endsWith("/")
          ? basename.length - 1
          : basename.length;
        let nextChar = pathname.charAt(startIndex);
        if (nextChar && nextChar !== "/") {
          // pathname does not start with basename/
          return null;
        }
        return pathname.slice(startIndex) || "/";
      }

      const joinPaths = (paths) => paths.join("/").replace(/\/\/+/g, "/");

      const normalizePathname = (pathname) =>
        pathname.replace(/\/+$/, "").replace(/^\/*/, "/");

      function isRouteErrorResponse(error) {
        return (
          error != null &&
          typeof error.status === "number" &&
          typeof error.statusText === "string" &&
          typeof error.internal === "boolean" &&
          "data" in error
        );
      }

      const validMutationMethodsArr = ["post", "put", "patch", "delete"];
      new Set(validMutationMethodsArr);
      const validRequestMethodsArr = ["get", ...validMutationMethodsArr];
      new Set(validRequestMethodsArr);

      function _extends() {
        _extends = Object.assign
          ? Object.assign.bind()
          : function (target) {
              for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i];
                for (var key in source) {
                  if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                  }
                }
              }
              return target;
            };
        return _extends.apply(this, arguments);
      }
      const DataRouterContext =
        /* @__PURE__ */ reactExports.createContext(null);
      const DataRouterStateContext =
        /* @__PURE__ */ reactExports.createContext(null);
      const NavigationContext =
        /* @__PURE__ */ reactExports.createContext(null);
      const LocationContext = /* @__PURE__ */ reactExports.createContext(null);
      const RouteContext = /* @__PURE__ */ reactExports.createContext({
        outlet: null,
        matches: [],
        isDataRoute: false,
      });
      const RouteErrorContext =
        /* @__PURE__ */ reactExports.createContext(null);
      function useInRouterContext() {
        return reactExports.useContext(LocationContext) != null;
      }
      function useLocation() {
        !useInRouterContext() ? invariant$1(false) : void 0;
        return reactExports.useContext(LocationContext).location;
      }
      function useRoutes(routes, locationArg) {
        return useRoutesImpl(routes, locationArg);
      }
      function useRoutesImpl(routes, locationArg, dataRouterState, future) {
        !useInRouterContext() ? invariant$1(false) : void 0;
        let { navigator } = reactExports.useContext(NavigationContext);
        let { matches: parentMatches } = reactExports.useContext(RouteContext);
        let routeMatch = parentMatches[parentMatches.length - 1];
        let parentParams = routeMatch ? routeMatch.params : {};
        routeMatch ? routeMatch.pathname : "/";
        let parentPathnameBase = routeMatch ? routeMatch.pathnameBase : "/";
        routeMatch && routeMatch.route;
        let locationFromContext = useLocation();
        let location;
        if (locationArg) {
          var _parsedLocationArg$pa;
          let parsedLocationArg =
            typeof locationArg === "string"
              ? parsePath(locationArg)
              : locationArg;
          !(
            parentPathnameBase === "/" ||
            ((_parsedLocationArg$pa = parsedLocationArg.pathname) == null
              ? void 0
              : _parsedLocationArg$pa.startsWith(parentPathnameBase))
          )
            ? invariant$1(false)
            : void 0;
          location = parsedLocationArg;
        } else {
          location = locationFromContext;
        }
        let pathname = location.pathname || "/";
        let remainingPathname = pathname;
        if (parentPathnameBase !== "/") {
          let parentSegments = parentPathnameBase.replace(/^\//, "").split("/");
          let segments = pathname.replace(/^\//, "").split("/");
          remainingPathname =
            "/" + segments.slice(parentSegments.length).join("/");
        }
        let matches = matchRoutes(routes, {
          pathname: remainingPathname,
        });
        let renderedMatches = _renderMatches(
          matches &&
            matches.map((match) =>
              Object.assign({}, match, {
                params: Object.assign({}, parentParams, match.params),
                pathname: joinPaths([
                  parentPathnameBase,
                  // Re-encode pathnames that were decoded inside matchRoutes
                  navigator.encodeLocation
                    ? navigator.encodeLocation(match.pathname).pathname
                    : match.pathname,
                ]),
                pathnameBase:
                  match.pathnameBase === "/"
                    ? parentPathnameBase
                    : joinPaths([
                        parentPathnameBase,
                        // Re-encode pathnames that were decoded inside matchRoutes
                        navigator.encodeLocation
                          ? navigator.encodeLocation(match.pathnameBase)
                              .pathname
                          : match.pathnameBase,
                      ]),
              }),
            ),
          parentMatches,
          dataRouterState,
          future,
        );
        if (locationArg && renderedMatches) {
          return /* @__PURE__ */ reactExports.createElement(
            LocationContext.Provider,
            {
              value: {
                location: _extends(
                  {
                    pathname: "/",
                    search: "",
                    hash: "",
                    state: null,
                    key: "default",
                  },
                  location,
                ),
                navigationType: Action.Pop,
              },
            },
            renderedMatches,
          );
        }
        return renderedMatches;
      }
      function DefaultErrorComponent() {
        let error = useRouteError();
        let message = isRouteErrorResponse(error)
          ? error.status + " " + error.statusText
          : error instanceof Error
            ? error.message
            : JSON.stringify(error);
        let stack = error instanceof Error ? error.stack : null;
        let lightgrey = "rgba(200,200,200, 0.5)";
        let preStyles = {
          padding: "0.5rem",
          backgroundColor: lightgrey,
        };
        let devInfo = null;
        return /* @__PURE__ */ reactExports.createElement(
          reactExports.Fragment,
          null,
          /* @__PURE__ */ reactExports.createElement(
            "h2",
            null,
            "Unexpected Application Error!",
          ),
          /* @__PURE__ */ reactExports.createElement(
            "h3",
            {
              style: {
                fontStyle: "italic",
              },
            },
            message,
          ),
          stack
            ? /* @__PURE__ */ reactExports.createElement(
                "pre",
                {
                  style: preStyles,
                },
                stack,
              )
            : null,
          devInfo,
        );
      }
      const defaultErrorElement = /* @__PURE__ */ reactExports.createElement(
        DefaultErrorComponent,
        null,
      );
      class RenderErrorBoundary extends reactExports.Component {
        constructor(props) {
          super(props);
          this.state = {
            location: props.location,
            revalidation: props.revalidation,
            error: props.error,
          };
        }
        static getDerivedStateFromError(error) {
          return {
            error,
          };
        }
        static getDerivedStateFromProps(props, state) {
          if (
            state.location !== props.location ||
            (state.revalidation !== "idle" && props.revalidation === "idle")
          ) {
            return {
              error: props.error,
              location: props.location,
              revalidation: props.revalidation,
            };
          }
          return {
            error: props.error !== void 0 ? props.error : state.error,
            location: state.location,
            revalidation: props.revalidation || state.revalidation,
          };
        }
        componentDidCatch(error, errorInfo) {
          console.error(
            "React Router caught the following error during render",
            error,
            errorInfo,
          );
        }
        render() {
          return this.state.error !== void 0
            ? /* @__PURE__ */ reactExports.createElement(
                RouteContext.Provider,
                {
                  value: this.props.routeContext,
                },
                /* @__PURE__ */ reactExports.createElement(
                  RouteErrorContext.Provider,
                  {
                    value: this.state.error,
                    children: this.props.component,
                  },
                ),
              )
            : this.props.children;
        }
      }
      function RenderedRoute(_ref) {
        let { routeContext, match, children } = _ref;
        let dataRouterContext = reactExports.useContext(DataRouterContext);
        if (
          dataRouterContext &&
          dataRouterContext.static &&
          dataRouterContext.staticContext &&
          (match.route.errorElement || match.route.ErrorBoundary)
        ) {
          dataRouterContext.staticContext._deepestRenderedBoundaryId =
            match.route.id;
        }
        return /* @__PURE__ */ reactExports.createElement(
          RouteContext.Provider,
          {
            value: routeContext,
          },
          children,
        );
      }
      function _renderMatches(matches, parentMatches, dataRouterState, future) {
        var _dataRouterState;
        if (parentMatches === void 0) {
          parentMatches = [];
        }
        if (dataRouterState === void 0) {
          dataRouterState = null;
        }
        if (future === void 0) {
          future = null;
        }
        if (matches == null) {
          var _future;
          if (!dataRouterState) {
            return null;
          }
          if (dataRouterState.errors) {
            matches = dataRouterState.matches;
          } else if (
            (_future = future) != null &&
            _future.v7_partialHydration &&
            parentMatches.length === 0 &&
            !dataRouterState.initialized &&
            dataRouterState.matches.length > 0
          ) {
            matches = dataRouterState.matches;
          } else {
            return null;
          }
        }
        let renderedMatches = matches;
        let errors =
          (_dataRouterState = dataRouterState) == null
            ? void 0
            : _dataRouterState.errors;
        if (errors != null) {
          let errorIndex = renderedMatches.findIndex(
            (m) =>
              m.route.id &&
              (errors == null ? void 0 : errors[m.route.id]) !== void 0,
          );
          !(errorIndex >= 0) ? invariant$1(false) : void 0;
          renderedMatches = renderedMatches.slice(
            0,
            Math.min(renderedMatches.length, errorIndex + 1),
          );
        }
        let renderFallback = false;
        let fallbackIndex = -1;
        if (dataRouterState && future && future.v7_partialHydration) {
          for (let i = 0; i < renderedMatches.length; i++) {
            let match = renderedMatches[i];
            if (
              match.route.HydrateFallback ||
              match.route.hydrateFallbackElement
            ) {
              fallbackIndex = i;
            }
            if (match.route.id) {
              let { loaderData, errors: errors2 } = dataRouterState;
              let needsToRunLoader =
                match.route.loader &&
                loaderData[match.route.id] === void 0 &&
                (!errors2 || errors2[match.route.id] === void 0);
              if (match.route.lazy || needsToRunLoader) {
                renderFallback = true;
                if (fallbackIndex >= 0) {
                  renderedMatches = renderedMatches.slice(0, fallbackIndex + 1);
                } else {
                  renderedMatches = [renderedMatches[0]];
                }
                break;
              }
            }
          }
        }
        return renderedMatches.reduceRight((outlet, match, index) => {
          let error;
          let shouldRenderHydrateFallback = false;
          let errorElement = null;
          let hydrateFallbackElement = null;
          if (dataRouterState) {
            error = errors && match.route.id ? errors[match.route.id] : void 0;
            errorElement = match.route.errorElement || defaultErrorElement;
            if (renderFallback) {
              if (fallbackIndex < 0 && index === 0) {
                warningOnce("route-fallback");
                shouldRenderHydrateFallback = true;
                hydrateFallbackElement = null;
              } else if (fallbackIndex === index) {
                shouldRenderHydrateFallback = true;
                hydrateFallbackElement =
                  match.route.hydrateFallbackElement || null;
              }
            }
          }
          let matches2 = parentMatches.concat(
            renderedMatches.slice(0, index + 1),
          );
          let getChildren = () => {
            let children;
            if (error) {
              children = errorElement;
            } else if (shouldRenderHydrateFallback) {
              children = hydrateFallbackElement;
            } else if (match.route.Component) {
              children = /* @__PURE__ */ reactExports.createElement(
                match.route.Component,
                null,
              );
            } else if (match.route.element) {
              children = match.route.element;
            } else {
              children = outlet;
            }
            return /* @__PURE__ */ reactExports.createElement(RenderedRoute, {
              match,
              routeContext: {
                outlet,
                matches: matches2,
                isDataRoute: dataRouterState != null,
              },
              children,
            });
          };
          return dataRouterState &&
            (match.route.ErrorBoundary ||
              match.route.errorElement ||
              index === 0)
            ? /* @__PURE__ */ reactExports.createElement(RenderErrorBoundary, {
                location: dataRouterState.location,
                revalidation: dataRouterState.revalidation,
                component: errorElement,
                error,
                children: getChildren(),
                routeContext: {
                  outlet: null,
                  matches: matches2,
                  isDataRoute: true,
                },
              })
            : getChildren();
        }, null);
      }
      var DataRouterStateHook$1 = /* @__PURE__ */ (function (
        DataRouterStateHook2,
      ) {
        DataRouterStateHook2["UseBlocker"] = "useBlocker";
        DataRouterStateHook2["UseLoaderData"] = "useLoaderData";
        DataRouterStateHook2["UseActionData"] = "useActionData";
        DataRouterStateHook2["UseRouteError"] = "useRouteError";
        DataRouterStateHook2["UseNavigation"] = "useNavigation";
        DataRouterStateHook2["UseRouteLoaderData"] = "useRouteLoaderData";
        DataRouterStateHook2["UseMatches"] = "useMatches";
        DataRouterStateHook2["UseRevalidator"] = "useRevalidator";
        DataRouterStateHook2["UseNavigateStable"] = "useNavigate";
        DataRouterStateHook2["UseRouteId"] = "useRouteId";
        return DataRouterStateHook2;
      })(DataRouterStateHook$1 || {});
      function useDataRouterState(hookName) {
        let state = reactExports.useContext(DataRouterStateContext);
        !state ? invariant$1(false) : void 0;
        return state;
      }
      function useRouteContext(hookName) {
        let route = reactExports.useContext(RouteContext);
        !route ? invariant$1(false) : void 0;
        return route;
      }
      function useCurrentRouteId(hookName) {
        let route = useRouteContext();
        let thisRoute = route.matches[route.matches.length - 1];
        !thisRoute.route.id ? invariant$1(false) : void 0;
        return thisRoute.route.id;
      }
      function useRouteError() {
        var _state$errors;
        let error = reactExports.useContext(RouteErrorContext);
        let state = useDataRouterState(DataRouterStateHook$1.UseRouteError);
        let routeId = useCurrentRouteId();
        if (error !== void 0) {
          return error;
        }
        return (_state$errors = state.errors) == null
          ? void 0
          : _state$errors[routeId];
      }
      const alreadyWarned$1 = {};
      function warningOnce(key, cond, message) {
        if (!alreadyWarned$1[key]) {
          alreadyWarned$1[key] = true;
        }
      }
      function logV6DeprecationWarnings(renderFuture, routerFuture) {
        if (
          (renderFuture == null ? void 0 : renderFuture.v7_startTransition) ===
          void 0
        );
        if (
          (renderFuture == null
            ? void 0
            : renderFuture.v7_relativeSplatPath) === void 0 &&
          true
        );
      }
      function Route(_props) {
        invariant$1(false);
      }
      function Router(_ref5) {
        let {
          basename: basenameProp = "/",
          children = null,
          location: locationProp,
          navigationType = Action.Pop,
          navigator,
          static: staticProp = false,
          future,
        } = _ref5;
        !!useInRouterContext() ? invariant$1(false) : void 0;
        let basename = basenameProp.replace(/^\/*/, "/");
        let navigationContext = reactExports.useMemo(
          () => ({
            basename,
            navigator,
            static: staticProp,
            future: _extends(
              {
                v7_relativeSplatPath: false,
              },
              future,
            ),
          }),
          [basename, future, navigator, staticProp],
        );
        if (typeof locationProp === "string") {
          locationProp = parsePath(locationProp);
        }
        let {
          pathname = "/",
          search = "",
          hash = "",
          state = null,
          key = "default",
        } = locationProp;
        let locationContext = reactExports.useMemo(() => {
          let trailingPathname = stripBasename(pathname, basename);
          if (trailingPathname == null) {
            return null;
          }
          return {
            location: {
              pathname: trailingPathname,
              search,
              hash,
              state,
              key,
            },
            navigationType,
          };
        }, [basename, pathname, search, hash, state, key, navigationType]);
        if (locationContext == null) {
          return null;
        }
        return /* @__PURE__ */ reactExports.createElement(
          NavigationContext.Provider,
          {
            value: navigationContext,
          },
          /* @__PURE__ */ reactExports.createElement(LocationContext.Provider, {
            children,
            value: locationContext,
          }),
        );
      }
      function Routes(_ref6) {
        let { children, location } = _ref6;
        return useRoutes(createRoutesFromChildren(children), location);
      }
      new Promise(() => {});
      function createRoutesFromChildren(children, parentPath) {
        if (parentPath === void 0) {
          parentPath = [];
        }
        let routes = [];
        reactExports.Children.forEach(children, (element, index) => {
          if (!(/* @__PURE__ */ reactExports.isValidElement(element))) {
            return;
          }
          let treePath = [...parentPath, index];
          if (element.type === reactExports.Fragment) {
            routes.push.apply(
              routes,
              createRoutesFromChildren(element.props.children, treePath),
            );
            return;
          }
          !(element.type === Route) ? invariant$1(false) : void 0;
          !(!element.props.index || !element.props.children)
            ? invariant$1(false)
            : void 0;
          let route = {
            id: element.props.id || treePath.join("-"),
            caseSensitive: element.props.caseSensitive,
            element: element.props.element,
            Component: element.props.Component,
            index: element.props.index,
            path: element.props.path,
            loader: element.props.loader,
            action: element.props.action,
            errorElement: element.props.errorElement,
            ErrorBoundary: element.props.ErrorBoundary,
            hasErrorBoundary:
              element.props.ErrorBoundary != null ||
              element.props.errorElement != null,
            shouldRevalidate: element.props.shouldRevalidate,
            handle: element.props.handle,
            lazy: element.props.lazy,
          };
          if (element.props.children) {
            route.children = createRoutesFromChildren(
              element.props.children,
              treePath,
            );
          }
          routes.push(route);
        });
        return routes;
      }

      const REACT_ROUTER_VERSION = "6";
      try {
        window.__reactRouterVersion = REACT_ROUTER_VERSION;
      } catch (e) {}
      const START_TRANSITION = "startTransition";
      const startTransitionImpl = React$1[START_TRANSITION];
      function HashRouter(_ref5) {
        let { basename, children, future, window: window2 } = _ref5;
        let historyRef = reactExports.useRef();
        if (historyRef.current == null) {
          historyRef.current = createHashHistory({
            window: window2,
            v5Compat: true,
          });
        }
        let history = historyRef.current;
        let [state, setStateImpl] = reactExports.useState({
          action: history.action,
          location: history.location,
        });
        let { v7_startTransition } = future || {};
        let setState = reactExports.useCallback(
          (newState) => {
            v7_startTransition && startTransitionImpl
              ? startTransitionImpl(() => setStateImpl(newState))
              : setStateImpl(newState);
          },
          [setStateImpl, v7_startTransition],
        );
        reactExports.useLayoutEffect(
          () => history.listen(setState),
          [history, setState],
        );
        reactExports.useEffect(
          () => logV6DeprecationWarnings(future),
          [future],
        );
        return /* @__PURE__ */ reactExports.createElement(Router, {
          basename,
          children,
          location: state.location,
          navigationType: state.action,
          navigator: history,
          future,
        });
      }
      var DataRouterHook;
      (function (DataRouterHook2) {
        DataRouterHook2["UseScrollRestoration"] = "useScrollRestoration";
        DataRouterHook2["UseSubmit"] = "useSubmit";
        DataRouterHook2["UseSubmitFetcher"] = "useSubmitFetcher";
        DataRouterHook2["UseFetcher"] = "useFetcher";
        DataRouterHook2["useViewTransitionState"] = "useViewTransitionState";
      })(DataRouterHook || (DataRouterHook = {}));
      var DataRouterStateHook;
      (function (DataRouterStateHook2) {
        DataRouterStateHook2["UseFetcher"] = "useFetcher";
        DataRouterStateHook2["UseFetchers"] = "useFetchers";
        DataRouterStateHook2["UseScrollRestoration"] = "useScrollRestoration";
      })(DataRouterStateHook || (DataRouterStateHook = {}));

      const LayoutGroupContext = reactExports.createContext({});

      function useConstant(init) {
        const ref = reactExports.useRef(null);
        if (ref.current === null) {
          ref.current = init();
        }
        return ref.current;
      }

      const isBrowser$1 = typeof window !== "undefined";

      const useIsomorphicLayoutEffect = isBrowser$1
        ? reactExports.useLayoutEffect
        : reactExports.useEffect;

      const PresenceContext = /* @__PURE__ */ reactExports.createContext(null);

      function addUniqueItem(arr, item) {
        if (arr.indexOf(item) === -1) arr.push(item);
      }
      function removeItem(arr, item) {
        const index = arr.indexOf(item);
        if (index > -1) arr.splice(index, 1);
      }

      const clamp = (min, max, v) => {
        if (v > max) return max;
        if (v < min) return min;
        return v;
      };

      let invariant = () => {};

      const MotionGlobalConfig = {};

      const isNumericalString = (v) => /^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(v);

      function isObject(value) {
        return typeof value === "object" && value !== null;
      }

      const isZeroValueString = (v) => /^0[^.\s]+$/u.test(v);

      /*#__NO_SIDE_EFFECTS__*/
      function memo(callback) {
        let result;
        return () => {
          if (result === undefined) result = callback();
          return result;
        };
      }

      /*#__NO_SIDE_EFFECTS__*/
      const noop = (any) => any;

      const combineFunctions = (a, b) => (v) => b(a(v));
      const pipe = (...transformers) => transformers.reduce(combineFunctions);

      /*
  Progress within given range

  Given a lower limit and an upper limit, we return the progress
  (expressed as a number 0-1) represented by the given value, and
  limit that progress to within 0-1.

  @param [number]: Lower limit
  @param [number]: Upper limit
  @param [number]: Value to find progress within given range
  @return [number]: Progress of value within range as expressed 0-1
*/
      /*#__NO_SIDE_EFFECTS__*/
      const progress = (from, to, value) => {
        const toFromDifference = to - from;
        return toFromDifference === 0 ? 1 : (value - from) / toFromDifference;
      };

      class SubscriptionManager {
        constructor() {
          this.subscriptions = [];
        }
        add(handler) {
          addUniqueItem(this.subscriptions, handler);
          return () => removeItem(this.subscriptions, handler);
        }
        notify(a, b, c) {
          const numSubscriptions = this.subscriptions.length;
          if (!numSubscriptions) return;
          if (numSubscriptions === 1) {
            this.subscriptions[0](a, b, c);
          } else {
            for (let i = 0; i < numSubscriptions; i++) {
              const handler = this.subscriptions[i];
              handler && handler(a, b, c);
            }
          }
        }
        getSize() {
          return this.subscriptions.length;
        }
        clear() {
          this.subscriptions.length = 0;
        }
      }

      /*#__NO_SIDE_EFFECTS__*/
      const secondsToMilliseconds = (seconds) => seconds * 1000;
      /*#__NO_SIDE_EFFECTS__*/
      const millisecondsToSeconds = (milliseconds) => milliseconds / 1000;

      /*
  Convert velocity into velocity per second

  @param [number]: Unit per frame
  @param [number]: Frame duration in ms
*/
      function velocityPerSecond(velocity, frameDuration) {
        return frameDuration ? velocity * (1000 / frameDuration) : 0;
      }

      /*
  Bezier function generator
  This has been modified from Gaëtan Renaudeau's BezierEasing
  https://github.com/gre/bezier-easing/blob/master/src/index.js
  https://github.com/gre/bezier-easing/blob/master/LICENSE
  
  I've removed the newtonRaphsonIterate algo because in benchmarking it
  wasn't noticeably faster than binarySubdivision, indeed removing it
  usually improved times, depending on the curve.
  I also removed the lookup table, as for the added bundle size and loop we're
  only cutting ~4 or so subdivision iterations. I bumped the max iterations up
  to 12 to compensate and this still tended to be faster for no perceivable
  loss in accuracy.
  Usage
    const easeOut = cubicBezier(.17,.67,.83,.67);
    const x = easeOut(0.5); // returns 0.627...
*/
      // Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.
      const calcBezier = (t, a1, a2) =>
        (((1.0 - 3.0 * a2 + 3.0 * a1) * t + (3.0 * a2 - 6.0 * a1)) * t +
          3.0 * a1) *
        t;
      const subdivisionPrecision = 0.0000001;
      const subdivisionMaxIterations = 12;
      function binarySubdivide(x, lowerBound, upperBound, mX1, mX2) {
        let currentX;
        let currentT;
        let i = 0;
        do {
          currentT = lowerBound + (upperBound - lowerBound) / 2.0;
          currentX = calcBezier(currentT, mX1, mX2) - x;
          if (currentX > 0.0) {
            upperBound = currentT;
          } else {
            lowerBound = currentT;
          }
        } while (
          Math.abs(currentX) > subdivisionPrecision &&
          ++i < subdivisionMaxIterations
        );
        return currentT;
      }
      function cubicBezier(mX1, mY1, mX2, mY2) {
        // If this is a linear gradient, return linear easing
        if (mX1 === mY1 && mX2 === mY2) return noop;
        const getTForX = (aX) => binarySubdivide(aX, 0, 1, mX1, mX2);
        // If animation is at start/end, return t without easing
        return (t) =>
          t === 0 || t === 1 ? t : calcBezier(getTForX(t), mY1, mY2);
      }

      // Accepts an easing function and returns a new one that outputs mirrored values for
      // the second half of the animation. Turns easeIn into easeInOut.
      const mirrorEasing = (easing) => (p) =>
        p <= 0.5 ? easing(2 * p) / 2 : (2 - easing(2 * (1 - p))) / 2;

      // Accepts an easing function and returns a new one that outputs reversed values.
      // Turns easeIn into easeOut.
      const reverseEasing = (easing) => (p) => 1 - easing(1 - p);

      const backOut = /*@__PURE__*/ cubicBezier(0.33, 1.53, 0.69, 0.99);
      const backIn = /*@__PURE__*/ reverseEasing(backOut);
      const backInOut = /*@__PURE__*/ mirrorEasing(backIn);

      const anticipate = (p) =>
        (p *= 2) < 1 ? 0.5 * backIn(p) : 0.5 * (2 - Math.pow(2, -10 * (p - 1)));

      const circIn = (p) => 1 - Math.sin(Math.acos(p));
      const circOut = reverseEasing(circIn);
      const circInOut = mirrorEasing(circIn);

      const easeIn = /*@__PURE__*/ cubicBezier(0.42, 0, 1, 1);
      const easeOut = /*@__PURE__*/ cubicBezier(0, 0, 0.58, 1);
      const easeInOut = /*@__PURE__*/ cubicBezier(0.42, 0, 0.58, 1);

      const isEasingArray = (ease) => {
        return Array.isArray(ease) && typeof ease[0] !== "number";
      };

      const isBezierDefinition = (easing) =>
        Array.isArray(easing) && typeof easing[0] === "number";

      const easingLookup = {
        linear: noop,
        easeIn,
        easeInOut,
        easeOut,
        circIn,
        circInOut,
        circOut,
        backIn,
        backInOut,
        backOut,
        anticipate,
      };
      const isValidEasing = (easing) => {
        return typeof easing === "string";
      };
      const easingDefinitionToFunction = (definition) => {
        if (isBezierDefinition(definition)) {
          // If cubic bezier definition, create bezier curve
          invariant(definition.length === 4);
          const [x1, y1, x2, y2] = definition;
          return cubicBezier(x1, y1, x2, y2);
        } else if (isValidEasing(definition)) {
          return easingLookup[definition];
        }
        return definition;
      };

      const stepsOrder = [
        "setup", // Compute
        "read", // Read
        "resolveKeyframes", // Write/Read/Write/Read
        "preUpdate", // Compute
        "update", // Compute
        "preRender", // Compute
        "render", // Write
        "postRender", // Compute
      ];

      function createRenderStep(runNextFrame, stepName) {
        let thisFrame = new Set();
        let nextFrame = new Set();

        let isProcessing = false;
        let flushNextFrame = false;

        const toKeepAlive = new WeakSet();
        let latestFrameData = {
          delta: 0.0,
          timestamp: 0.0,
          isProcessing: false,
        };
        function triggerCallback(callback) {
          if (toKeepAlive.has(callback)) {
            step.schedule(callback);
            runNextFrame();
          }
          callback(latestFrameData);
        }
        const step = {
          schedule: (callback, keepAlive = false, immediate = false) => {
            const addToCurrentFrame = immediate && isProcessing;
            const queue = addToCurrentFrame ? thisFrame : nextFrame;
            if (keepAlive) toKeepAlive.add(callback);
            if (!queue.has(callback)) queue.add(callback);
            return callback;
          },

          cancel: (callback) => {
            nextFrame.delete(callback);
            toKeepAlive.delete(callback);
          },

          process: (frameData) => {
            latestFrameData = frameData;

            if (isProcessing) {
              flushNextFrame = true;
              return;
            }
            isProcessing = true;
            [thisFrame, nextFrame] = [nextFrame, thisFrame];
            // Execute this frame
            thisFrame.forEach(triggerCallback);
            // Clear the frame so no callbacks remain. This is to avoid
            // memory leaks should this render step not run for a while.
            thisFrame.clear();
            isProcessing = false;
            if (flushNextFrame) {
              flushNextFrame = false;
              step.process(frameData);
            }
          },
        };
        return step;
      }

      const maxElapsed = 40;
      function createRenderBatcher(scheduleNextBatch, allowKeepAlive) {
        let runNextFrame = false;
        let useDefaultElapsed = true;
        const state = {
          delta: 0.0,
          timestamp: 0.0,
          isProcessing: false,
        };
        const flagRunNextFrame = () => (runNextFrame = true);
        const steps = stepsOrder.reduce((acc, key) => {
          acc[key] = createRenderStep(flagRunNextFrame);
          return acc;
        }, {});
        const {
          setup,
          read,
          resolveKeyframes,
          preUpdate,
          update,
          preRender,
          render,
          postRender,
        } = steps;
        const processBatch = () => {
          const timestamp = MotionGlobalConfig.useManualTiming
            ? state.timestamp
            : performance.now();
          runNextFrame = false;
          if (!MotionGlobalConfig.useManualTiming) {
            state.delta = useDefaultElapsed
              ? 1000 / 60
              : Math.max(Math.min(timestamp - state.timestamp, maxElapsed), 1);
          }
          state.timestamp = timestamp;
          state.isProcessing = true;
          // Unrolled render loop for better per-frame performance
          setup.process(state);
          read.process(state);
          resolveKeyframes.process(state);
          preUpdate.process(state);
          update.process(state);
          preRender.process(state);
          render.process(state);
          postRender.process(state);
          state.isProcessing = false;
          if (runNextFrame && allowKeepAlive) {
            useDefaultElapsed = false;
            scheduleNextBatch(processBatch);
          }
        };
        const wake = () => {
          runNextFrame = true;
          useDefaultElapsed = true;
          if (!state.isProcessing) {
            scheduleNextBatch(processBatch);
          }
        };
        const schedule = stepsOrder.reduce((acc, key) => {
          const step = steps[key];
          acc[key] = (process, keepAlive = false, immediate = false) => {
            if (!runNextFrame) wake();
            return step.schedule(process, keepAlive, immediate);
          };
          return acc;
        }, {});
        const cancel = (process) => {
          for (let i = 0; i < stepsOrder.length; i++) {
            steps[stepsOrder[i]].cancel(process);
          }
        };
        return { schedule, cancel, state, steps };
      }

      const {
        schedule: frame,
        cancel: cancelFrame,
        state: frameData,
        steps: frameSteps,
      } = /* @__PURE__ */ createRenderBatcher(
        typeof requestAnimationFrame !== "undefined"
          ? requestAnimationFrame
          : noop,
        true,
      );

      let now;
      function clearTime() {
        now = undefined;
      }

      const time = {
        now: () => {
          if (now === undefined) {
            time.set(
              frameData.isProcessing || MotionGlobalConfig.useManualTiming
                ? frameData.timestamp
                : performance.now(),
            );
          }
          return now;
        },
        set: (newTime) => {
          now = newTime;
          queueMicrotask(clearTime);
        },
      };

      const checkStringStartsWith = (token) => (key) =>
        typeof key === "string" && key.startsWith(token);
      const isCSSVariableName = /*@__PURE__*/ checkStringStartsWith("--");
      const startsAsVariableToken =
        /*@__PURE__*/ checkStringStartsWith("var(--");
      const isCSSVariableToken = (value) => {
        const startsWithToken = startsAsVariableToken(value);
        if (!startsWithToken) return false;
        // Ensure any comments are stripped from the value as this can harm performance of the regex.
        return singleCssVariableRegex.test(value.split("/*")[0].trim());
      };
      const singleCssVariableRegex =
        /var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu;

      function containsCSSVariable(value) {
        if (typeof value !== "string") return false;
        // Strip comments to avoid false positives
        return value.split("/*")[0].includes("var(--");
      }

      const number = {
        test: (v) => typeof v === "number",
        parse: parseFloat,
        transform: (v) => v,
      };
      const alpha = {
        ...number,
        transform: (v) => clamp(0, 1, v),
      };
      const scale = {
        ...number,
        default: 1,
      };

      // If this number is a decimal, make it just five decimal places
      // to avoid exponents
      const sanitize = (v) => Math.round(v * 100000) / 100000;

      const floatRegex = /-?(?:\d+(?:\.\d+)?|\.\d+)/gu;

      function isNullish(v) {
        return v == null;
      }

      const singleColorRegex =
        /^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu;

      const isColorString = (type, testProp) => (v) => {
        return Boolean(
          (typeof v === "string" &&
            singleColorRegex.test(v) &&
            v.startsWith(type)) ||
          (testProp &&
            !isNullish(v) &&
            Object.prototype.hasOwnProperty.call(v, testProp)),
        );
      };
      const splitColor = (aName, bName, cName) => (v) => {
        if (typeof v !== "string") return v;
        const [a, b, c, alpha] = v.match(floatRegex);
        return {
          [aName]: parseFloat(a),
          [bName]: parseFloat(b),
          [cName]: parseFloat(c),
          alpha: alpha !== undefined ? parseFloat(alpha) : 1,
        };
      };

      const clampRgbUnit = (v) => clamp(0, 255, v);
      const rgbUnit = {
        ...number,
        transform: (v) => Math.round(clampRgbUnit(v)),
      };
      const rgba = {
        test: /*@__PURE__*/ isColorString("rgb", "red"),
        parse: /*@__PURE__*/ splitColor("red", "green", "blue"),
        transform: ({ red, green, blue, alpha: alpha$1 = 1 }) =>
          "rgba(" +
          rgbUnit.transform(red) +
          ", " +
          rgbUnit.transform(green) +
          ", " +
          rgbUnit.transform(blue) +
          ", " +
          sanitize(alpha.transform(alpha$1)) +
          ")",
      };

      function parseHex(v) {
        let r = "";
        let g = "";
        let b = "";
        let a = "";
        // If we have 6 characters, ie #FF0000
        if (v.length > 5) {
          r = v.substring(1, 3);
          g = v.substring(3, 5);
          b = v.substring(5, 7);
          a = v.substring(7, 9);
          // Or we have 3 characters, ie #F00
        } else {
          r = v.substring(1, 2);
          g = v.substring(2, 3);
          b = v.substring(3, 4);
          a = v.substring(4, 5);
          r += r;
          g += g;
          b += b;
          a += a;
        }
        return {
          red: parseInt(r, 16),
          green: parseInt(g, 16),
          blue: parseInt(b, 16),
          alpha: a ? parseInt(a, 16) / 255 : 1,
        };
      }
      const hex = {
        test: /*@__PURE__*/ isColorString("#"),
        parse: parseHex,
        transform: rgba.transform,
      };

      /*#__NO_SIDE_EFFECTS__*/
      const createUnitType = (unit) => ({
        test: (v) =>
          typeof v === "string" &&
          v.endsWith(unit) &&
          v.split(" ").length === 1,
        parse: parseFloat,
        transform: (v) => `${v}${unit}`,
      });
      const degrees = /*@__PURE__*/ createUnitType("deg");
      const percent = /*@__PURE__*/ createUnitType("%");
      const px = /*@__PURE__*/ createUnitType("px");
      const vh = /*@__PURE__*/ createUnitType("vh");
      const vw = /*@__PURE__*/ createUnitType("vw");
      const progressPercentage = /*@__PURE__*/ (() => ({
        ...percent,
        parse: (v) => percent.parse(v) / 100,
        transform: (v) => percent.transform(v * 100),
      }))();

      const hsla = {
        test: /*@__PURE__*/ isColorString("hsl", "hue"),
        parse: /*@__PURE__*/ splitColor("hue", "saturation", "lightness"),
        transform: ({ hue, saturation, lightness, alpha: alpha$1 = 1 }) => {
          return (
            "hsla(" +
            Math.round(hue) +
            ", " +
            percent.transform(sanitize(saturation)) +
            ", " +
            percent.transform(sanitize(lightness)) +
            ", " +
            sanitize(alpha.transform(alpha$1)) +
            ")"
          );
        },
      };

      const color = {
        test: (v) => rgba.test(v) || hex.test(v) || hsla.test(v),
        parse: (v) => {
          if (rgba.test(v)) {
            return rgba.parse(v);
          } else if (hsla.test(v)) {
            return hsla.parse(v);
          } else {
            return hex.parse(v);
          }
        },
        transform: (v) => {
          return typeof v === "string"
            ? v
            : v.hasOwnProperty("red")
              ? rgba.transform(v)
              : hsla.transform(v);
        },
        getAnimatableNone: (v) => {
          const parsed = color.parse(v);
          parsed.alpha = 0;
          return color.transform(parsed);
        },
      };

      const colorRegex =
        /(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu;

      function test(v) {
        return (
          isNaN(v) &&
          typeof v === "string" &&
          (v.match(floatRegex)?.length || 0) +
            (v.match(colorRegex)?.length || 0) >
            0
        );
      }
      const NUMBER_TOKEN = "number";
      const COLOR_TOKEN = "color";
      const VAR_TOKEN = "var";
      const VAR_FUNCTION_TOKEN = "var(";
      const SPLIT_TOKEN = "${}";
      // this regex consists of the `singleCssVariableRegex|rgbHSLValueRegex|digitRegex`
      const complexRegex =
        /var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu;
      function analyseComplexValue(value) {
        const originalValue = value.toString();
        const values = [];
        const indexes = {
          color: [],
          number: [],
          var: [],
        };
        const types = [];
        let i = 0;
        const tokenised = originalValue.replace(complexRegex, (parsedValue) => {
          if (color.test(parsedValue)) {
            indexes.color.push(i);
            types.push(COLOR_TOKEN);
            values.push(color.parse(parsedValue));
          } else if (parsedValue.startsWith(VAR_FUNCTION_TOKEN)) {
            indexes.var.push(i);
            types.push(VAR_TOKEN);
            values.push(parsedValue);
          } else {
            indexes.number.push(i);
            types.push(NUMBER_TOKEN);
            values.push(parseFloat(parsedValue));
          }
          ++i;
          return SPLIT_TOKEN;
        });
        const split = tokenised.split(SPLIT_TOKEN);
        return { values, split, indexes, types };
      }
      function parseComplexValue(v) {
        return analyseComplexValue(v).values;
      }
      function createTransformer(source) {
        const { split, types } = analyseComplexValue(source);
        const numSections = split.length;
        return (v) => {
          let output = "";
          for (let i = 0; i < numSections; i++) {
            output += split[i];
            if (v[i] !== undefined) {
              const type = types[i];
              if (type === NUMBER_TOKEN) {
                output += sanitize(v[i]);
              } else if (type === COLOR_TOKEN) {
                output += color.transform(v[i]);
              } else {
                output += v[i];
              }
            }
          }
          return output;
        };
      }
      const convertNumbersToZero = (v) =>
        typeof v === "number"
          ? 0
          : color.test(v)
            ? color.getAnimatableNone(v)
            : v;
      function getAnimatableNone$1(v) {
        const parsed = parseComplexValue(v);
        const transformer = createTransformer(v);
        return transformer(parsed.map(convertNumbersToZero));
      }
      const complex = {
        test,
        parse: parseComplexValue,
        createTransformer,
        getAnimatableNone: getAnimatableNone$1,
      };

      // Adapted from https://gist.github.com/mjackson/5311256
      function hueToRgb(p, q, t) {
        if (t < 0) t += 1;
        if (t > 1) t -= 1;
        if (t < 1 / 6) return p + (q - p) * 6 * t;
        if (t < 1 / 2) return q;
        if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
        return p;
      }
      function hslaToRgba({ hue, saturation, lightness, alpha }) {
        hue /= 360;
        saturation /= 100;
        lightness /= 100;
        let red = 0;
        let green = 0;
        let blue = 0;
        if (!saturation) {
          red = green = blue = lightness;
        } else {
          const q =
            lightness < 0.5
              ? lightness * (1 + saturation)
              : lightness + saturation - lightness * saturation;
          const p = 2 * lightness - q;
          red = hueToRgb(p, q, hue + 1 / 3);
          green = hueToRgb(p, q, hue);
          blue = hueToRgb(p, q, hue - 1 / 3);
        }
        return {
          red: Math.round(red * 255),
          green: Math.round(green * 255),
          blue: Math.round(blue * 255),
          alpha,
        };
      }

      function mixImmediate(a, b) {
        return (p) => (p > 0 ? b : a);
      }

      /*
  Value in range from progress

  Given a lower limit and an upper limit, we return the value within
  that range as expressed by progress (usually a number from 0 to 1)

  So progress = 0.5 would change

  from -------- to

  to

  from ---- to

  E.g. from = 10, to = 20, progress = 0.5 => 15

  @param [number]: Lower limit of range
  @param [number]: Upper limit of range
  @param [number]: The progress between lower and upper limits expressed 0-1
  @return [number]: Value as calculated from progress within range (not limited within range)
*/
      const mixNumber$1 = (from, to, progress) => {
        return from + (to - from) * progress;
      };

      // Linear color space blending
      // Explained https://www.youtube.com/watch?v=LKnqECcg6Gw
      // Demonstrated http://codepen.io/osublake/pen/xGVVaN
      const mixLinearColor = (from, to, v) => {
        const fromExpo = from * from;
        const expo = v * (to * to - fromExpo) + fromExpo;
        return expo < 0 ? 0 : Math.sqrt(expo);
      };
      const colorTypes = [hex, rgba, hsla];
      const getColorType = (v) => colorTypes.find((type) => type.test(v));
      function asRGBA(color) {
        const type = getColorType(color);
        if (!Boolean(type)) return false;
        let model = type.parse(color);
        if (type === hsla) {
          // TODO Remove this cast - needed since Motion's stricter typing
          model = hslaToRgba(model);
        }
        return model;
      }
      const mixColor = (from, to) => {
        const fromRGBA = asRGBA(from);
        const toRGBA = asRGBA(to);
        if (!fromRGBA || !toRGBA) {
          return mixImmediate(from, to);
        }
        const blended = { ...fromRGBA };
        return (v) => {
          blended.red = mixLinearColor(fromRGBA.red, toRGBA.red, v);
          blended.green = mixLinearColor(fromRGBA.green, toRGBA.green, v);
          blended.blue = mixLinearColor(fromRGBA.blue, toRGBA.blue, v);
          blended.alpha = mixNumber$1(fromRGBA.alpha, toRGBA.alpha, v);
          return rgba.transform(blended);
        };
      };

      const invisibleValues = new Set(["none", "hidden"]);

      function mixVisibility(origin, target) {
        if (invisibleValues.has(origin)) {
          return (p) => (p <= 0 ? origin : target);
        } else {
          return (p) => (p >= 1 ? target : origin);
        }
      }

      function mixNumber(a, b) {
        return (p) => mixNumber$1(a, b, p);
      }
      function getMixer(a) {
        if (typeof a === "number") {
          return mixNumber;
        } else if (typeof a === "string") {
          return isCSSVariableToken(a)
            ? mixImmediate
            : color.test(a)
              ? mixColor
              : mixComplex;
        } else if (Array.isArray(a)) {
          return mixArray;
        } else if (typeof a === "object") {
          return color.test(a) ? mixColor : mixObject;
        }
        return mixImmediate;
      }
      function mixArray(a, b) {
        const output = [...a];
        const numValues = output.length;
        const blendValue = a.map((v, i) => getMixer(v)(v, b[i]));
        return (p) => {
          for (let i = 0; i < numValues; i++) {
            output[i] = blendValue[i](p);
          }
          return output;
        };
      }
      function mixObject(a, b) {
        const output = { ...a, ...b };
        const blendValue = {};
        for (const key in output) {
          if (a[key] !== undefined && b[key] !== undefined) {
            blendValue[key] = getMixer(a[key])(a[key], b[key]);
          }
        }
        return (v) => {
          for (const key in blendValue) {
            output[key] = blendValue[key](v);
          }
          return output;
        };
      }
      function matchOrder(origin, target) {
        const orderedOrigin = [];
        const pointers = { color: 0, var: 0, number: 0 };
        for (let i = 0; i < target.values.length; i++) {
          const type = target.types[i];
          const originIndex = origin.indexes[type][pointers[type]];
          const originValue = origin.values[originIndex] ?? 0;
          orderedOrigin[i] = originValue;
          pointers[type]++;
        }
        return orderedOrigin;
      }
      const mixComplex = (origin, target) => {
        const template = complex.createTransformer(target);
        const originStats = analyseComplexValue(origin);
        const targetStats = analyseComplexValue(target);
        const canInterpolate =
          originStats.indexes.var.length === targetStats.indexes.var.length &&
          originStats.indexes.color.length ===
            targetStats.indexes.color.length &&
          originStats.indexes.number.length >=
            targetStats.indexes.number.length;
        if (canInterpolate) {
          if (
            (invisibleValues.has(origin) && !targetStats.values.length) ||
            (invisibleValues.has(target) && !originStats.values.length)
          ) {
            return mixVisibility(origin, target);
          }
          return pipe(
            mixArray(matchOrder(originStats, targetStats), targetStats.values),
            template,
          );
        } else {
          return mixImmediate(origin, target);
        }
      };

      function mix(from, to, p) {
        if (
          typeof from === "number" &&
          typeof to === "number" &&
          typeof p === "number"
        ) {
          return mixNumber$1(from, to, p);
        }
        const mixer = getMixer(from);
        return mixer(from, to);
      }

      const frameloopDriver = (update) => {
        const passTimestamp = ({ timestamp }) => update(timestamp);
        return {
          start: (keepAlive = true) => frame.update(passTimestamp, keepAlive),
          stop: () => cancelFrame(passTimestamp),

          now: () =>
            frameData.isProcessing ? frameData.timestamp : time.now(),
        };
      };

      const generateLinearEasing = (
        easing,
        duration, // as milliseconds
        resolution = 10, // as milliseconds
      ) => {
        let points = "";
        const numPoints = Math.max(Math.round(duration / resolution), 2);
        for (let i = 0; i < numPoints; i++) {
          points +=
            Math.round(easing(i / (numPoints - 1)) * 10000) / 10000 + ", ";
        }
        return `linear(${points.substring(0, points.length - 2)})`;
      };

      const maxGeneratorDuration = 20000;
      function calcGeneratorDuration(generator) {
        let duration = 0;
        const timeStep = 50;
        let state = generator.next(duration);
        while (!state.done && duration < maxGeneratorDuration) {
          duration += timeStep;
          state = generator.next(duration);
        }
        return duration >= maxGeneratorDuration ? Infinity : duration;
      }

      function createGeneratorEasing(options, scale = 100, createGenerator) {
        const generator = createGenerator({
          ...options,
          keyframes: [0, scale],
        });
        const duration = Math.min(
          calcGeneratorDuration(generator),
          maxGeneratorDuration,
        );
        return {
          type: "keyframes",
          ease: (progress) => {
            return generator.next(duration * progress).value / scale;
          },
          duration: millisecondsToSeconds(duration),
        };
      }

      const velocitySampleDuration = 5; // ms
      function calcGeneratorVelocity(resolveValue, t, current) {
        const prevT = Math.max(t - velocitySampleDuration, 0);
        return velocityPerSecond(current - resolveValue(prevT), t - prevT);
      }

      const springDefaults = {
        // Default spring physics
        stiffness: 100,
        damping: 10,
        mass: 1.0,
        velocity: 0.0,
        // Default duration/bounce-based options
        duration: 800, // in ms
        bounce: 0.3,
        visualDuration: 0.3, // in seconds
        // Rest thresholds
        restSpeed: {
          granular: 0.01,
          default: 2,
        },
        restDelta: {
          granular: 0.005,
          default: 0.5,
        },
        // Limits
        minDuration: 0.01, // in seconds
        maxDuration: 10.0, // in seconds
        minDamping: 0.05,
        maxDamping: 1,
      };

      const safeMin = 0.001;
      function findSpring({
        duration = springDefaults.duration,
        bounce = springDefaults.bounce,
        velocity = springDefaults.velocity,
        mass = springDefaults.mass,
      }) {
        let envelope;
        let derivative;
        let dampingRatio = 1 - bounce;

        dampingRatio = clamp(
          springDefaults.minDamping,
          springDefaults.maxDamping,
          dampingRatio,
        );
        duration = clamp(
          springDefaults.minDuration,
          springDefaults.maxDuration,
          millisecondsToSeconds(duration),
        );
        if (dampingRatio < 1) {
          envelope = (undampedFreq) => {
            const exponentialDecay = undampedFreq * dampingRatio;
            const delta = exponentialDecay * duration;
            const a = exponentialDecay - velocity;
            const b = calcAngularFreq(undampedFreq, dampingRatio);
            const c = Math.exp(-delta);
            return safeMin - (a / b) * c;
          };
          derivative = (undampedFreq) => {
            const exponentialDecay = undampedFreq * dampingRatio;
            const delta = exponentialDecay * duration;
            const d = delta * velocity + velocity;
            const e =
              Math.pow(dampingRatio, 2) * Math.pow(undampedFreq, 2) * duration;
            const f = Math.exp(-delta);
            const g = calcAngularFreq(Math.pow(undampedFreq, 2), dampingRatio);
            const factor = -envelope(undampedFreq) + safeMin > 0 ? -1 : 1;
            return (factor * ((d - e) * f)) / g;
          };
        } else {
          envelope = (undampedFreq) => {
            const a = Math.exp(-undampedFreq * duration);
            const b = (undampedFreq - velocity) * duration + 1;
            return -safeMin + a * b;
          };
          derivative = (undampedFreq) => {
            const a = Math.exp(-undampedFreq * duration);
            const b = (velocity - undampedFreq) * (duration * duration);
            return a * b;
          };
        }
        const initialGuess = 5 / duration;
        const undampedFreq = approximateRoot(
          envelope,
          derivative,
          initialGuess,
        );
        duration = secondsToMilliseconds(duration);
        if (isNaN(undampedFreq)) {
          return {
            stiffness: springDefaults.stiffness,
            damping: springDefaults.damping,
            duration,
          };
        } else {
          const stiffness = Math.pow(undampedFreq, 2) * mass;
          return {
            stiffness,
            damping: dampingRatio * 2 * Math.sqrt(mass * stiffness),
            duration,
          };
        }
      }
      const rootIterations = 12;
      function approximateRoot(envelope, derivative, initialGuess) {
        let result = initialGuess;
        for (let i = 1; i < rootIterations; i++) {
          result = result - envelope(result) / derivative(result);
        }
        return result;
      }
      function calcAngularFreq(undampedFreq, dampingRatio) {
        return undampedFreq * Math.sqrt(1 - dampingRatio * dampingRatio);
      }

      const durationKeys = ["duration", "bounce"];
      const physicsKeys = ["stiffness", "damping", "mass"];
      function isSpringType(options, keys) {
        return keys.some((key) => options[key] !== undefined);
      }
      function getSpringOptions(options) {
        let springOptions = {
          velocity: springDefaults.velocity,
          stiffness: springDefaults.stiffness,
          damping: springDefaults.damping,
          mass: springDefaults.mass,
          isResolvedFromDuration: false,
          ...options,
        };
        // stiffness/damping/mass overrides duration/bounce
        if (
          !isSpringType(options, physicsKeys) &&
          isSpringType(options, durationKeys)
        ) {
          if (options.visualDuration) {
            const visualDuration = options.visualDuration;
            const root = (2 * Math.PI) / (visualDuration * 1.2);
            const stiffness = root * root;
            const damping =
              2 *
              clamp(0.05, 1, 1 - (options.bounce || 0)) *
              Math.sqrt(stiffness);
            springOptions = {
              ...springOptions,
              mass: springDefaults.mass,
              stiffness,
              damping,
            };
          } else {
            const derived = findSpring(options);
            springOptions = {
              ...springOptions,
              ...derived,
              mass: springDefaults.mass,
            };
            springOptions.isResolvedFromDuration = true;
          }
        }
        return springOptions;
      }
      function spring(
        optionsOrVisualDuration = springDefaults.visualDuration,
        bounce = springDefaults.bounce,
      ) {
        const options =
          typeof optionsOrVisualDuration !== "object"
            ? {
                visualDuration: optionsOrVisualDuration,
                keyframes: [0, 1],
                bounce,
              }
            : optionsOrVisualDuration;
        let { restSpeed, restDelta } = options;
        const origin = options.keyframes[0];
        const target = options.keyframes[options.keyframes.length - 1];

        const state = { done: false, value: origin };
        const {
          stiffness,
          damping,
          mass,
          duration,
          velocity,
          isResolvedFromDuration,
        } = getSpringOptions({
          ...options,
          velocity: -millisecondsToSeconds(options.velocity || 0),
        });
        const initialVelocity = velocity || 0.0;
        const dampingRatio = damping / (2 * Math.sqrt(stiffness * mass));
        const initialDelta = target - origin;
        const undampedAngularFreq = millisecondsToSeconds(
          Math.sqrt(stiffness / mass),
        );

        const isGranularScale = Math.abs(initialDelta) < 5;
        restSpeed ||
          (restSpeed = isGranularScale
            ? springDefaults.restSpeed.granular
            : springDefaults.restSpeed.default);
        restDelta ||
          (restDelta = isGranularScale
            ? springDefaults.restDelta.granular
            : springDefaults.restDelta.default);
        let resolveSpring;
        if (dampingRatio < 1) {
          const angularFreq = calcAngularFreq(
            undampedAngularFreq,
            dampingRatio,
          );
          // Underdamped spring
          resolveSpring = (t) => {
            const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);
            return (
              target -
              envelope *
                (((initialVelocity +
                  dampingRatio * undampedAngularFreq * initialDelta) /
                  angularFreq) *
                  Math.sin(angularFreq * t) +
                  initialDelta * Math.cos(angularFreq * t))
            );
          };
        } else if (dampingRatio === 1) {
          // Critically damped spring
          resolveSpring = (t) =>
            target -
            Math.exp(-undampedAngularFreq * t) *
              (initialDelta +
                (initialVelocity + undampedAngularFreq * initialDelta) * t);
        } else {
          // Overdamped spring
          const dampedAngularFreq =
            undampedAngularFreq * Math.sqrt(dampingRatio * dampingRatio - 1);
          resolveSpring = (t) => {
            const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);
            // When performing sinh or cosh values can hit Infinity so we cap them here
            const freqForT = Math.min(dampedAngularFreq * t, 300);
            return (
              target -
              (envelope *
                ((initialVelocity +
                  dampingRatio * undampedAngularFreq * initialDelta) *
                  Math.sinh(freqForT) +
                  dampedAngularFreq * initialDelta * Math.cosh(freqForT))) /
                dampedAngularFreq
            );
          };
        }
        const generator = {
          calculatedDuration: isResolvedFromDuration ? duration || null : null,
          next: (t) => {
            const current = resolveSpring(t);
            if (!isResolvedFromDuration) {
              let currentVelocity = t === 0 ? initialVelocity : 0.0;

              if (dampingRatio < 1) {
                currentVelocity =
                  t === 0
                    ? secondsToMilliseconds(initialVelocity)
                    : calcGeneratorVelocity(resolveSpring, t, current);
              }
              const isBelowVelocityThreshold =
                Math.abs(currentVelocity) <= restSpeed;
              const isBelowDisplacementThreshold =
                Math.abs(target - current) <= restDelta;
              state.done =
                isBelowVelocityThreshold && isBelowDisplacementThreshold;
            } else {
              state.done = t >= duration;
            }
            state.value = state.done ? target : current;
            return state;
          },
          toString: () => {
            const calculatedDuration = Math.min(
              calcGeneratorDuration(generator),
              maxGeneratorDuration,
            );
            const easing = generateLinearEasing(
              (progress) => generator.next(calculatedDuration * progress).value,
              calculatedDuration,
              30,
            );
            return calculatedDuration + "ms " + easing;
          },
          toTransition: () => {},
        };
        return generator;
      }
      spring.applyToOptions = (options) => {
        const generatorOptions = createGeneratorEasing(options, 100, spring);
        options.ease = generatorOptions.ease;
        options.duration = secondsToMilliseconds(generatorOptions.duration);
        options.type = "keyframes";
        return options;
      };

      function inertia({
        keyframes,
        velocity = 0.0,
        power = 0.8,
        timeConstant = 325,
        bounceDamping = 10,
        bounceStiffness = 500,
        modifyTarget,
        min,
        max,
        restDelta = 0.5,
        restSpeed,
      }) {
        const origin = keyframes[0];
        const state = {
          done: false,
          value: origin,
        };
        const isOutOfBounds = (v) =>
          (min !== undefined && v < min) || (max !== undefined && v > max);
        const nearestBoundary = (v) => {
          if (min === undefined) return max;
          if (max === undefined) return min;
          return Math.abs(min - v) < Math.abs(max - v) ? min : max;
        };
        let amplitude = power * velocity;
        const ideal = origin + amplitude;
        const target = modifyTarget === undefined ? ideal : modifyTarget(ideal);

        if (target !== ideal) amplitude = target - origin;
        const calcDelta = (t) => -amplitude * Math.exp(-t / timeConstant);
        const calcLatest = (t) => target + calcDelta(t);
        const applyFriction = (t) => {
          const delta = calcDelta(t);
          const latest = calcLatest(t);
          state.done = Math.abs(delta) <= restDelta;
          state.value = state.done ? target : latest;
        };

        let timeReachedBoundary;
        let spring$1;
        const checkCatchBoundary = (t) => {
          if (!isOutOfBounds(state.value)) return;
          timeReachedBoundary = t;
          spring$1 = spring({
            keyframes: [state.value, nearestBoundary(state.value)],
            velocity: calcGeneratorVelocity(calcLatest, t, state.value), // TODO: This should be passing * 1000
            damping: bounceDamping,
            stiffness: bounceStiffness,
            restDelta,
            restSpeed,
          });
        };
        checkCatchBoundary(0);
        return {
          calculatedDuration: null,
          next: (t) => {
            let hasUpdatedFrame = false;
            if (!spring$1 && timeReachedBoundary === undefined) {
              hasUpdatedFrame = true;
              applyFriction(t);
              checkCatchBoundary(t);
            }

            if (timeReachedBoundary !== undefined && t >= timeReachedBoundary) {
              return spring$1.next(t - timeReachedBoundary);
            } else {
              !hasUpdatedFrame && applyFriction(t);
              return state;
            }
          },
        };
      }

      function createMixers(output, ease, customMixer) {
        const mixers = [];
        const mixerFactory = customMixer || MotionGlobalConfig.mix || mix;
        const numMixers = output.length - 1;
        for (let i = 0; i < numMixers; i++) {
          let mixer = mixerFactory(output[i], output[i + 1]);
          if (ease) {
            const easingFunction = Array.isArray(ease) ? ease[i] || noop : ease;
            mixer = pipe(easingFunction, mixer);
          }
          mixers.push(mixer);
        }
        return mixers;
      }

      function interpolate(
        input,
        output,
        { clamp: isClamp = true, ease, mixer } = {},
      ) {
        const inputLength = input.length;
        invariant(inputLength === output.length);

        if (inputLength === 1) return () => output[0];
        if (inputLength === 2 && output[0] === output[1])
          return () => output[1];
        const isZeroDeltaRange = input[0] === input[1];
        // If input runs highest -> lowest, reverse both arrays
        if (input[0] > input[inputLength - 1]) {
          input = [...input].reverse();
          output = [...output].reverse();
        }
        const mixers = createMixers(output, ease, mixer);
        const numMixers = mixers.length;
        const interpolator = (v) => {
          if (isZeroDeltaRange && v < input[0]) return output[0];
          let i = 0;
          if (numMixers > 1) {
            for (; i < input.length - 2; i++) {
              if (v < input[i + 1]) break;
            }
          }
          const progressInRange = progress(input[i], input[i + 1], v);
          return mixers[i](progressInRange);
        };
        return isClamp
          ? (v) => interpolator(clamp(input[0], input[inputLength - 1], v))
          : interpolator;
      }

      function fillOffset(offset, remaining) {
        const min = offset[offset.length - 1];
        for (let i = 1; i <= remaining; i++) {
          const offsetProgress = progress(0, remaining, i);
          offset.push(mixNumber$1(min, 1, offsetProgress));
        }
      }

      function defaultOffset(arr) {
        const offset = [0];
        fillOffset(offset, arr.length - 1);
        return offset;
      }

      function convertOffsetToTimes(offset, duration) {
        return offset.map((o) => o * duration);
      }

      function defaultEasing(values, easing) {
        return values
          .map(() => easing || easeInOut)
          .splice(0, values.length - 1);
      }
      function keyframes({
        duration = 300,
        keyframes: keyframeValues,
        times,
        ease = "easeInOut",
      }) {
        const easingFunctions = isEasingArray(ease)
          ? ease.map(easingDefinitionToFunction)
          : easingDefinitionToFunction(ease);

        const state = {
          done: false,
          value: keyframeValues[0],
        };

        const absoluteTimes = convertOffsetToTimes(
          // Only use the provided offsets if they're the correct length
          // TODO Maybe we should warn here if there's a length mismatch
          times && times.length === keyframeValues.length
            ? times
            : defaultOffset(keyframeValues),
          duration,
        );
        const mapTimeToKeyframe = interpolate(absoluteTimes, keyframeValues, {
          ease: Array.isArray(easingFunctions)
            ? easingFunctions
            : defaultEasing(keyframeValues, easingFunctions),
        });
        return {
          calculatedDuration: duration,
          next: (t) => {
            state.value = mapTimeToKeyframe(t);
            state.done = t >= duration;
            return state;
          },
        };
      }

      const isNotNull$1 = (value) => value !== null;
      function getFinalKeyframe$1(
        keyframes,
        { repeat, repeatType = "loop" },
        finalKeyframe,
        speed = 1,
      ) {
        const resolvedKeyframes = keyframes.filter(isNotNull$1);
        const useFirstKeyframe =
          speed < 0 || (repeat && repeatType !== "loop" && repeat % 2 === 1);
        const index = useFirstKeyframe ? 0 : resolvedKeyframes.length - 1;
        return !index || finalKeyframe === undefined
          ? resolvedKeyframes[index]
          : finalKeyframe;
      }

      const transitionTypeMap = {
        decay: inertia,
        inertia,
        tween: keyframes,
        keyframes: keyframes,
        spring,
      };
      function replaceTransitionType(transition) {
        if (typeof transition.type === "string") {
          transition.type = transitionTypeMap[transition.type];
        }
      }

      class WithPromise {
        constructor() {
          this.updateFinished();
        }
        get finished() {
          return this._finished;
        }
        updateFinished() {
          this._finished = new Promise((resolve) => {
            this.resolve = resolve;
          });
        }
        notifyFinished() {
          this.resolve();
        }

        then(onResolve, onReject) {
          return this.finished.then(onResolve, onReject);
        }
      }

      const percentToProgress = (percent) => percent / 100;
      class JSAnimation extends WithPromise {
        constructor(options) {
          super();
          this.state = "idle";
          this.startTime = null;
          this.isStopped = false;
          this.currentTime = 0;
          this.holdTime = null;
          this.playbackSpeed = 1;
          this.stop = () => {
            const { motionValue } = this.options;
            if (motionValue && motionValue.updatedAt !== time.now()) {
              this.tick(time.now());
            }
            this.isStopped = true;
            if (this.state === "idle") return;
            this.teardown();
            this.options.onStop?.();
          };
          this.options = options;
          this.initAnimation();
          this.play();
          if (options.autoplay === false) this.pause();
        }
        initAnimation() {
          const { options } = this;
          replaceTransitionType(options);
          const {
            type = keyframes,
            repeat = 0,
            repeatDelay = 0,
            repeatType,
            velocity = 0,
          } = options;
          let { keyframes: keyframes$1 } = options;
          const generatorFactory = type || keyframes;
          if (
            generatorFactory !== keyframes &&
            typeof keyframes$1[0] !== "number"
          ) {
            this.mixKeyframes = pipe(
              percentToProgress,
              mix(keyframes$1[0], keyframes$1[1]),
            );
            keyframes$1 = [0, 100];
          }
          const generator = generatorFactory({
            ...options,
            keyframes: keyframes$1,
          });
          if (repeatType === "mirror") {
            this.mirroredGenerator = generatorFactory({
              ...options,
              keyframes: [...keyframes$1].reverse(),
              velocity: -velocity,
            });
          }
          if (generator.calculatedDuration === null) {
            generator.calculatedDuration = calcGeneratorDuration(generator);
          }
          const { calculatedDuration } = generator;
          this.calculatedDuration = calculatedDuration;
          this.resolvedDuration = calculatedDuration + repeatDelay;
          this.totalDuration =
            this.resolvedDuration * (repeat + 1) - repeatDelay;
          this.generator = generator;
        }
        updateTime(timestamp) {
          const animationTime =
            Math.round(timestamp - this.startTime) * this.playbackSpeed;
          if (this.holdTime !== null) {
            this.currentTime = this.holdTime;
          } else {
            this.currentTime = animationTime;
          }
        }
        tick(timestamp, sample = false) {
          const {
            generator,
            totalDuration,
            mixKeyframes,
            mirroredGenerator,
            resolvedDuration,
            calculatedDuration,
          } = this;
          if (this.startTime === null) return generator.next(0);
          const {
            delay = 0,
            keyframes: keyframes2,
            repeat,
            repeatType,
            repeatDelay,
            type,
            onUpdate,
            finalKeyframe,
          } = this.options;
          if (this.speed > 0) {
            this.startTime = Math.min(this.startTime, timestamp);
          } else if (this.speed < 0) {
            this.startTime = Math.min(
              timestamp - totalDuration / this.speed,
              this.startTime,
            );
          }
          if (sample) {
            this.currentTime = timestamp;
          } else {
            this.updateTime(timestamp);
          }
          const timeWithoutDelay =
            this.currentTime - delay * (this.playbackSpeed >= 0 ? 1 : -1);
          const isInDelayPhase =
            this.playbackSpeed >= 0
              ? timeWithoutDelay < 0
              : timeWithoutDelay > totalDuration;
          this.currentTime = Math.max(timeWithoutDelay, 0);
          if (this.state === "finished" && this.holdTime === null) {
            this.currentTime = totalDuration;
          }
          let elapsed = this.currentTime;
          let frameGenerator = generator;
          if (repeat) {
            const progress =
              Math.min(this.currentTime, totalDuration) / resolvedDuration;
            let currentIteration = Math.floor(progress);
            let iterationProgress = progress % 1;
            if (!iterationProgress && progress >= 1) {
              iterationProgress = 1;
            }
            iterationProgress === 1 && currentIteration--;
            currentIteration = Math.min(currentIteration, repeat + 1);
            const isOddIteration = Boolean(currentIteration % 2);
            if (isOddIteration) {
              if (repeatType === "reverse") {
                iterationProgress = 1 - iterationProgress;
                if (repeatDelay) {
                  iterationProgress -= repeatDelay / resolvedDuration;
                }
              } else if (repeatType === "mirror") {
                frameGenerator = mirroredGenerator;
              }
            }
            elapsed = clamp(0, 1, iterationProgress) * resolvedDuration;
          }
          const state = isInDelayPhase
            ? { done: false, value: keyframes2[0] }
            : frameGenerator.next(elapsed);
          if (mixKeyframes) {
            state.value = mixKeyframes(state.value);
          }
          let { done } = state;
          if (!isInDelayPhase && calculatedDuration !== null) {
            done =
              this.playbackSpeed >= 0
                ? this.currentTime >= totalDuration
                : this.currentTime <= 0;
          }
          const isAnimationFinished =
            this.holdTime === null &&
            (this.state === "finished" || (this.state === "running" && done));
          if (isAnimationFinished && type !== inertia) {
            state.value = getFinalKeyframe$1(
              keyframes2,
              this.options,
              finalKeyframe,
              this.speed,
            );
          }
          if (onUpdate) {
            onUpdate(state.value);
          }
          if (isAnimationFinished) {
            this.finish();
          }
          return state;
        }

        then(resolve, reject) {
          return this.finished.then(resolve, reject);
        }
        get duration() {
          return millisecondsToSeconds(this.calculatedDuration);
        }
        get iterationDuration() {
          const { delay = 0 } = this.options || {};
          return this.duration + millisecondsToSeconds(delay);
        }
        get time() {
          return millisecondsToSeconds(this.currentTime);
        }
        set time(newTime) {
          newTime = secondsToMilliseconds(newTime);
          this.currentTime = newTime;
          if (
            this.startTime === null ||
            this.holdTime !== null ||
            this.playbackSpeed === 0
          ) {
            this.holdTime = newTime;
          } else if (this.driver) {
            this.startTime = this.driver.now() - newTime / this.playbackSpeed;
          }
          this.driver?.start(false);
        }
        get speed() {
          return this.playbackSpeed;
        }
        set speed(newSpeed) {
          this.updateTime(time.now());
          const hasChanged = this.playbackSpeed !== newSpeed;
          this.playbackSpeed = newSpeed;
          if (hasChanged) {
            this.time = millisecondsToSeconds(this.currentTime);
          }
        }
        play() {
          if (this.isStopped) return;
          const { driver = frameloopDriver, startTime } = this.options;
          if (!this.driver) {
            this.driver = driver((timestamp) => this.tick(timestamp));
          }
          this.options.onPlay?.();
          const now = this.driver.now();
          if (this.state === "finished") {
            this.updateFinished();
            this.startTime = now;
          } else if (this.holdTime !== null) {
            this.startTime = now - this.holdTime;
          } else if (!this.startTime) {
            this.startTime = startTime ?? now;
          }
          if (this.state === "finished" && this.speed < 0) {
            this.startTime += this.calculatedDuration;
          }
          this.holdTime = null;
          this.state = "running";
          this.driver.start();
        }
        pause() {
          this.state = "paused";
          this.updateTime(time.now());
          this.holdTime = this.currentTime;
        }
        complete() {
          if (this.state !== "running") {
            this.play();
          }
          this.state = "finished";
          this.holdTime = null;
        }
        finish() {
          this.notifyFinished();
          this.teardown();
          this.state = "finished";
          this.options.onComplete?.();
        }
        cancel() {
          this.holdTime = null;
          this.startTime = 0;
          this.tick(0);
          this.teardown();
          this.options.onCancel?.();
        }
        teardown() {
          this.state = "idle";
          this.stopDriver();
          this.startTime = this.holdTime = null;
        }
        stopDriver() {
          if (!this.driver) return;
          this.driver.stop();
          this.driver = void 0;
        }
        sample(sampleTime) {
          this.startTime = 0;
          return this.tick(sampleTime, true);
        }
        attachTimeline(timeline) {
          if (this.options.allowFlatten) {
            this.options.type = "keyframes";
            this.options.ease = "linear";
            this.initAnimation();
          }
          this.driver?.stop();
          return timeline.observe(this);
        }
      }

      function fillWildcards(keyframes) {
        for (let i = 1; i < keyframes.length; i++) {
          keyframes[i] ?? (keyframes[i] = keyframes[i - 1]);
        }
      }

      const radToDeg = (rad) => (rad * 180) / Math.PI;
      const rotate = (v) => {
        const angle = radToDeg(Math.atan2(v[1], v[0]));
        return rebaseAngle(angle);
      };
      const matrix2dParsers = {
        x: 4,
        y: 5,
        translateX: 4,
        translateY: 5,
        scaleX: 0,
        scaleY: 3,
        scale: (v) => (Math.abs(v[0]) + Math.abs(v[3])) / 2,
        rotate,
        rotateZ: rotate,
        skewX: (v) => radToDeg(Math.atan(v[1])),
        skewY: (v) => radToDeg(Math.atan(v[2])),
        skew: (v) => (Math.abs(v[1]) + Math.abs(v[2])) / 2,
      };
      const rebaseAngle = (angle) => {
        angle = angle % 360;
        if (angle < 0) angle += 360;
        return angle;
      };
      const rotateZ = rotate;
      const scaleX = (v) => Math.sqrt(v[0] * v[0] + v[1] * v[1]);
      const scaleY = (v) => Math.sqrt(v[4] * v[4] + v[5] * v[5]);
      const matrix3dParsers = {
        x: 12,
        y: 13,
        z: 14,
        translateX: 12,
        translateY: 13,
        translateZ: 14,
        scaleX,
        scaleY,
        scale: (v) => (scaleX(v) + scaleY(v)) / 2,
        rotateX: (v) => rebaseAngle(radToDeg(Math.atan2(v[6], v[5]))),
        rotateY: (v) => rebaseAngle(radToDeg(Math.atan2(-v[2], v[0]))),
        rotateZ,
        rotate: rotateZ,
        skewX: (v) => radToDeg(Math.atan(v[4])),
        skewY: (v) => radToDeg(Math.atan(v[1])),
        skew: (v) => (Math.abs(v[1]) + Math.abs(v[4])) / 2,
      };
      function defaultTransformValue(name) {
        return name.includes("scale") ? 1 : 0;
      }
      function parseValueFromTransform(transform, name) {
        if (!transform || transform === "none") {
          return defaultTransformValue(name);
        }
        const matrix3dMatch = transform.match(/^matrix3d\(([-\d.e\s,]+)\)$/u);
        let parsers;
        let match;
        if (matrix3dMatch) {
          parsers = matrix3dParsers;
          match = matrix3dMatch;
        } else {
          const matrix2dMatch = transform.match(/^matrix\(([-\d.e\s,]+)\)$/u);
          parsers = matrix2dParsers;
          match = matrix2dMatch;
        }
        if (!match) {
          return defaultTransformValue(name);
        }
        const valueParser = parsers[name];
        const values = match[1].split(",").map(convertTransformToNumber);
        return typeof valueParser === "function"
          ? valueParser(values)
          : values[valueParser];
      }
      const readTransformValue = (instance, name) => {
        const { transform = "none" } = getComputedStyle(instance);
        return parseValueFromTransform(transform, name);
      };
      function convertTransformToNumber(value) {
        return parseFloat(value.trim());
      }

      const transformPropOrder = [
        "transformPerspective",
        "x",
        "y",
        "z",
        "translateX",
        "translateY",
        "translateZ",
        "scale",
        "scaleX",
        "scaleY",
        "rotate",
        "rotateX",
        "rotateY",
        "rotateZ",
        "skew",
        "skewX",
        "skewY",
      ];

      const transformProps = /*@__PURE__*/ (() =>
        new Set(transformPropOrder))();

      const isNumOrPxType = (v) => v === number || v === px;
      const transformKeys = new Set(["x", "y", "z"]);
      const nonTranslationalTransformKeys = transformPropOrder.filter(
        (key) => !transformKeys.has(key),
      );
      function removeNonTranslationalTransform(visualElement) {
        const removedTransforms = [];
        nonTranslationalTransformKeys.forEach((key) => {
          const value = visualElement.getValue(key);
          if (value !== undefined) {
            removedTransforms.push([key, value.get()]);
            value.set(key.startsWith("scale") ? 1 : 0);
          }
        });
        return removedTransforms;
      }
      const positionalValues = {
        // Dimensions
        width: ({ x }, { paddingLeft = "0", paddingRight = "0" }) =>
          x.max - x.min - parseFloat(paddingLeft) - parseFloat(paddingRight),
        height: ({ y }, { paddingTop = "0", paddingBottom = "0" }) =>
          y.max - y.min - parseFloat(paddingTop) - parseFloat(paddingBottom),
        top: (_bbox, { top }) => parseFloat(top),
        left: (_bbox, { left }) => parseFloat(left),
        bottom: ({ y }, { top }) => parseFloat(top) + (y.max - y.min),
        right: ({ x }, { left }) => parseFloat(left) + (x.max - x.min),
        // Transform
        x: (_bbox, { transform }) => parseValueFromTransform(transform, "x"),
        y: (_bbox, { transform }) => parseValueFromTransform(transform, "y"),
      };
      // Alias translate longform names
      positionalValues.translateX = positionalValues.x;
      positionalValues.translateY = positionalValues.y;

      const toResolve = new Set();
      let isScheduled = false;
      let anyNeedsMeasurement = false;
      let isForced = false;
      function measureAllKeyframes() {
        if (anyNeedsMeasurement) {
          const resolversToMeasure = Array.from(toResolve).filter(
            (resolver) => resolver.needsMeasurement,
          );
          const elementsToMeasure = new Set(
            resolversToMeasure.map((resolver) => resolver.element),
          );
          const transformsToRestore = new Map();

          elementsToMeasure.forEach((element) => {
            const removedTransforms = removeNonTranslationalTransform(element);
            if (!removedTransforms.length) return;
            transformsToRestore.set(element, removedTransforms);
            element.render();
          });
          // Read
          resolversToMeasure.forEach((resolver) =>
            resolver.measureInitialState(),
          );
          // Write
          elementsToMeasure.forEach((element) => {
            element.render();
            const restore = transformsToRestore.get(element);
            if (restore) {
              restore.forEach(([key, value]) => {
                element.getValue(key)?.set(value);
              });
            }
          });
          // Read
          resolversToMeasure.forEach((resolver) => resolver.measureEndState());
          // Write
          resolversToMeasure.forEach((resolver) => {
            if (resolver.suspendedScrollY !== undefined) {
              window.scrollTo(0, resolver.suspendedScrollY);
            }
          });
        }
        anyNeedsMeasurement = false;
        isScheduled = false;
        toResolve.forEach((resolver) => resolver.complete(isForced));
        toResolve.clear();
      }
      function readAllKeyframes() {
        toResolve.forEach((resolver) => {
          resolver.readKeyframes();
          if (resolver.needsMeasurement) {
            anyNeedsMeasurement = true;
          }
        });
      }
      function flushKeyframeResolvers() {
        isForced = true;
        readAllKeyframes();
        measureAllKeyframes();
        isForced = false;
      }
      class KeyframeResolver {
        constructor(
          unresolvedKeyframes,
          onComplete,
          name,
          motionValue,
          element,
          isAsync = false,
        ) {
          this.state = "pending";

          this.isAsync = false;

          this.needsMeasurement = false;
          this.unresolvedKeyframes = [...unresolvedKeyframes];
          this.onComplete = onComplete;
          this.name = name;
          this.motionValue = motionValue;
          this.element = element;
          this.isAsync = isAsync;
        }
        scheduleResolve() {
          this.state = "scheduled";
          if (this.isAsync) {
            toResolve.add(this);
            if (!isScheduled) {
              isScheduled = true;
              frame.read(readAllKeyframes);
              frame.resolveKeyframes(measureAllKeyframes);
            }
          } else {
            this.readKeyframes();
            this.complete();
          }
        }
        readKeyframes() {
          const { unresolvedKeyframes, name, element, motionValue } = this;
          // If initial keyframe is null we need to read it from the DOM
          if (unresolvedKeyframes[0] === null) {
            const currentValue = motionValue?.get();
            // TODO: This doesn't work if the final keyframe is a wildcard
            const finalKeyframe =
              unresolvedKeyframes[unresolvedKeyframes.length - 1];
            if (currentValue !== undefined) {
              unresolvedKeyframes[0] = currentValue;
            } else if (element && name) {
              const valueAsRead = element.readValue(name, finalKeyframe);
              if (valueAsRead !== undefined && valueAsRead !== null) {
                unresolvedKeyframes[0] = valueAsRead;
              }
            }
            if (unresolvedKeyframes[0] === undefined) {
              unresolvedKeyframes[0] = finalKeyframe;
            }
            if (motionValue && currentValue === undefined) {
              motionValue.set(unresolvedKeyframes[0]);
            }
          }
          fillWildcards(unresolvedKeyframes);
        }
        setFinalKeyframe() {}
        measureInitialState() {}
        renderEndStyles() {}
        measureEndState() {}
        complete(isForcedComplete = false) {
          this.state = "complete";
          this.onComplete(
            this.unresolvedKeyframes,
            this.finalKeyframe,
            isForcedComplete,
          );
          toResolve.delete(this);
        }
        cancel() {
          if (this.state === "scheduled") {
            toResolve.delete(this);
            this.state = "pending";
          }
        }
        resume() {
          if (this.state === "pending") this.scheduleResolve();
        }
      }

      const isCSSVar = (name) => name.startsWith("--");

      function setStyle(element, name, value) {
        isCSSVar(name)
          ? element.style.setProperty(name, value)
          : (element.style[name] = value);
      }

      const supportsScrollTimeline = /* @__PURE__ */ memo(
        () => window.ScrollTimeline !== undefined,
      );

      const supportsFlags = {};

      function memoSupports(callback, supportsFlag) {
        const memoized = memo(callback);
        return () => supportsFlags[supportsFlag] ?? memoized();
      }

      const supportsLinearEasing = /*@__PURE__*/ memoSupports(() => {
        try {
          document
            .createElement("div")
            .animate({ opacity: 0 }, { easing: "linear(0, 1)" });
        } catch (e) {
          return false;
        }
        return true;
      }, "linearEasing");

      const cubicBezierAsString = ([a, b, c, d]) =>
        `cubic-bezier(${a}, ${b}, ${c}, ${d})`;

      const supportedWaapiEasing = {
        linear: "linear",
        ease: "ease",
        easeIn: "ease-in",
        easeOut: "ease-out",
        easeInOut: "ease-in-out",
        circIn: /*@__PURE__*/ cubicBezierAsString([0, 0.65, 0.55, 1]),
        circOut: /*@__PURE__*/ cubicBezierAsString([0.55, 0, 1, 0.45]),
        backIn: /*@__PURE__*/ cubicBezierAsString([0.31, 0.01, 0.66, -0.59]),
        backOut: /*@__PURE__*/ cubicBezierAsString([0.33, 1.53, 0.69, 0.99]),
      };

      function mapEasingToNativeEasing(easing, duration) {
        if (!easing) {
          return undefined;
        } else if (typeof easing === "function") {
          return supportsLinearEasing()
            ? generateLinearEasing(easing, duration)
            : "ease-out";
        } else if (isBezierDefinition(easing)) {
          return cubicBezierAsString(easing);
        } else if (Array.isArray(easing)) {
          return easing.map(
            (segmentEasing) =>
              mapEasingToNativeEasing(segmentEasing, duration) ||
              supportedWaapiEasing.easeOut,
          );
        } else {
          return supportedWaapiEasing[easing];
        }
      }

      function startWaapiAnimation(
        element,
        valueName,
        keyframes,
        {
          delay = 0,
          duration = 300,
          repeat = 0,
          repeatType = "loop",
          ease = "easeOut",
          times,
        } = {},
        pseudoElement = undefined,
      ) {
        const keyframeOptions = {
          [valueName]: keyframes,
        };
        if (times) keyframeOptions.offset = times;
        const easing = mapEasingToNativeEasing(ease, duration);

        if (Array.isArray(easing)) keyframeOptions.easing = easing;
        const options = {
          delay,
          duration,
          easing: !Array.isArray(easing) ? easing : "linear",
          fill: "both",
          iterations: repeat + 1,
          direction: repeatType === "reverse" ? "alternate" : "normal",
        };
        if (pseudoElement) options.pseudoElement = pseudoElement;
        const animation = element.animate(keyframeOptions, options);
        return animation;
      }

      function isGenerator(type) {
        return typeof type === "function" && "applyToOptions" in type;
      }

      function applyGeneratorOptions({ type, ...options }) {
        if (isGenerator(type) && supportsLinearEasing()) {
          return type.applyToOptions(options);
        } else {
          options.duration ?? (options.duration = 300);
          options.ease ?? (options.ease = "easeOut");
        }
        return options;
      }

      class NativeAnimation extends WithPromise {
        constructor(options) {
          super();
          this.finishedTime = null;
          this.isStopped = false;

          this.manualStartTime = null;
          if (!options) return;
          const {
            element,
            name,
            keyframes,
            pseudoElement,
            allowFlatten = false,
            finalKeyframe,
            onComplete,
          } = options;
          this.isPseudoElement = Boolean(pseudoElement);
          this.allowFlatten = allowFlatten;
          this.options = options;
          invariant(typeof options.type !== "string");
          const transition = applyGeneratorOptions(options);
          this.animation = startWaapiAnimation(
            element,
            name,
            keyframes,
            transition,
            pseudoElement,
          );
          if (transition.autoplay === false) {
            this.animation.pause();
          }
          this.animation.onfinish = () => {
            this.finishedTime = this.time;
            if (!pseudoElement) {
              const keyframe = getFinalKeyframe$1(
                keyframes,
                this.options,
                finalKeyframe,
                this.speed,
              );
              if (this.updateMotionValue) {
                this.updateMotionValue(keyframe);
              } else {
                setStyle(element, name, keyframe);
              }
              this.animation.cancel();
            }
            onComplete?.();
            this.notifyFinished();
          };
        }
        play() {
          if (this.isStopped) return;
          this.manualStartTime = null;
          this.animation.play();
          if (this.state === "finished") {
            this.updateFinished();
          }
        }
        pause() {
          this.animation.pause();
        }
        complete() {
          this.animation.finish?.();
        }
        cancel() {
          try {
            this.animation.cancel();
          } catch (e) {}
        }
        stop() {
          if (this.isStopped) return;
          this.isStopped = true;
          const { state } = this;
          if (state === "idle" || state === "finished") {
            return;
          }
          if (this.updateMotionValue) {
            this.updateMotionValue();
          } else {
            this.commitStyles();
          }
          if (!this.isPseudoElement) this.cancel();
        }

        commitStyles() {
          if (!this.isPseudoElement) {
            this.animation.commitStyles?.();
          }
        }
        get duration() {
          const duration =
            this.animation.effect?.getComputedTiming?.().duration || 0;
          return millisecondsToSeconds(Number(duration));
        }
        get iterationDuration() {
          const { delay = 0 } = this.options || {};
          return this.duration + millisecondsToSeconds(delay);
        }
        get time() {
          return millisecondsToSeconds(Number(this.animation.currentTime) || 0);
        }
        set time(newTime) {
          this.manualStartTime = null;
          this.finishedTime = null;
          this.animation.currentTime = secondsToMilliseconds(newTime);
        }

        get speed() {
          return this.animation.playbackRate;
        }
        set speed(newSpeed) {
          // Allow backwards playback after finishing
          if (newSpeed < 0) this.finishedTime = null;
          this.animation.playbackRate = newSpeed;
        }
        get state() {
          return this.finishedTime !== null
            ? "finished"
            : this.animation.playState;
        }
        get startTime() {
          return this.manualStartTime ?? Number(this.animation.startTime);
        }
        set startTime(newStartTime) {
          this.manualStartTime = this.animation.startTime = newStartTime;
        }

        attachTimeline({ timeline, observe }) {
          if (this.allowFlatten) {
            this.animation.effect?.updateTiming({ easing: "linear" });
          }
          this.animation.onfinish = null;
          if (timeline && supportsScrollTimeline()) {
            this.animation.timeline = timeline;
            return noop;
          } else {
            return observe(this);
          }
        }
      }

      const unsupportedEasingFunctions = {
        anticipate,
        backInOut,
        circInOut,
      };
      function isUnsupportedEase(key) {
        return key in unsupportedEasingFunctions;
      }
      function replaceStringEasing(transition) {
        if (
          typeof transition.ease === "string" &&
          isUnsupportedEase(transition.ease)
        ) {
          transition.ease = unsupportedEasingFunctions[transition.ease];
        }
      }

      const sampleDelta = 10; //ms
      class NativeAnimationExtended extends NativeAnimation {
        constructor(options) {
          replaceStringEasing(options);

          replaceTransitionType(options);
          super(options);
          if (options.startTime !== undefined) {
            this.startTime = options.startTime;
          }
          this.options = options;
        }

        updateMotionValue(value) {
          const { motionValue, onUpdate, onComplete, element, ...options } =
            this.options;
          if (!motionValue) return;
          if (value !== undefined) {
            motionValue.set(value);
            return;
          }
          const sampleAnimation = new JSAnimation({
            ...options,
            autoplay: false,
          });

          const sampleTime = Math.max(sampleDelta, time.now() - this.startTime);
          const delta = clamp(0, sampleDelta, sampleTime - sampleDelta);
          motionValue.setWithVelocity(
            sampleAnimation.sample(Math.max(0, sampleTime - delta)).value,
            sampleAnimation.sample(sampleTime).value,
            delta,
          );
          sampleAnimation.stop();
        }
      }

      const isAnimatable = (value, name) => {
        // If the list of keys that might be non-animatable grows, replace with Set
        if (name === "zIndex") return false;
        // If it's a number or a keyframes array, we can animate it. We might at some point
        // need to do a deep isAnimatable check of keyframes, or let Popmotion handle this,
        // but for now lets leave it like this for performance reasons
        if (typeof value === "number" || Array.isArray(value)) return true;
        if (
          typeof value === "string" && // It's animatable if we have a string
          (complex.test(value) || value === "0") && // And it contains numbers and/or colors
          !value.startsWith("url(") // Unless it starts with "url("
        ) {
          return true;
        }
        return false;
      };

      function hasKeyframesChanged(keyframes) {
        const current = keyframes[0];
        if (keyframes.length === 1) return true;
        for (let i = 0; i < keyframes.length; i++) {
          if (keyframes[i] !== current) return true;
        }
      }
      function canAnimate(keyframes, name, type, velocity) {
        const originKeyframe = keyframes[0];
        if (originKeyframe === null) return false;

        if (name === "display" || name === "visibility") return true;
        const targetKeyframe = keyframes[keyframes.length - 1];
        const isOriginAnimatable = isAnimatable(originKeyframe, name);
        const isTargetAnimatable = isAnimatable(targetKeyframe, name);
        // Always skip if any of these are true
        if (!isOriginAnimatable || !isTargetAnimatable) {
          return false;
        }
        return (
          hasKeyframesChanged(keyframes) ||
          ((type === "spring" || isGenerator(type)) && velocity)
        );
      }

      function makeAnimationInstant(options) {
        options.duration = 0;
        options.type = "keyframes";
      }

      const acceleratedValues = new Set([
        "opacity",
        "clipPath",
        "filter",
        "transform",
        // TODO: Could be re-enabled now we have support for linear() easing
        // "background-color"
      ]);
      const supportsWaapi = /*@__PURE__*/ memo(() =>
        Object.hasOwnProperty.call(Element.prototype, "animate"),
      );
      function supportsBrowserAnimation(options) {
        const { motionValue, name, repeatDelay, repeatType, damping, type } =
          options;
        const subject = motionValue?.owner?.current;

        if (!(subject instanceof HTMLElement)) {
          return false;
        }
        const { onUpdate, transformTemplate } = motionValue.owner.getProps();
        return (
          supportsWaapi() &&
          name &&
          acceleratedValues.has(name) &&
          (name !== "transform" || !transformTemplate) &&
          !onUpdate &&
          !repeatDelay &&
          repeatType !== "mirror" &&
          damping !== 0 &&
          type !== "inertia"
        );
      }

      const MAX_RESOLVE_DELAY = 40;
      class AsyncMotionValueAnimation extends WithPromise {
        constructor({
          autoplay = true,
          delay = 0,
          type = "keyframes",
          repeat = 0,
          repeatDelay = 0,
          repeatType = "loop",
          keyframes,
          name,
          motionValue,
          element,
          ...options
        }) {
          super();

          this.stop = () => {
            if (this._animation) {
              this._animation.stop();
              this.stopTimeline?.();
            }
            this.keyframeResolver?.cancel();
          };
          this.createdAt = time.now();
          const optionsWithDefaults = {
            autoplay,
            delay,
            type,
            repeat,
            repeatDelay,
            repeatType,
            name,
            motionValue,
            element,
            ...options,
          };
          const KeyframeResolver$1 =
            element?.KeyframeResolver || KeyframeResolver;
          this.keyframeResolver = new KeyframeResolver$1(
            keyframes,
            (resolvedKeyframes, finalKeyframe, forced) =>
              this.onKeyframesResolved(
                resolvedKeyframes,
                finalKeyframe,
                optionsWithDefaults,
                !forced,
              ),
            name,
            motionValue,
            element,
          );
          this.keyframeResolver?.scheduleResolve();
        }
        onKeyframesResolved(keyframes, finalKeyframe, options, sync) {
          this.keyframeResolver = undefined;
          const { name, type, velocity, delay, isHandoff, onUpdate } = options;
          this.resolvedAt = time.now();

          if (!canAnimate(keyframes, name, type, velocity)) {
            if (MotionGlobalConfig.instantAnimations || !delay) {
              onUpdate?.(getFinalKeyframe$1(keyframes, options, finalKeyframe));
            }
            keyframes[0] = keyframes[keyframes.length - 1];
            makeAnimationInstant(options);
            options.repeat = 0;
          }

          const startTime = sync
            ? !this.resolvedAt
              ? this.createdAt
              : this.resolvedAt - this.createdAt > MAX_RESOLVE_DELAY
                ? this.resolvedAt
                : this.createdAt
            : undefined;
          const resolvedOptions = {
            startTime,
            finalKeyframe,
            ...options,
            keyframes,
          };

          const animation =
            !isHandoff && supportsBrowserAnimation(resolvedOptions)
              ? new NativeAnimationExtended({
                  ...resolvedOptions,
                  element: resolvedOptions.motionValue.owner.current,
                })
              : new JSAnimation(resolvedOptions);
          animation.finished.then(() => this.notifyFinished()).catch(noop);
          if (this.pendingTimeline) {
            this.stopTimeline = animation.attachTimeline(this.pendingTimeline);
            this.pendingTimeline = undefined;
          }
          this._animation = animation;
        }
        get finished() {
          if (!this._animation) {
            return this._finished;
          } else {
            return this.animation.finished;
          }
        }
        then(onResolve, _onReject) {
          return this.finished.finally(onResolve).then(() => {});
        }
        get animation() {
          if (!this._animation) {
            this.keyframeResolver?.resume();
            flushKeyframeResolvers();
          }
          return this._animation;
        }
        get duration() {
          return this.animation.duration;
        }
        get iterationDuration() {
          return this.animation.iterationDuration;
        }
        get time() {
          return this.animation.time;
        }
        set time(newTime) {
          this.animation.time = newTime;
        }
        get speed() {
          return this.animation.speed;
        }
        get state() {
          return this.animation.state;
        }
        set speed(newSpeed) {
          this.animation.speed = newSpeed;
        }
        get startTime() {
          return this.animation.startTime;
        }
        attachTimeline(timeline) {
          if (this._animation) {
            this.stopTimeline = this.animation.attachTimeline(timeline);
          } else {
            this.pendingTimeline = timeline;
          }
          return () => this.stop();
        }
        play() {
          this.animation.play();
        }
        pause() {
          this.animation.pause();
        }
        complete() {
          this.animation.complete();
        }
        cancel() {
          if (this._animation) {
            this.animation.cancel();
          }
          this.keyframeResolver?.cancel();
        }
      }

      const splitCSSVariableRegex =
        // eslint-disable-next-line redos-detector/no-unsafe-regex -- false positive, as it can match a lot of words
        /^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u;
      function parseCSSVariable(current) {
        const match = splitCSSVariableRegex.exec(current);
        if (!match) return [,];
        const [, token1, token2, fallback] = match;
        return [`--${token1 ?? token2}`, fallback];
      }
      function getVariableValue(current, element, depth = 1) {
        const [token, fallback] = parseCSSVariable(current);
        // No CSS variable detected
        if (!token) return;
        // Attempt to read this CSS variable off the element
        const resolved = window
          .getComputedStyle(element)
          .getPropertyValue(token);
        if (resolved) {
          const trimmed = resolved.trim();
          return isNumericalString(trimmed) ? parseFloat(trimmed) : trimmed;
        }
        return isCSSVariableToken(fallback)
          ? getVariableValue(fallback, element, depth + 1)
          : fallback;
      }

      function getValueTransition(transition, key) {
        return transition?.[key] ?? transition?.["default"] ?? transition;
      }

      const underDampedSpring = {
        type: "spring",
        stiffness: 500,
        damping: 25,
        restSpeed: 10,
      };
      const criticallyDampedSpring = (target) => ({
        type: "spring",
        stiffness: 550,
        damping: target === 0 ? 2 * Math.sqrt(550) : 30,
        restSpeed: 10,
      });
      const keyframesTransition = {
        type: "keyframes",
        duration: 0.8,
      };

      const ease = {
        type: "keyframes",
        ease: [0.25, 0.1, 0.35, 1],
        duration: 0.3,
      };
      const getDefaultTransition = (valueKey, { keyframes }) => {
        if (keyframes.length > 2) {
          return keyframesTransition;
        } else if (transformProps.has(valueKey)) {
          return valueKey.startsWith("scale")
            ? criticallyDampedSpring(keyframes[1])
            : underDampedSpring;
        }
        return ease;
      };

      function isTransitionDefined({
        when,
        delay: _delay,
        delayChildren,
        staggerChildren,
        staggerDirection,
        repeat,
        repeatType,
        repeatDelay,
        from,
        elapsed,
        ...transition
      }) {
        return !!Object.keys(transition).length;
      }

      const isNotNull = (value) => value !== null;
      function getFinalKeyframe(
        keyframes,
        { repeat, repeatType = "loop" },
        finalKeyframe,
      ) {
        const resolvedKeyframes = keyframes.filter(isNotNull);
        const index =
          repeat && repeatType !== "loop" && repeat % 2 === 1
            ? 0
            : resolvedKeyframes.length - 1;
        return resolvedKeyframes[index];
      }

      function calcChildStagger(
        children,
        child,
        delayChildren,
        staggerChildren = 0,
        staggerDirection = 1,
      ) {
        const index = Array.from(children)
          .sort((a, b) => a.sortNodePosition(b))
          .indexOf(child);
        const numChildren = children.size;
        const maxStaggerDuration = (numChildren - 1) * staggerChildren;
        const delayIsFunction = typeof delayChildren === "function";
        return delayIsFunction
          ? delayChildren(index, numChildren)
          : staggerDirection === 1
            ? index * staggerChildren
            : maxStaggerDuration - index * staggerChildren;
      }

      const animateMotionValue =
        (name, value, target, transition = {}, element, isHandoff) =>
        (onComplete) => {
          const valueTransition = getValueTransition(transition, name) || {};

          const delay = valueTransition.delay || transition.delay || 0;

          let { elapsed = 0 } = transition;
          elapsed = elapsed - secondsToMilliseconds(delay);
          const options = {
            keyframes: Array.isArray(target) ? target : [null, target],
            ease: "easeOut",
            velocity: value.getVelocity(),
            ...valueTransition,
            delay: -elapsed,
            onUpdate: (v) => {
              value.set(v);
              valueTransition.onUpdate && valueTransition.onUpdate(v);
            },
            onComplete: () => {
              onComplete();
              valueTransition.onComplete && valueTransition.onComplete();
            },
            name,
            motionValue: value,
            element: isHandoff ? undefined : element,
          };

          if (!isTransitionDefined(valueTransition)) {
            Object.assign(options, getDefaultTransition(name, options));
          }

          options.duration &&
            (options.duration = secondsToMilliseconds(options.duration));
          options.repeatDelay &&
            (options.repeatDelay = secondsToMilliseconds(options.repeatDelay));

          if (options.from !== undefined) {
            options.keyframes[0] = options.from;
          }
          let shouldSkip = false;
          if (
            options.type === false ||
            (options.duration === 0 && !options.repeatDelay)
          ) {
            makeAnimationInstant(options);
            if (options.delay === 0) {
              shouldSkip = true;
            }
          }
          if (
            MotionGlobalConfig.instantAnimations ||
            MotionGlobalConfig.skipAnimations
          ) {
            shouldSkip = true;
            makeAnimationInstant(options);
            options.delay = 0;
          }

          options.allowFlatten = !valueTransition.type && !valueTransition.ease;

          if (shouldSkip && !isHandoff && value.get() !== undefined) {
            const finalKeyframe = getFinalKeyframe(
              options.keyframes,
              valueTransition,
            );
            if (finalKeyframe !== undefined) {
              frame.update(() => {
                options.onUpdate(finalKeyframe);
                options.onComplete();
              });
              return;
            }
          }
          return valueTransition.isSync
            ? new JSAnimation(options)
            : new AsyncMotionValueAnimation(options);
        };

      const positionalKeys = new Set([
        "width",
        "height",
        "top",
        "left",
        "right",
        "bottom",
        ...transformPropOrder,
      ]);

      const MAX_VELOCITY_DELTA = 30;
      const isFloat = (value) => {
        return !isNaN(parseFloat(value));
      };
      class MotionValue {
        constructor(init, options = {}) {
          this.canTrackVelocity = null;
          this.events = {};
          this.updateAndNotify = (v) => {
            const currentTime = time.now();
            if (this.updatedAt !== currentTime) {
              this.setPrevFrameValue();
            }
            this.prev = this.current;
            this.setCurrent(v);
            if (this.current !== this.prev) {
              this.events.change?.notify(this.current);
              if (this.dependents) {
                for (const dependent of this.dependents) {
                  dependent.dirty();
                }
              }
            }
          };
          this.hasAnimated = false;
          this.setCurrent(init);
          this.owner = options.owner;
        }
        setCurrent(current) {
          this.current = current;
          this.updatedAt = time.now();
          if (this.canTrackVelocity === null && current !== void 0) {
            this.canTrackVelocity = isFloat(this.current);
          }
        }
        setPrevFrameValue(prevFrameValue = this.current) {
          this.prevFrameValue = prevFrameValue;
          this.prevUpdatedAt = this.updatedAt;
        }

        onChange(subscription) {
          return this.on("change", subscription);
        }
        on(eventName, callback) {
          if (!this.events[eventName]) {
            this.events[eventName] = new SubscriptionManager();
          }
          const unsubscribe = this.events[eventName].add(callback);
          if (eventName === "change") {
            return () => {
              unsubscribe();
              frame.read(() => {
                if (!this.events.change.getSize()) {
                  this.stop();
                }
              });
            };
          }
          return unsubscribe;
        }
        clearListeners() {
          for (const eventManagers in this.events) {
            this.events[eventManagers].clear();
          }
        }

        attach(passiveEffect, stopPassiveEffect) {
          this.passiveEffect = passiveEffect;
          this.stopPassiveEffect = stopPassiveEffect;
        }

        set(v) {
          if (!this.passiveEffect) {
            this.updateAndNotify(v);
          } else {
            this.passiveEffect(v, this.updateAndNotify);
          }
        }
        setWithVelocity(prev, current, delta) {
          this.set(current);
          this.prev = void 0;
          this.prevFrameValue = prev;
          this.prevUpdatedAt = this.updatedAt - delta;
        }

        jump(v, endAnimation = true) {
          this.updateAndNotify(v);
          this.prev = v;
          this.prevUpdatedAt = this.prevFrameValue = void 0;
          endAnimation && this.stop();
          if (this.stopPassiveEffect) this.stopPassiveEffect();
        }
        dirty() {
          this.events.change?.notify(this.current);
        }
        addDependent(dependent) {
          if (!this.dependents) {
            this.dependents = /* @__PURE__ */ new Set();
          }
          this.dependents.add(dependent);
        }
        removeDependent(dependent) {
          if (this.dependents) {
            this.dependents.delete(dependent);
          }
        }

        get() {
          return this.current;
        }

        getPrevious() {
          return this.prev;
        }

        getVelocity() {
          const currentTime = time.now();
          if (
            !this.canTrackVelocity ||
            this.prevFrameValue === void 0 ||
            currentTime - this.updatedAt > MAX_VELOCITY_DELTA
          ) {
            return 0;
          }
          const delta = Math.min(
            this.updatedAt - this.prevUpdatedAt,
            MAX_VELOCITY_DELTA,
          );
          return velocityPerSecond(
            parseFloat(this.current) - parseFloat(this.prevFrameValue),
            delta,
          );
        }

        start(startAnimation) {
          this.stop();
          return new Promise((resolve) => {
            this.hasAnimated = true;
            this.animation = startAnimation(resolve);
            if (this.events.animationStart) {
              this.events.animationStart.notify();
            }
          }).then(() => {
            if (this.events.animationComplete) {
              this.events.animationComplete.notify();
            }
            this.clearAnimation();
          });
        }

        stop() {
          if (this.animation) {
            this.animation.stop();
            if (this.events.animationCancel) {
              this.events.animationCancel.notify();
            }
          }
          this.clearAnimation();
        }

        isAnimating() {
          return !!this.animation;
        }
        clearAnimation() {
          delete this.animation;
        }

        destroy() {
          this.dependents?.clear();
          this.events.destroy?.notify();
          this.clearListeners();
          this.stop();
          if (this.stopPassiveEffect) {
            this.stopPassiveEffect();
          }
        }
      }
      function motionValue(init, options) {
        return new MotionValue(init, options);
      }

      function getValueState(visualElement) {
        const state = [{}, {}];
        visualElement?.values.forEach((value, key) => {
          state[0][key] = value.get();
          state[1][key] = value.getVelocity();
        });
        return state;
      }
      function resolveVariantFromProps(
        props,
        definition,
        custom,
        visualElement,
      ) {
        if (typeof definition === "function") {
          const [current, velocity] = getValueState(visualElement);
          definition = definition(
            custom !== undefined ? custom : props.custom,
            current,
            velocity,
          );
        }

        if (typeof definition === "string") {
          definition = props.variants && props.variants[definition];
        }

        if (typeof definition === "function") {
          const [current, velocity] = getValueState(visualElement);
          definition = definition(
            custom !== undefined ? custom : props.custom,
            current,
            velocity,
          );
        }
        return definition;
      }

      function resolveVariant(visualElement, definition, custom) {
        const props = visualElement.getProps();
        return resolveVariantFromProps(
          props,
          definition,
          custom !== undefined ? custom : props.custom,
          visualElement,
        );
      }

      const isKeyframesTarget = (v) => {
        return Array.isArray(v);
      };

      function setMotionValue(visualElement, key, value) {
        if (visualElement.hasValue(key)) {
          visualElement.getValue(key).set(value);
        } else {
          visualElement.addValue(key, motionValue(value));
        }
      }
      function resolveFinalValueInKeyframes(v) {
        // TODO maybe throw if v.length - 1 is placeholder token?
        return isKeyframesTarget(v) ? v[v.length - 1] || 0 : v;
      }
      function setTarget(visualElement, definition) {
        const resolved = resolveVariant(visualElement, definition);
        let { transitionEnd = {}, transition = {}, ...target } = resolved || {};
        target = { ...target, ...transitionEnd };
        for (const key in target) {
          const value = resolveFinalValueInKeyframes(target[key]);
          setMotionValue(visualElement, key, value);
        }
      }

      const isMotionValue = (value) => Boolean(value && value.getVelocity);

      function isWillChangeMotionValue(value) {
        return Boolean(isMotionValue(value) && value.add);
      }

      function addValueToWillChange(visualElement, key) {
        const willChange = visualElement.getValue("willChange");

        if (isWillChangeMotionValue(willChange)) {
          return willChange.add(key);
        } else if (!willChange && MotionGlobalConfig.WillChange) {
          const newWillChange = new MotionGlobalConfig.WillChange("auto");
          visualElement.addValue("willChange", newWillChange);
          newWillChange.add(key);
        }
      }

      function camelToDash(str) {
        return str.replace(/([A-Z])/g, (match) => `-${match.toLowerCase()}`);
      }

      const optimizedAppearDataId = "framerAppearId";
      const optimizedAppearDataAttribute =
        "data-" + camelToDash(optimizedAppearDataId);

      function getOptimisedAppearId(visualElement) {
        return visualElement.props[optimizedAppearDataAttribute];
      }

      function shouldBlockAnimation({ protectedKeys, needsAnimating }, key) {
        const shouldBlock =
          protectedKeys.hasOwnProperty(key) && needsAnimating[key] !== true;
        needsAnimating[key] = false;
        return shouldBlock;
      }
      function animateTarget(
        visualElement,
        targetAndTransition,
        { delay = 0, transitionOverride, type } = {},
      ) {
        let {
          transition = visualElement.getDefaultTransition(),
          transitionEnd,
          ...target
        } = targetAndTransition;
        if (transitionOverride) transition = transitionOverride;
        const animations = [];
        const animationTypeState =
          type &&
          visualElement.animationState &&
          visualElement.animationState.getState()[type];
        for (const key in target) {
          const value = visualElement.getValue(
            key,
            visualElement.latestValues[key] ?? null,
          );
          const valueTarget = target[key];
          if (
            valueTarget === undefined ||
            (animationTypeState &&
              shouldBlockAnimation(animationTypeState, key))
          ) {
            continue;
          }
          const valueTransition = {
            delay,
            ...getValueTransition(transition || {}, key),
          };

          const currentValue = value.get();
          if (
            currentValue !== undefined &&
            !value.isAnimating &&
            !Array.isArray(valueTarget) &&
            valueTarget === currentValue &&
            !valueTransition.velocity
          ) {
            continue;
          }

          let isHandoff = false;
          if (window.MotionHandoffAnimation) {
            const appearId = getOptimisedAppearId(visualElement);
            if (appearId) {
              const startTime = window.MotionHandoffAnimation(
                appearId,
                key,
                frame,
              );
              if (startTime !== null) {
                valueTransition.startTime = startTime;
                isHandoff = true;
              }
            }
          }
          addValueToWillChange(visualElement, key);
          value.start(
            animateMotionValue(
              key,
              value,
              valueTarget,
              visualElement.shouldReduceMotion && positionalKeys.has(key)
                ? { type: false }
                : valueTransition,
              visualElement,
              isHandoff,
            ),
          );
          const animation = value.animation;
          if (animation) {
            animations.push(animation);
          }
        }
        if (transitionEnd) {
          Promise.all(animations).then(() => {
            frame.update(() => {
              transitionEnd && setTarget(visualElement, transitionEnd);
            });
          });
        }
        return animations;
      }

      function animateVariant(visualElement, variant, options = {}) {
        const resolved = resolveVariant(
          visualElement,
          variant,
          options.type === "exit"
            ? visualElement.presenceContext?.custom
            : undefined,
        );
        let { transition = visualElement.getDefaultTransition() || {} } =
          resolved || {};
        if (options.transitionOverride) {
          transition = options.transitionOverride;
        }

        const getAnimation = resolved
          ? () => Promise.all(animateTarget(visualElement, resolved, options))
          : () => Promise.resolve();

        const getChildAnimations =
          visualElement.variantChildren && visualElement.variantChildren.size
            ? (forwardDelay = 0) => {
                const {
                  delayChildren = 0,
                  staggerChildren,
                  staggerDirection,
                } = transition;
                return animateChildren(
                  visualElement,
                  variant,
                  forwardDelay,
                  delayChildren,
                  staggerChildren,
                  staggerDirection,
                  options,
                );
              }
            : () => Promise.resolve();

        const { when } = transition;
        if (when) {
          const [first, last] =
            when === "beforeChildren"
              ? [getAnimation, getChildAnimations]
              : [getChildAnimations, getAnimation];
          return first().then(() => last());
        } else {
          return Promise.all([
            getAnimation(),
            getChildAnimations(options.delay),
          ]);
        }
      }
      function animateChildren(
        visualElement,
        variant,
        delay = 0,
        delayChildren = 0,
        staggerChildren = 0,
        staggerDirection = 1,
        options,
      ) {
        const animations = [];
        for (const child of visualElement.variantChildren) {
          child.notify("AnimationStart", variant);
          animations.push(
            animateVariant(child, variant, {
              ...options,
              delay:
                delay +
                (typeof delayChildren === "function" ? 0 : delayChildren) +
                calcChildStagger(
                  visualElement.variantChildren,
                  child,
                  delayChildren,
                  staggerChildren,
                  staggerDirection,
                ),
            }).then(() => child.notify("AnimationComplete", variant)),
          );
        }
        return Promise.all(animations);
      }

      function animateVisualElement(visualElement, definition, options = {}) {
        visualElement.notify("AnimationStart", definition);
        let animation;
        if (Array.isArray(definition)) {
          const animations = definition.map((variant) =>
            animateVariant(visualElement, variant, options),
          );
          animation = Promise.all(animations);
        } else if (typeof definition === "string") {
          animation = animateVariant(visualElement, definition, options);
        } else {
          const resolvedDefinition =
            typeof definition === "function"
              ? resolveVariant(visualElement, definition, options.custom)
              : definition;
          animation = Promise.all(
            animateTarget(visualElement, resolvedDefinition, options),
          );
        }
        return animation.then(() => {
          visualElement.notify("AnimationComplete", definition);
        });
      }

      const auto = {
        test: (v) => v === "auto",
        parse: (v) => v,
      };

      const testValueType = (v) => (type) => type.test(v);

      const dimensionValueTypes = [number, px, percent, degrees, vw, vh, auto];

      const findDimensionValueType = (v) =>
        dimensionValueTypes.find(testValueType(v));

      function isNone(value) {
        if (typeof value === "number") {
          return value === 0;
        } else if (value !== null) {
          return value === "none" || value === "0" || isZeroValueString(value);
        } else {
          return true;
        }
      }

      const maxDefaults = new Set([
        "brightness",
        "contrast",
        "saturate",
        "opacity",
      ]);
      function applyDefaultFilter(v) {
        const [name, value] = v.slice(0, -1).split("(");
        if (name === "drop-shadow") return v;
        const [number] = value.match(floatRegex) || [];
        if (!number) return v;
        const unit = value.replace(number, "");
        let defaultValue = maxDefaults.has(name) ? 1 : 0;
        if (number !== value) defaultValue *= 100;
        return name + "(" + defaultValue + unit + ")";
      }
      const functionRegex = /\b([a-z-]*)\(.*?\)/gu;
      const filter = {
        ...complex,
        getAnimatableNone: (v) => {
          const functions = v.match(functionRegex);
          return functions ? functions.map(applyDefaultFilter).join(" ") : v;
        },
      };

      const int = {
        ...number,
        transform: Math.round,
      };

      const transformValueTypes = {
        rotate: degrees,
        rotateX: degrees,
        rotateY: degrees,
        rotateZ: degrees,
        scale,
        scaleX: scale,
        scaleY: scale,
        scaleZ: scale,
        skew: degrees,
        skewX: degrees,
        skewY: degrees,
        distance: px,
        translateX: px,
        translateY: px,
        translateZ: px,
        x: px,
        y: px,
        z: px,
        perspective: px,
        transformPerspective: px,
        opacity: alpha,
        originX: progressPercentage,
        originY: progressPercentage,
        originZ: px,
      };

      const numberValueTypes = {
        // Border props
        borderWidth: px,
        borderTopWidth: px,
        borderRightWidth: px,
        borderBottomWidth: px,
        borderLeftWidth: px,
        borderRadius: px,
        radius: px,
        borderTopLeftRadius: px,
        borderTopRightRadius: px,
        borderBottomRightRadius: px,
        borderBottomLeftRadius: px,
        // Positioning props
        width: px,
        maxWidth: px,
        height: px,
        maxHeight: px,
        top: px,
        right: px,
        bottom: px,
        left: px,
        inset: px,
        insetBlock: px,
        insetBlockStart: px,
        insetBlockEnd: px,
        insetInline: px,
        insetInlineStart: px,
        insetInlineEnd: px,
        // Spacing props
        padding: px,
        paddingTop: px,
        paddingRight: px,
        paddingBottom: px,
        paddingLeft: px,
        paddingBlock: px,
        paddingBlockStart: px,
        paddingBlockEnd: px,
        paddingInline: px,
        paddingInlineStart: px,
        paddingInlineEnd: px,
        margin: px,
        marginTop: px,
        marginRight: px,
        marginBottom: px,
        marginLeft: px,
        marginBlock: px,
        marginBlockStart: px,
        marginBlockEnd: px,
        marginInline: px,
        marginInlineStart: px,
        marginInlineEnd: px,
        // Misc
        backgroundPositionX: px,
        backgroundPositionY: px,
        ...transformValueTypes,
        zIndex: int,
        // SVG
        fillOpacity: alpha,
        strokeOpacity: alpha,
        numOctaves: int,
      };

      const defaultValueTypes = {
        ...numberValueTypes,
        // Color props
        color,
        backgroundColor: color,
        outlineColor: color,
        fill: color,
        stroke: color,
        // Border props
        borderColor: color,
        borderTopColor: color,
        borderRightColor: color,
        borderBottomColor: color,
        borderLeftColor: color,
        filter,
        WebkitFilter: filter,
      };

      const getDefaultValueType = (key) => defaultValueTypes[key];

      function getAnimatableNone(key, value) {
        let defaultValueType = getDefaultValueType(key);
        if (defaultValueType !== filter) defaultValueType = complex;
        // If value is not recognised as animatable, ie "none", create an animatable version origin based on the target
        return defaultValueType.getAnimatableNone
          ? defaultValueType.getAnimatableNone(value)
          : undefined;
      }

      const invalidTemplates = new Set(["auto", "none", "0"]);
      function makeNoneKeyframesAnimatable(
        unresolvedKeyframes,
        noneKeyframeIndexes,
        name,
      ) {
        let i = 0;
        let animatableTemplate = undefined;
        while (i < unresolvedKeyframes.length && !animatableTemplate) {
          const keyframe = unresolvedKeyframes[i];
          if (
            typeof keyframe === "string" &&
            !invalidTemplates.has(keyframe) &&
            analyseComplexValue(keyframe).values.length
          ) {
            animatableTemplate = unresolvedKeyframes[i];
          }
          i++;
        }
        if (animatableTemplate && name) {
          for (const noneIndex of noneKeyframeIndexes) {
            unresolvedKeyframes[noneIndex] = getAnimatableNone(
              name,
              animatableTemplate,
            );
          }
        }
      }

      class DOMKeyframesResolver extends KeyframeResolver {
        constructor(
          unresolvedKeyframes,
          onComplete,
          name,
          motionValue,
          element,
        ) {
          super(
            unresolvedKeyframes,
            onComplete,
            name,
            motionValue,
            element,
            true,
          );
        }
        readKeyframes() {
          const { unresolvedKeyframes, element, name } = this;
          if (!element || !element.current) return;
          super.readKeyframes();

          for (let i = 0; i < unresolvedKeyframes.length; i++) {
            let keyframe = unresolvedKeyframes[i];
            if (typeof keyframe === "string") {
              keyframe = keyframe.trim();
              if (isCSSVariableToken(keyframe)) {
                const resolved = getVariableValue(keyframe, element.current);
                if (resolved !== undefined) {
                  unresolvedKeyframes[i] = resolved;
                }
                if (i === unresolvedKeyframes.length - 1) {
                  this.finalKeyframe = keyframe;
                }
              }
            }
          }

          this.resolveNoneKeyframes();

          if (!positionalKeys.has(name) || unresolvedKeyframes.length !== 2) {
            return;
          }
          const [origin, target] = unresolvedKeyframes;
          const originType = findDimensionValueType(origin);
          const targetType = findDimensionValueType(target);

          const originHasVar = containsCSSVariable(origin);
          const targetHasVar = containsCSSVariable(target);
          if (originHasVar !== targetHasVar && positionalValues[name]) {
            this.needsMeasurement = true;
            return;
          }

          if (originType === targetType) return;

          if (isNumOrPxType(originType) && isNumOrPxType(targetType)) {
            for (let i = 0; i < unresolvedKeyframes.length; i++) {
              const value = unresolvedKeyframes[i];
              if (typeof value === "string") {
                unresolvedKeyframes[i] = parseFloat(value);
              }
            }
          } else if (positionalValues[name]) {
            this.needsMeasurement = true;
          }
        }
        resolveNoneKeyframes() {
          const { unresolvedKeyframes, name } = this;
          const noneKeyframeIndexes = [];
          for (let i = 0; i < unresolvedKeyframes.length; i++) {
            if (
              unresolvedKeyframes[i] === null ||
              isNone(unresolvedKeyframes[i])
            ) {
              noneKeyframeIndexes.push(i);
            }
          }
          if (noneKeyframeIndexes.length) {
            makeNoneKeyframesAnimatable(
              unresolvedKeyframes,
              noneKeyframeIndexes,
              name,
            );
          }
        }
        measureInitialState() {
          const { element, unresolvedKeyframes, name } = this;
          if (!element || !element.current) return;
          if (name === "height") {
            this.suspendedScrollY = window.pageYOffset;
          }
          this.measuredOrigin = positionalValues[name](
            element.measureViewportBox(),
            window.getComputedStyle(element.current),
          );
          unresolvedKeyframes[0] = this.measuredOrigin;
          // Set final key frame to measure after next render
          const measureKeyframe =
            unresolvedKeyframes[unresolvedKeyframes.length - 1];
          if (measureKeyframe !== undefined) {
            element
              .getValue(name, measureKeyframe)
              .jump(measureKeyframe, false);
          }
        }
        measureEndState() {
          const { element, name, unresolvedKeyframes } = this;
          if (!element || !element.current) return;
          const value = element.getValue(name);
          value && value.jump(this.measuredOrigin, false);
          const finalKeyframeIndex = unresolvedKeyframes.length - 1;
          const finalKeyframe = unresolvedKeyframes[finalKeyframeIndex];
          unresolvedKeyframes[finalKeyframeIndex] = positionalValues[name](
            element.measureViewportBox(),
            window.getComputedStyle(element.current),
          );
          if (finalKeyframe !== null && this.finalKeyframe === undefined) {
            this.finalKeyframe = finalKeyframe;
          }
          // If we removed transform values, reapply them before the next render
          if (this.removedTransforms?.length) {
            this.removedTransforms.forEach(
              ([unsetTransformName, unsetTransformValue]) => {
                element.getValue(unsetTransformName).set(unsetTransformValue);
              },
            );
          }
          this.resolveNoneKeyframes();
        }
      }

      function resolveElements(elementOrSelector, scope, selectorCache) {
        if (elementOrSelector instanceof EventTarget) {
          return [elementOrSelector];
        } else if (typeof elementOrSelector === "string") {
          let root = document;
          const elements =
            selectorCache?.[elementOrSelector] ??
            root.querySelectorAll(elementOrSelector);
          return elements ? Array.from(elements) : [];
        }
        return Array.from(elementOrSelector);
      }

      const getValueAsType = (value, type) => {
        return type && typeof value === "number"
          ? type.transform(value)
          : value;
      };

      function isHTMLElement(element) {
        return isObject(element) && "offsetHeight" in element;
      }

      const { schedule: microtask } = /* @__PURE__ */ createRenderBatcher(
        queueMicrotask,
        false,
      );

      const isDragging = {
        x: false,
        y: false,
      };
      function isDragActive() {
        return isDragging.x || isDragging.y;
      }

      function setDragLock(axis) {
        if (axis === "x" || axis === "y") {
          if (isDragging[axis]) {
            return null;
          } else {
            isDragging[axis] = true;
            return () => {
              isDragging[axis] = false;
            };
          }
        } else {
          if (isDragging.x || isDragging.y) {
            return null;
          } else {
            isDragging.x = isDragging.y = true;
            return () => {
              isDragging.x = isDragging.y = false;
            };
          }
        }
      }

      function setupGesture(elementOrSelector, options) {
        const elements = resolveElements(elementOrSelector);
        const gestureAbortController = new AbortController();
        const eventOptions = {
          passive: true,
          ...options,
          signal: gestureAbortController.signal,
        };
        const cancel = () => gestureAbortController.abort();
        return [elements, eventOptions, cancel];
      }

      function isValidHover(event) {
        return !(event.pointerType === "touch" || isDragActive());
      }

      function hover(elementOrSelector, onHoverStart, options = {}) {
        const [elements, eventOptions, cancel] = setupGesture(
          elementOrSelector,
          options,
        );
        const onPointerEnter = (enterEvent) => {
          if (!isValidHover(enterEvent)) return;
          const { target } = enterEvent;
          const onHoverEnd = onHoverStart(target, enterEvent);
          if (typeof onHoverEnd !== "function" || !target) return;
          const onPointerLeave = (leaveEvent) => {
            if (!isValidHover(leaveEvent)) return;
            onHoverEnd(leaveEvent);
            target.removeEventListener("pointerleave", onPointerLeave);
          };
          target.addEventListener("pointerleave", onPointerLeave, eventOptions);
        };
        elements.forEach((element) => {
          element.addEventListener(
            "pointerenter",
            onPointerEnter,
            eventOptions,
          );
        });
        return cancel;
      }

      const isNodeOrChild = (parent, child) => {
        if (!child) {
          return false;
        } else if (parent === child) {
          return true;
        } else {
          return isNodeOrChild(parent, child.parentElement);
        }
      };

      const isPrimaryPointer = (event) => {
        if (event.pointerType === "mouse") {
          return typeof event.button !== "number" || event.button <= 0;
        } else {
          return event.isPrimary !== false;
        }
      };

      const interactiveElements = new Set([
        "BUTTON",
        "INPUT",
        "SELECT",
        "TEXTAREA",
        "A",
      ]);

      function isElementKeyboardAccessible(element) {
        return (
          interactiveElements.has(element.tagName) ||
          element.isContentEditable === true
        );
      }

      const isPressing = new WeakSet();

      function filterEvents(callback) {
        return (event) => {
          if (event.key !== "Enter") return;
          callback(event);
        };
      }
      function firePointerEvent(target, type) {
        target.dispatchEvent(
          new PointerEvent("pointer" + type, {
            isPrimary: true,
            bubbles: true,
          }),
        );
      }
      const enableKeyboardPress = (focusEvent, eventOptions) => {
        const element = focusEvent.currentTarget;
        if (!element) return;
        const handleKeydown = filterEvents(() => {
          if (isPressing.has(element)) return;
          firePointerEvent(element, "down");
          const handleKeyup = filterEvents(() => {
            firePointerEvent(element, "up");
          });
          const handleBlur = () => firePointerEvent(element, "cancel");
          element.addEventListener("keyup", handleKeyup, eventOptions);
          element.addEventListener("blur", handleBlur, eventOptions);
        });
        element.addEventListener("keydown", handleKeydown, eventOptions);

        element.addEventListener(
          "blur",
          () => element.removeEventListener("keydown", handleKeydown),
          eventOptions,
        );
      };

      function isValidPressEvent(event) {
        return isPrimaryPointer(event) && !isDragActive();
      }

      function press(targetOrSelector, onPressStart, options = {}) {
        const [targets, eventOptions, cancelEvents] = setupGesture(
          targetOrSelector,
          options,
        );
        const startPress = (startEvent) => {
          const target = startEvent.currentTarget;
          if (!isValidPressEvent(startEvent)) return;
          isPressing.add(target);
          const onPressEnd = onPressStart(target, startEvent);
          const onPointerEnd = (endEvent, success) => {
            window.removeEventListener("pointerup", onPointerUp);
            window.removeEventListener("pointercancel", onPointerCancel);
            if (isPressing.has(target)) {
              isPressing.delete(target);
            }
            if (!isValidPressEvent(endEvent)) {
              return;
            }
            if (typeof onPressEnd === "function") {
              onPressEnd(endEvent, { success });
            }
          };
          const onPointerUp = (upEvent) => {
            onPointerEnd(
              upEvent,
              target === window ||
                target === document ||
                options.useGlobalTarget ||
                isNodeOrChild(target, upEvent.target),
            );
          };
          const onPointerCancel = (cancelEvent) => {
            onPointerEnd(cancelEvent, false);
          };
          window.addEventListener("pointerup", onPointerUp, eventOptions);
          window.addEventListener(
            "pointercancel",
            onPointerCancel,
            eventOptions,
          );
        };
        targets.forEach((target) => {
          const pointerDownTarget = options.useGlobalTarget ? window : target;
          pointerDownTarget.addEventListener(
            "pointerdown",
            startPress,
            eventOptions,
          );
          if (isHTMLElement(target)) {
            target.addEventListener("focus", (event) =>
              enableKeyboardPress(event, eventOptions),
            );
            if (
              !isElementKeyboardAccessible(target) &&
              !target.hasAttribute("tabindex")
            ) {
              target.tabIndex = 0;
            }
          }
        });
        return cancelEvents;
      }

      function isSVGElement(element) {
        return isObject(element) && "ownerSVGElement" in element;
      }

      function isSVGSVGElement(element) {
        return isSVGElement(element) && element.tagName === "svg";
      }

      const valueTypes = [...dimensionValueTypes, color, complex];

      const findValueType = (v) => valueTypes.find(testValueType(v));

      const createAxisDelta = () => ({
        translate: 0,
        scale: 1,
        origin: 0,
        originPoint: 0,
      });
      const createDelta = () => ({
        x: createAxisDelta(),
        y: createAxisDelta(),
      });
      const createAxis = () => ({ min: 0, max: 0 });
      const createBox = () => ({
        x: createAxis(),
        y: createAxis(),
      });

      // Does this device prefer reduced motion? Returns `null` server-side.
      const prefersReducedMotion = { current: null };
      const hasReducedMotionListener = { current: false };

      const isBrowser = typeof window !== "undefined";
      function initPrefersReducedMotion() {
        hasReducedMotionListener.current = true;
        if (!isBrowser) return;
        if (window.matchMedia) {
          const motionMediaQuery = window.matchMedia(
            "(prefers-reduced-motion)",
          );
          const setReducedMotionPreferences = () =>
            (prefersReducedMotion.current = motionMediaQuery.matches);
          motionMediaQuery.addEventListener(
            "change",
            setReducedMotionPreferences,
          );
          setReducedMotionPreferences();
        } else {
          prefersReducedMotion.current = false;
        }
      }

      const visualElementStore = new WeakMap();

      function isAnimationControls(v) {
        return (
          v !== null && typeof v === "object" && typeof v.start === "function"
        );
      }

      function isVariantLabel(v) {
        return typeof v === "string" || Array.isArray(v);
      }

      const variantPriorityOrder = [
        "animate",
        "whileInView",
        "whileFocus",
        "whileHover",
        "whileTap",
        "whileDrag",
        "exit",
      ];
      const variantProps = ["initial", ...variantPriorityOrder];

      function isControllingVariants(props) {
        return (
          isAnimationControls(props.animate) ||
          variantProps.some((name) => isVariantLabel(props[name]))
        );
      }
      function isVariantNode(props) {
        return Boolean(isControllingVariants(props) || props.variants);
      }

      function updateMotionValuesFromProps(element, next, prev) {
        for (const key in next) {
          const nextValue = next[key];
          const prevValue = prev[key];
          if (isMotionValue(nextValue)) {
            element.addValue(key, nextValue);
          } else if (isMotionValue(prevValue)) {
            element.addValue(key, motionValue(nextValue, { owner: element }));
          } else if (prevValue !== nextValue) {
            if (element.hasValue(key)) {
              const existingValue = element.getValue(key);
              if (existingValue.liveStyle === true) {
                existingValue.jump(nextValue);
              } else if (!existingValue.hasAnimated) {
                existingValue.set(nextValue);
              }
            } else {
              const latestValue = element.getStaticValue(key);
              element.addValue(
                key,
                motionValue(
                  latestValue !== undefined ? latestValue : nextValue,
                  { owner: element },
                ),
              );
            }
          }
        }
        // Handle removed values
        for (const key in prev) {
          if (next[key] === undefined) element.removeValue(key);
        }
        return next;
      }

      const propEventHandlers = [
        "AnimationStart",
        "AnimationComplete",
        "Update",
        "BeforeLayoutMeasure",
        "LayoutMeasure",
        "LayoutAnimationStart",
        "LayoutAnimationComplete",
      ];
      let featureDefinitions = {};
      function setFeatureDefinitions(definitions) {
        featureDefinitions = definitions;
      }
      function getFeatureDefinitions() {
        return featureDefinitions;
      }
      class VisualElement {
        scrapeMotionValuesFromProps(_props, _prevProps, _visualElement) {
          return {};
        }
        constructor(
          {
            parent,
            props,
            presenceContext,
            reducedMotionConfig,
            blockInitialAnimation,
            visualState,
          },
          options = {},
        ) {
          this.current = null;
          this.children = /* @__PURE__ */ new Set();
          this.isVariantNode = false;
          this.isControllingVariants = false;
          this.shouldReduceMotion = null;
          this.values = /* @__PURE__ */ new Map();
          this.KeyframeResolver = KeyframeResolver;
          this.features = {};
          this.valueSubscriptions = /* @__PURE__ */ new Map();
          this.prevMotionValues = {};
          this.events = {};
          this.propEventSubscriptions = {};
          this.notifyUpdate = () => this.notify("Update", this.latestValues);
          this.render = () => {
            if (!this.current) return;
            this.triggerBuild();
            this.renderInstance(
              this.current,
              this.renderState,
              this.props.style,
              this.projection,
            );
          };
          this.renderScheduledAt = 0;
          this.scheduleRender = () => {
            const now = time.now();
            if (this.renderScheduledAt < now) {
              this.renderScheduledAt = now;
              frame.render(this.render, false, true);
            }
          };
          const { latestValues, renderState } = visualState;
          this.latestValues = latestValues;
          this.baseTarget = { ...latestValues };
          this.initialValues = props.initial ? { ...latestValues } : {};
          this.renderState = renderState;
          this.parent = parent;
          this.props = props;
          this.presenceContext = presenceContext;
          this.depth = parent ? parent.depth + 1 : 0;
          this.reducedMotionConfig = reducedMotionConfig;
          this.options = options;
          this.blockInitialAnimation = Boolean(blockInitialAnimation);
          this.isControllingVariants = isControllingVariants(props);
          this.isVariantNode = isVariantNode(props);
          if (this.isVariantNode) {
            this.variantChildren = /* @__PURE__ */ new Set();
          }
          this.manuallyAnimateOnMount = Boolean(parent && parent.current);
          const { willChange, ...initialMotionValues } =
            this.scrapeMotionValuesFromProps(props, {}, this);
          for (const key in initialMotionValues) {
            const value = initialMotionValues[key];
            if (latestValues[key] !== void 0 && isMotionValue(value)) {
              value.set(latestValues[key]);
            }
          }
        }
        mount(instance) {
          this.current = instance;
          visualElementStore.set(instance, this);
          if (this.projection && !this.projection.instance) {
            this.projection.mount(instance);
          }
          if (
            this.parent &&
            this.isVariantNode &&
            !this.isControllingVariants
          ) {
            this.removeFromVariantTree = this.parent.addVariantChild(this);
          }
          this.values.forEach((value, key) =>
            this.bindToMotionValue(key, value),
          );
          if (this.reducedMotionConfig === "never") {
            this.shouldReduceMotion = false;
          } else if (this.reducedMotionConfig === "always") {
            this.shouldReduceMotion = true;
          } else {
            if (!hasReducedMotionListener.current) {
              initPrefersReducedMotion();
            }
            this.shouldReduceMotion = prefersReducedMotion.current;
          }
          this.parent?.addChild(this);
          this.update(this.props, this.presenceContext);
        }
        unmount() {
          this.projection && this.projection.unmount();
          cancelFrame(this.notifyUpdate);
          cancelFrame(this.render);
          this.valueSubscriptions.forEach((remove) => remove());
          this.valueSubscriptions.clear();
          this.removeFromVariantTree && this.removeFromVariantTree();
          this.parent?.removeChild(this);
          for (const key in this.events) {
            this.events[key].clear();
          }
          for (const key in this.features) {
            const feature = this.features[key];
            if (feature) {
              feature.unmount();
              feature.isMounted = false;
            }
          }
          this.current = null;
        }
        addChild(child) {
          this.children.add(child);
          this.enteringChildren ??
            (this.enteringChildren = /* @__PURE__ */ new Set());
          this.enteringChildren.add(child);
        }
        removeChild(child) {
          this.children.delete(child);
          this.enteringChildren && this.enteringChildren.delete(child);
        }
        bindToMotionValue(key, value) {
          if (this.valueSubscriptions.has(key)) {
            this.valueSubscriptions.get(key)();
          }
          const valueIsTransform = transformProps.has(key);
          if (valueIsTransform && this.onBindTransform) {
            this.onBindTransform();
          }
          const removeOnChange = value.on("change", (latestValue) => {
            this.latestValues[key] = latestValue;
            this.props.onUpdate && frame.preRender(this.notifyUpdate);
            if (valueIsTransform && this.projection) {
              this.projection.isTransformDirty = true;
            }
            this.scheduleRender();
          });
          let removeSyncCheck;
          if (typeof window !== "undefined" && window.MotionCheckAppearSync) {
            removeSyncCheck = window.MotionCheckAppearSync(this, key, value);
          }
          this.valueSubscriptions.set(key, () => {
            removeOnChange();
            if (removeSyncCheck) removeSyncCheck();
            if (value.owner) value.stop();
          });
        }
        sortNodePosition(other) {
          if (
            !this.current ||
            !this.sortInstanceNodePosition ||
            this.type !== other.type
          ) {
            return 0;
          }
          return this.sortInstanceNodePosition(this.current, other.current);
        }
        updateFeatures() {
          let key = "animation";
          for (key in featureDefinitions) {
            const featureDefinition = featureDefinitions[key];
            if (!featureDefinition) continue;
            const { isEnabled, Feature: FeatureConstructor } =
              featureDefinition;
            if (
              !this.features[key] &&
              FeatureConstructor &&
              isEnabled(this.props)
            ) {
              this.features[key] = new FeatureConstructor(this);
            }
            if (this.features[key]) {
              const feature = this.features[key];
              if (feature.isMounted) {
                feature.update();
              } else {
                feature.mount();
                feature.isMounted = true;
              }
            }
          }
        }
        triggerBuild() {
          this.build(this.renderState, this.latestValues, this.props);
        }

        measureViewportBox() {
          return this.current
            ? this.measureInstanceViewportBox(this.current, this.props)
            : createBox();
        }
        getStaticValue(key) {
          return this.latestValues[key];
        }
        setStaticValue(key, value) {
          this.latestValues[key] = value;
        }

        update(props, presenceContext) {
          if (props.transformTemplate || this.props.transformTemplate) {
            this.scheduleRender();
          }
          this.prevProps = this.props;
          this.props = props;
          this.prevPresenceContext = this.presenceContext;
          this.presenceContext = presenceContext;
          for (let i = 0; i < propEventHandlers.length; i++) {
            const key = propEventHandlers[i];
            if (this.propEventSubscriptions[key]) {
              this.propEventSubscriptions[key]();
              delete this.propEventSubscriptions[key];
            }
            const listenerName = "on" + key;
            const listener = props[listenerName];
            if (listener) {
              this.propEventSubscriptions[key] = this.on(key, listener);
            }
          }
          this.prevMotionValues = updateMotionValuesFromProps(
            this,
            this.scrapeMotionValuesFromProps(props, this.prevProps || {}, this),
            this.prevMotionValues,
          );
          if (this.handleChildMotionValue) {
            this.handleChildMotionValue();
          }
        }
        getProps() {
          return this.props;
        }

        getVariant(name) {
          return this.props.variants ? this.props.variants[name] : void 0;
        }

        getDefaultTransition() {
          return this.props.transition;
        }
        getTransformPagePoint() {
          return this.props.transformPagePoint;
        }
        getClosestVariantNode() {
          return this.isVariantNode
            ? this
            : this.parent
              ? this.parent.getClosestVariantNode()
              : void 0;
        }

        addVariantChild(child) {
          const closestVariantNode = this.getClosestVariantNode();
          if (closestVariantNode) {
            closestVariantNode.variantChildren &&
              closestVariantNode.variantChildren.add(child);
            return () => closestVariantNode.variantChildren.delete(child);
          }
        }

        addValue(key, value) {
          const existingValue = this.values.get(key);
          if (value !== existingValue) {
            if (existingValue) this.removeValue(key);
            this.bindToMotionValue(key, value);
            this.values.set(key, value);
            this.latestValues[key] = value.get();
          }
        }

        removeValue(key) {
          this.values.delete(key);
          const unsubscribe = this.valueSubscriptions.get(key);
          if (unsubscribe) {
            unsubscribe();
            this.valueSubscriptions.delete(key);
          }
          delete this.latestValues[key];
          this.removeValueFromRenderState(key, this.renderState);
        }

        hasValue(key) {
          return this.values.has(key);
        }
        getValue(key, defaultValue) {
          if (this.props.values && this.props.values[key]) {
            return this.props.values[key];
          }
          let value = this.values.get(key);
          if (value === void 0 && defaultValue !== void 0) {
            value = motionValue(defaultValue === null ? void 0 : defaultValue, {
              owner: this,
            });
            this.addValue(key, value);
          }
          return value;
        }

        readValue(key, target) {
          let value =
            this.latestValues[key] !== void 0 || !this.current
              ? this.latestValues[key]
              : (this.getBaseTargetFromProps(this.props, key) ??
                this.readValueFromInstance(this.current, key, this.options));
          if (value !== void 0 && value !== null) {
            if (
              typeof value === "string" &&
              (isNumericalString(value) || isZeroValueString(value))
            ) {
              value = parseFloat(value);
            } else if (!findValueType(value) && complex.test(target)) {
              value = getAnimatableNone(key, target);
            }
            this.setBaseTarget(key, isMotionValue(value) ? value.get() : value);
          }
          return isMotionValue(value) ? value.get() : value;
        }

        setBaseTarget(key, value) {
          this.baseTarget[key] = value;
        }

        getBaseTarget(key) {
          const { initial } = this.props;
          let valueFromInitial;
          if (typeof initial === "string" || typeof initial === "object") {
            const variant = resolveVariantFromProps(
              this.props,
              initial,
              this.presenceContext?.custom,
            );
            if (variant) {
              valueFromInitial = variant[key];
            }
          }
          if (initial && valueFromInitial !== void 0) {
            return valueFromInitial;
          }
          const target = this.getBaseTargetFromProps(this.props, key);
          if (target !== void 0 && !isMotionValue(target)) return target;
          return this.initialValues[key] !== void 0 &&
            valueFromInitial === void 0
            ? void 0
            : this.baseTarget[key];
        }
        on(eventName, callback) {
          if (!this.events[eventName]) {
            this.events[eventName] = new SubscriptionManager();
          }
          return this.events[eventName].add(callback);
        }
        notify(eventName, ...args) {
          if (this.events[eventName]) {
            this.events[eventName].notify(...args);
          }
        }
        scheduleRenderMicrotask() {
          microtask.render(this.render);
        }
      }

      class Feature {
        constructor(node) {
          this.isMounted = false;
          this.node = node;
        }
        update() {}
      }

      class DOMVisualElement extends VisualElement {
        constructor() {
          super(...arguments);
          this.KeyframeResolver = DOMKeyframesResolver;
        }
        sortInstanceNodePosition(a, b) {
          return a.compareDocumentPosition(b) & 2 ? 1 : -1;
        }
        getBaseTargetFromProps(props, key) {
          const style = props.style;
          return style ? style[key] : undefined;
        }
        removeValueFromRenderState(key, { vars, style }) {
          delete vars[key];
          delete style[key];
        }
        handleChildMotionValue() {
          if (this.childSubscription) {
            this.childSubscription();
            delete this.childSubscription;
          }
          const { children } = this.props;
          if (isMotionValue(children)) {
            this.childSubscription = children.on("change", (latest) => {
              if (this.current) {
                this.current.textContent = `${latest}`;
              }
            });
          }
        }
      }

      function convertBoundingBoxToBox({ top, left, right, bottom }) {
        return {
          x: { min: left, max: right },
          y: { min: top, max: bottom },
        };
      }
      function convertBoxToBoundingBox({ x, y }) {
        return { top: y.min, right: x.max, bottom: y.max, left: x.min };
      }

      function transformBoxPoints(point, transformPoint) {
        if (!transformPoint) return point;
        const topLeft = transformPoint({ x: point.left, y: point.top });
        const bottomRight = transformPoint({ x: point.right, y: point.bottom });
        return {
          top: topLeft.y,
          left: topLeft.x,
          bottom: bottomRight.y,
          right: bottomRight.x,
        };
      }

      function isIdentityScale(scale) {
        return scale === undefined || scale === 1;
      }
      function hasScale({ scale, scaleX, scaleY }) {
        return (
          !isIdentityScale(scale) ||
          !isIdentityScale(scaleX) ||
          !isIdentityScale(scaleY)
        );
      }
      function hasTransform(values) {
        return (
          hasScale(values) ||
          has2DTranslate(values) ||
          values.z ||
          values.rotate ||
          values.rotateX ||
          values.rotateY ||
          values.skewX ||
          values.skewY
        );
      }
      function has2DTranslate(values) {
        return is2DTranslate(values.x) || is2DTranslate(values.y);
      }
      function is2DTranslate(value) {
        return value && value !== "0%";
      }

      function scalePoint(point, scale, originPoint) {
        const distanceFromOrigin = point - originPoint;
        const scaled = scale * distanceFromOrigin;
        return originPoint + scaled;
      }

      function applyPointDelta(point, translate, scale, originPoint, boxScale) {
        if (boxScale !== undefined) {
          point = scalePoint(point, boxScale, originPoint);
        }
        return scalePoint(point, scale, originPoint) + translate;
      }

      function applyAxisDelta(
        axis,
        translate = 0,
        scale = 1,
        originPoint,
        boxScale,
      ) {
        axis.min = applyPointDelta(
          axis.min,
          translate,
          scale,
          originPoint,
          boxScale,
        );
        axis.max = applyPointDelta(
          axis.max,
          translate,
          scale,
          originPoint,
          boxScale,
        );
      }

      function applyBoxDelta(box, { x, y }) {
        applyAxisDelta(box.x, x.translate, x.scale, x.originPoint);
        applyAxisDelta(box.y, y.translate, y.scale, y.originPoint);
      }
      const TREE_SCALE_SNAP_MIN = 0.999999999999;
      const TREE_SCALE_SNAP_MAX = 1.0000000000001;

      function applyTreeDeltas(
        box,
        treeScale,
        treePath,
        isSharedTransition = false,
      ) {
        const treeLength = treePath.length;
        if (!treeLength) return;
        // Reset the treeScale
        treeScale.x = treeScale.y = 1;
        let node;
        let delta;
        for (let i = 0; i < treeLength; i++) {
          node = treePath[i];
          delta = node.projectionDelta;

          const { visualElement } = node.options;
          if (
            visualElement &&
            visualElement.props.style &&
            visualElement.props.style.display === "contents"
          ) {
            continue;
          }
          if (
            isSharedTransition &&
            node.options.layoutScroll &&
            node.scroll &&
            node !== node.root
          ) {
            transformBox(box, {
              x: -node.scroll.offset.x,
              y: -node.scroll.offset.y,
            });
          }
          if (delta) {
            // Incoporate each ancestor's scale into a cumulative treeScale for this component
            treeScale.x *= delta.x.scale;
            treeScale.y *= delta.y.scale;
            // Apply each ancestor's calculated delta into this component's recorded layout box
            applyBoxDelta(box, delta);
          }
          if (isSharedTransition && hasTransform(node.latestValues)) {
            transformBox(box, node.latestValues);
          }
        }

        if (
          treeScale.x < TREE_SCALE_SNAP_MAX &&
          treeScale.x > TREE_SCALE_SNAP_MIN
        ) {
          treeScale.x = 1.0;
        }
        if (
          treeScale.y < TREE_SCALE_SNAP_MAX &&
          treeScale.y > TREE_SCALE_SNAP_MIN
        ) {
          treeScale.y = 1.0;
        }
      }
      function translateAxis(axis, distance) {
        axis.min = axis.min + distance;
        axis.max = axis.max + distance;
      }

      function transformAxis(
        axis,
        axisTranslate,
        axisScale,
        boxScale,
        axisOrigin = 0.5,
      ) {
        const originPoint = mixNumber$1(axis.min, axis.max, axisOrigin);
        // Apply the axis delta to the final axis
        applyAxisDelta(axis, axisTranslate, axisScale, originPoint, boxScale);
      }

      function transformBox(box, transform) {
        transformAxis(
          box.x,
          transform.x,
          transform.scaleX,
          transform.scale,
          transform.originX,
        );
        transformAxis(
          box.y,
          transform.y,
          transform.scaleY,
          transform.scale,
          transform.originY,
        );
      }

      function measureViewportBox(instance, transformPoint) {
        return convertBoundingBoxToBox(
          transformBoxPoints(instance.getBoundingClientRect(), transformPoint),
        );
      }
      function measurePageBox(element, rootProjectionNode, transformPagePoint) {
        const viewportBox = measureViewportBox(element, transformPagePoint);
        const { scroll } = rootProjectionNode;
        if (scroll) {
          translateAxis(viewportBox.x, scroll.offset.x);
          translateAxis(viewportBox.y, scroll.offset.y);
        }
        return viewportBox;
      }

      const translateAlias = {
        x: "translateX",
        y: "translateY",
        z: "translateZ",
        transformPerspective: "perspective",
      };
      const numTransforms = transformPropOrder.length;

      function buildTransform(latestValues, transform, transformTemplate) {
        // The transform string we're going to build into.
        let transformString = "";
        let transformIsDefault = true;

        for (let i = 0; i < numTransforms; i++) {
          const key = transformPropOrder[i];
          const value = latestValues[key];
          if (value === undefined) continue;
          let valueIsDefault = true;
          if (typeof value === "number") {
            valueIsDefault = value === (key.startsWith("scale") ? 1 : 0);
          } else {
            valueIsDefault = parseFloat(value) === 0;
          }
          if (!valueIsDefault || transformTemplate) {
            const valueAsType = getValueAsType(value, numberValueTypes[key]);
            if (!valueIsDefault) {
              transformIsDefault = false;
              const transformName = translateAlias[key] || key;
              transformString += `${transformName}(${valueAsType}) `;
            }
            if (transformTemplate) {
              transform[key] = valueAsType;
            }
          }
        }
        transformString = transformString.trim();
        // If we have a custom `transform` template, pass our transform values and
        // generated transformString to that before returning
        if (transformTemplate) {
          transformString = transformTemplate(
            transform,
            transformIsDefault ? "" : transformString,
          );
        } else if (transformIsDefault) {
          transformString = "none";
        }
        return transformString;
      }

      function buildHTMLStyles(state, latestValues, transformTemplate) {
        const { style, vars, transformOrigin } = state;
        // Track whether we encounter any transform or transformOrigin values.
        let hasTransform = false;
        let hasTransformOrigin = false;

        for (const key in latestValues) {
          const value = latestValues[key];
          if (transformProps.has(key)) {
            // If this is a transform, flag to enable further transform processing
            hasTransform = true;
            continue;
          } else if (isCSSVariableName(key)) {
            vars[key] = value;
            continue;
          } else {
            // Convert the value to its default value type, ie 0 -> "0px"
            const valueAsType = getValueAsType(value, numberValueTypes[key]);
            if (key.startsWith("origin")) {
              // If this is a transform origin, flag and enable further transform-origin processing
              hasTransformOrigin = true;
              transformOrigin[key] = valueAsType;
            } else {
              style[key] = valueAsType;
            }
          }
        }
        if (!latestValues.transform) {
          if (hasTransform || transformTemplate) {
            style.transform = buildTransform(
              latestValues,
              state.transform,
              transformTemplate,
            );
          } else if (style.transform) {
            style.transform = "none";
          }
        }

        if (hasTransformOrigin) {
          const {
            originX = "50%",
            originY = "50%",
            originZ = 0,
          } = transformOrigin;
          style.transformOrigin = `${originX} ${originY} ${originZ}`;
        }
      }

      function renderHTML(element, { style, vars }, styleProp, projection) {
        const elementStyle = element.style;
        let key;
        for (key in style) {
          // CSSStyleDeclaration has [index: number]: string; in the types, so we use that as key type.
          elementStyle[key] = style[key];
        }
        // Write projection styles directly to element style
        projection?.applyProjectionStyles(elementStyle, styleProp);
        for (key in vars) {
          // Loop over any CSS variables and assign those.
          // They can only be assigned using `setProperty`.
          elementStyle.setProperty(key, vars[key]);
        }
      }

      function pixelsToPercent(pixels, axis) {
        if (axis.max === axis.min) return 0;
        return (pixels / (axis.max - axis.min)) * 100;
      }

      const correctBorderRadius = {
        correct: (latest, node) => {
          if (!node.target) return latest;

          if (typeof latest === "string") {
            if (px.test(latest)) {
              latest = parseFloat(latest);
            } else {
              return latest;
            }
          }

          const x = pixelsToPercent(latest, node.target.x);
          const y = pixelsToPercent(latest, node.target.y);
          return `${x}% ${y}%`;
        },
      };

      const correctBoxShadow = {
        correct: (latest, { treeScale, projectionDelta }) => {
          const original = latest;
          const shadow = complex.parse(latest);
          // TODO: Doesn't support multiple shadows
          if (shadow.length > 5) return original;
          const template = complex.createTransformer(latest);
          const offset = typeof shadow[0] !== "number" ? 1 : 0;
          // Calculate the overall context scale
          const xScale = projectionDelta.x.scale * treeScale.x;
          const yScale = projectionDelta.y.scale * treeScale.y;
          shadow[0 + offset] /= xScale;
          shadow[1 + offset] /= yScale;

          const averageScale = mixNumber$1(xScale, yScale, 0.5);
          // Blur
          if (typeof shadow[2 + offset] === "number")
            shadow[2 + offset] /= averageScale;
          // Spread
          if (typeof shadow[3 + offset] === "number")
            shadow[3 + offset] /= averageScale;
          return template(shadow);
        },
      };

      const scaleCorrectors = {
        borderRadius: {
          ...correctBorderRadius,
          applyTo: [
            "borderTopLeftRadius",
            "borderTopRightRadius",
            "borderBottomLeftRadius",
            "borderBottomRightRadius",
          ],
        },
        borderTopLeftRadius: correctBorderRadius,
        borderTopRightRadius: correctBorderRadius,
        borderBottomLeftRadius: correctBorderRadius,
        borderBottomRightRadius: correctBorderRadius,
        boxShadow: correctBoxShadow,
      };

      function isForcedMotionValue(key, { layout, layoutId }) {
        return (
          transformProps.has(key) ||
          key.startsWith("origin") ||
          ((layout || layoutId !== undefined) &&
            (!!scaleCorrectors[key] || key === "opacity"))
        );
      }

      function scrapeMotionValuesFromProps$1(props, prevProps, visualElement) {
        const style = props.style;
        const prevStyle = prevProps?.style;
        const newValues = {};
        if (!style) return newValues;
        for (const key in style) {
          if (
            isMotionValue(style[key]) ||
            (prevStyle && isMotionValue(prevStyle[key])) ||
            isForcedMotionValue(key, props) ||
            visualElement?.getValue(key)?.liveStyle !== undefined
          ) {
            newValues[key] = style[key];
          }
        }
        return newValues;
      }

      function getComputedStyle$1(element) {
        return window.getComputedStyle(element);
      }
      class HTMLVisualElement extends DOMVisualElement {
        constructor() {
          super(...arguments);
          this.type = "html";
          this.renderInstance = renderHTML;
        }
        readValueFromInstance(instance, key) {
          if (transformProps.has(key)) {
            return this.projection?.isProjecting
              ? defaultTransformValue(key)
              : readTransformValue(instance, key);
          } else {
            const computedStyle = getComputedStyle$1(instance);
            const value =
              (isCSSVariableName(key)
                ? computedStyle.getPropertyValue(key)
                : computedStyle[key]) || 0;
            return typeof value === "string" ? value.trim() : value;
          }
        }
        measureInstanceViewportBox(instance, { transformPagePoint }) {
          return measureViewportBox(instance, transformPagePoint);
        }
        build(renderState, latestValues, props) {
          buildHTMLStyles(renderState, latestValues, props.transformTemplate);
        }
        scrapeMotionValuesFromProps(props, prevProps, visualElement) {
          return scrapeMotionValuesFromProps$1(props, prevProps, visualElement);
        }
      }

      const dashKeys = {
        offset: "stroke-dashoffset",
        array: "stroke-dasharray",
      };
      const camelKeys = {
        offset: "strokeDashoffset",
        array: "strokeDasharray",
      };

      function buildSVGPath(
        attrs,
        length,
        spacing = 1,
        offset = 0,
        useDashCase = true,
      ) {
        // Normalise path length by setting SVG attribute pathLength to 1
        attrs.pathLength = 1;
        // We use dash case when setting attributes directly to the DOM node and camel case
        // when defining props on a React component.
        const keys = useDashCase ? dashKeys : camelKeys;
        // Build the dash offset
        attrs[keys.offset] = px.transform(-offset);
        // Build the dash array
        const pathLength = px.transform(length);
        const pathSpacing = px.transform(spacing);
        attrs[keys.array] = `${pathLength} ${pathSpacing}`;
      }

      const cssMotionPathProperties = [
        "offsetDistance",
        "offsetPath",
        "offsetRotate",
        "offsetAnchor",
      ];

      function buildSVGAttrs(
        state,
        {
          attrX,
          attrY,
          attrScale,
          pathLength,
          pathSpacing = 1,
          pathOffset = 0,
          // This is object creation, which we try to avoid per-frame.
          ...latest
        },
        isSVGTag,
        transformTemplate,
        styleProp,
      ) {
        buildHTMLStyles(state, latest, transformTemplate);

        if (isSVGTag) {
          if (state.style.viewBox) {
            state.attrs.viewBox = state.style.viewBox;
          }
          return;
        }
        state.attrs = state.style;
        state.style = {};
        const { attrs, style } = state;

        if (attrs.transform) {
          style.transform = attrs.transform;
          delete attrs.transform;
        }
        if (style.transform || attrs.transformOrigin) {
          style.transformOrigin = attrs.transformOrigin ?? "50% 50%";
          delete attrs.transformOrigin;
        }
        if (style.transform) {
          style.transformBox = styleProp?.transformBox ?? "fill-box";
          delete attrs.transformBox;
        }
        for (const key of cssMotionPathProperties) {
          if (attrs[key] !== undefined) {
            style[key] = attrs[key];
            delete attrs[key];
          }
        }
        // Render attrX/attrY/attrScale as attributes
        if (attrX !== undefined) attrs.x = attrX;
        if (attrY !== undefined) attrs.y = attrY;
        if (attrScale !== undefined) attrs.scale = attrScale;
        // Build SVG path if one has been defined
        if (pathLength !== undefined) {
          buildSVGPath(attrs, pathLength, pathSpacing, pathOffset, false);
        }
      }

      const camelCaseAttributes = new Set([
        "baseFrequency",
        "diffuseConstant",
        "kernelMatrix",
        "kernelUnitLength",
        "keySplines",
        "keyTimes",
        "limitingConeAngle",
        "markerHeight",
        "markerWidth",
        "numOctaves",
        "targetX",
        "targetY",
        "surfaceScale",
        "specularConstant",
        "specularExponent",
        "stdDeviation",
        "tableValues",
        "viewBox",
        "gradientTransform",
        "pathLength",
        "startOffset",
        "textLength",
        "lengthAdjust",
      ]);

      const isSVGTag = (tag) =>
        typeof tag === "string" && tag.toLowerCase() === "svg";

      function renderSVG(element, renderState, _styleProp, projection) {
        renderHTML(element, renderState, undefined, projection);
        for (const key in renderState.attrs) {
          element.setAttribute(
            !camelCaseAttributes.has(key) ? camelToDash(key) : key,
            renderState.attrs[key],
          );
        }
      }

      function scrapeMotionValuesFromProps(props, prevProps, visualElement) {
        const newValues = scrapeMotionValuesFromProps$1(
          props,
          prevProps,
          visualElement,
        );
        for (const key in props) {
          if (isMotionValue(props[key]) || isMotionValue(prevProps[key])) {
            const targetKey =
              transformPropOrder.indexOf(key) !== -1
                ? "attr" + key.charAt(0).toUpperCase() + key.substring(1)
                : key;
            newValues[targetKey] = props[key];
          }
        }
        return newValues;
      }

      class SVGVisualElement extends DOMVisualElement {
        constructor() {
          super(...arguments);
          this.type = "svg";
          this.isSVGTag = false;
          this.measureInstanceViewportBox = createBox;
        }
        getBaseTargetFromProps(props, key) {
          return props[key];
        }
        readValueFromInstance(instance, key) {
          if (transformProps.has(key)) {
            const defaultType = getDefaultValueType(key);
            return defaultType ? defaultType.default || 0 : 0;
          }
          key = !camelCaseAttributes.has(key) ? camelToDash(key) : key;
          return instance.getAttribute(key);
        }
        scrapeMotionValuesFromProps(props, prevProps, visualElement) {
          return scrapeMotionValuesFromProps(props, prevProps, visualElement);
        }
        build(renderState, latestValues, props) {
          buildSVGAttrs(
            renderState,
            latestValues,
            this.isSVGTag,
            props.transformTemplate,
            props.style,
          );
        }
        renderInstance(instance, renderState, styleProp, projection) {
          renderSVG(instance, renderState, styleProp, projection);
        }
        mount(instance) {
          this.isSVGTag = isSVGTag(instance.tagName);
          super.mount(instance);
        }
      }

      const numVariantProps = variantProps.length;

      function getVariantContext(visualElement) {
        if (!visualElement) return undefined;
        if (!visualElement.isControllingVariants) {
          const context = visualElement.parent
            ? getVariantContext(visualElement.parent) || {}
            : {};
          if (visualElement.props.initial !== undefined) {
            context.initial = visualElement.props.initial;
          }
          return context;
        }
        const context = {};
        for (let i = 0; i < numVariantProps; i++) {
          const name = variantProps[i];
          const prop = visualElement.props[name];
          if (isVariantLabel(prop) || prop === false) {
            context[name] = prop;
          }
        }
        return context;
      }

      function shallowCompare(next, prev) {
        if (!Array.isArray(prev)) return false;
        const prevLength = prev.length;
        if (prevLength !== next.length) return false;
        for (let i = 0; i < prevLength; i++) {
          if (prev[i] !== next[i]) return false;
        }
        return true;
      }

      const reversePriorityOrder = [...variantPriorityOrder].reverse();
      const numAnimationTypes = variantPriorityOrder.length;
      function createAnimateFunction(visualElement) {
        return (animations) => {
          return Promise.all(
            animations.map(({ animation, options }) =>
              animateVisualElement(visualElement, animation, options),
            ),
          );
        };
      }
      function createAnimationState(visualElement) {
        let animate = createAnimateFunction(visualElement);
        let state = createState();
        let isInitialRender = true;

        const buildResolvedTypeValues = (type) => (acc, definition) => {
          const resolved = resolveVariant(
            visualElement,
            definition,
            type === "exit" ? visualElement.presenceContext?.custom : undefined,
          );
          if (resolved) {
            const { transition, transitionEnd, ...target } = resolved;
            acc = { ...acc, ...target, ...transitionEnd };
          }
          return acc;
        };

        function setAnimateFunction(makeAnimator) {
          animate = makeAnimator(visualElement);
        }

        function animateChanges(changedActiveType) {
          const { props } = visualElement;
          const context = getVariantContext(visualElement.parent) || {};

          const animations = [];

          const removedKeys = new Set();

          let encounteredKeys = {};

          let removedVariantIndex = Infinity;

          for (let i = 0; i < numAnimationTypes; i++) {
            const type = reversePriorityOrder[i];
            const typeState = state[type];
            const prop =
              props[type] !== undefined ? props[type] : context[type];
            const propIsVariant = isVariantLabel(prop);

            const activeDelta =
              type === changedActiveType ? typeState.isActive : null;
            if (activeDelta === false) removedVariantIndex = i;

            let isInherited =
              prop === context[type] && prop !== props[type] && propIsVariant;
            if (
              isInherited &&
              isInitialRender &&
              visualElement.manuallyAnimateOnMount
            ) {
              isInherited = false;
            }

            typeState.protectedKeys = { ...encounteredKeys };
            // Check if we can skip analysing this prop early
            if (
              // If it isn't active and hasn't *just* been set as inactive
              (!typeState.isActive && activeDelta === null) ||
              // If we didn't and don't have any defined prop for this animation type
              (!prop && !typeState.prevProp) ||
              // Or if the prop doesn't define an animation
              isAnimationControls(prop) ||
              typeof prop === "boolean"
            ) {
              continue;
            }

            const variantDidChange = checkVariantsDidChange(
              typeState.prevProp,
              prop,
            );
            let shouldAnimateType =
              variantDidChange ||
              // If we're making this variant active, we want to always make it active
              (type === changedActiveType &&
                typeState.isActive &&
                !isInherited &&
                propIsVariant) ||
              // If we removed a higher-priority variant (i is in reverse order)
              (i > removedVariantIndex && propIsVariant);
            let handledRemovedValues = false;

            const definitionList = Array.isArray(prop) ? prop : [prop];

            let resolvedValues = definitionList.reduce(
              buildResolvedTypeValues(type),
              {},
            );
            if (activeDelta === false) resolvedValues = {};

            const { prevResolvedValues = {} } = typeState;
            const allKeys = {
              ...prevResolvedValues,
              ...resolvedValues,
            };
            const markToAnimate = (key) => {
              shouldAnimateType = true;
              if (removedKeys.has(key)) {
                handledRemovedValues = true;
                removedKeys.delete(key);
              }
              typeState.needsAnimating[key] = true;
              const motionValue = visualElement.getValue(key);
              if (motionValue) motionValue.liveStyle = false;
            };
            for (const key in allKeys) {
              const next = resolvedValues[key];
              const prev = prevResolvedValues[key];
              // If we've already handled this we can just skip ahead
              if (encounteredKeys.hasOwnProperty(key)) continue;

              let valueHasChanged = false;
              if (isKeyframesTarget(next) && isKeyframesTarget(prev)) {
                valueHasChanged = !shallowCompare(next, prev);
              } else {
                valueHasChanged = next !== prev;
              }
              if (valueHasChanged) {
                if (next !== undefined && next !== null) {
                  // If next is defined and doesn't equal prev, it needs animating
                  markToAnimate(key);
                } else {
                  // If it's undefined, it's been removed.
                  removedKeys.add(key);
                }
              } else if (next !== undefined && removedKeys.has(key)) {
                markToAnimate(key);
              } else {
                typeState.protectedKeys[key] = true;
              }
            }

            typeState.prevProp = prop;
            typeState.prevResolvedValues = resolvedValues;
            if (typeState.isActive) {
              encounteredKeys = { ...encounteredKeys, ...resolvedValues };
            }
            if (isInitialRender && visualElement.blockInitialAnimation) {
              shouldAnimateType = false;
            }

            const willAnimateViaParent = isInherited && variantDidChange;
            const needsAnimating =
              !willAnimateViaParent || handledRemovedValues;
            if (shouldAnimateType && needsAnimating) {
              animations.push(
                ...definitionList.map((animation) => {
                  const options = { type };

                  if (
                    typeof animation === "string" &&
                    isInitialRender &&
                    !willAnimateViaParent &&
                    visualElement.manuallyAnimateOnMount &&
                    visualElement.parent
                  ) {
                    const { parent } = visualElement;
                    const parentVariant = resolveVariant(parent, animation);
                    if (parent.enteringChildren && parentVariant) {
                      const { delayChildren } = parentVariant.transition || {};
                      options.delay = calcChildStagger(
                        parent.enteringChildren,
                        visualElement,
                        delayChildren,
                      );
                    }
                  }
                  return {
                    animation: animation,
                    options,
                  };
                }),
              );
            }
          }

          if (removedKeys.size) {
            const fallbackAnimation = {};

            if (typeof props.initial !== "boolean") {
              const initialTransition = resolveVariant(
                visualElement,
                Array.isArray(props.initial) ? props.initial[0] : props.initial,
              );
              if (initialTransition && initialTransition.transition) {
                fallbackAnimation.transition = initialTransition.transition;
              }
            }
            removedKeys.forEach((key) => {
              const fallbackTarget = visualElement.getBaseTarget(key);
              const motionValue = visualElement.getValue(key);
              if (motionValue) motionValue.liveStyle = true;
              // @ts-expect-error - @mattgperry to figure if we should do something here
              fallbackAnimation[key] = fallbackTarget ?? null;
            });
            animations.push({ animation: fallbackAnimation });
          }
          let shouldAnimate = Boolean(animations.length);
          if (
            isInitialRender &&
            (props.initial === false || props.initial === props.animate) &&
            !visualElement.manuallyAnimateOnMount
          ) {
            shouldAnimate = false;
          }
          isInitialRender = false;
          return shouldAnimate ? animate(animations) : Promise.resolve();
        }

        function setActive(type, isActive) {
          // If the active state hasn't changed, we can safely do nothing here
          if (state[type].isActive === isActive) return Promise.resolve();
          // Propagate active change to children
          visualElement.variantChildren?.forEach((child) =>
            child.animationState?.setActive(type, isActive),
          );
          state[type].isActive = isActive;
          const animations = animateChanges(type);
          for (const key in state) {
            state[key].protectedKeys = {};
          }
          return animations;
        }
        return {
          animateChanges,
          setActive,
          setAnimateFunction,
          getState: () => state,
          reset: () => {
            state = createState();

            // isInitialRender = true
          },
        };
      }
      function checkVariantsDidChange(prev, next) {
        if (typeof next === "string") {
          return next !== prev;
        } else if (Array.isArray(next)) {
          return !shallowCompare(next, prev);
        }
        return false;
      }
      function createTypeState(isActive = false) {
        return {
          isActive,
          protectedKeys: {},
          needsAnimating: {},
          prevResolvedValues: {},
        };
      }
      function createState() {
        return {
          animate: createTypeState(true),
          whileInView: createTypeState(),
          whileHover: createTypeState(),
          whileTap: createTypeState(),
          whileDrag: createTypeState(),
          whileFocus: createTypeState(),
          exit: createTypeState(),
        };
      }

      const SCALE_PRECISION = 0.0001;
      const SCALE_MIN = 1 - SCALE_PRECISION;
      const SCALE_MAX = 1 + SCALE_PRECISION;
      const TRANSLATE_PRECISION = 0.01;
      const TRANSLATE_MIN = 0 - TRANSLATE_PRECISION;
      const TRANSLATE_MAX = 0 + TRANSLATE_PRECISION;
      function calcLength(axis) {
        return axis.max - axis.min;
      }
      function isNear(value, target, maxDistance) {
        return Math.abs(value - target) <= maxDistance;
      }
      function calcAxisDelta(delta, source, target, origin = 0.5) {
        delta.origin = origin;
        delta.originPoint = mixNumber$1(source.min, source.max, delta.origin);
        delta.scale = calcLength(target) / calcLength(source);
        delta.translate =
          mixNumber$1(target.min, target.max, delta.origin) - delta.originPoint;
        if (
          (delta.scale >= SCALE_MIN && delta.scale <= SCALE_MAX) ||
          isNaN(delta.scale)
        ) {
          delta.scale = 1.0;
        }
        if (
          (delta.translate >= TRANSLATE_MIN &&
            delta.translate <= TRANSLATE_MAX) ||
          isNaN(delta.translate)
        ) {
          delta.translate = 0.0;
        }
      }
      function calcBoxDelta(delta, source, target, origin) {
        calcAxisDelta(
          delta.x,
          source.x,
          target.x,
          origin ? origin.originX : undefined,
        );
        calcAxisDelta(
          delta.y,
          source.y,
          target.y,
          origin ? origin.originY : undefined,
        );
      }
      function calcRelativeAxis(target, relative, parent) {
        target.min = parent.min + relative.min;
        target.max = target.min + calcLength(relative);
      }
      function calcRelativeBox(target, relative, parent) {
        calcRelativeAxis(target.x, relative.x, parent.x);
        calcRelativeAxis(target.y, relative.y, parent.y);
      }
      function calcRelativeAxisPosition(target, layout, parent) {
        target.min = layout.min - parent.min;
        target.max = target.min + calcLength(layout);
      }
      function calcRelativePosition(target, layout, parent) {
        calcRelativeAxisPosition(target.x, layout.x, parent.x);
        calcRelativeAxisPosition(target.y, layout.y, parent.y);
      }

      function removePointDelta(
        point,
        translate,
        scale,
        originPoint,
        boxScale,
      ) {
        point -= translate;
        point = scalePoint(point, 1 / scale, originPoint);
        if (boxScale !== undefined) {
          point = scalePoint(point, 1 / boxScale, originPoint);
        }
        return point;
      }

      function removeAxisDelta(
        axis,
        translate = 0,
        scale = 1,
        origin = 0.5,
        boxScale,
        originAxis = axis,
        sourceAxis = axis,
      ) {
        if (percent.test(translate)) {
          translate = parseFloat(translate);
          const relativeProgress = mixNumber$1(
            sourceAxis.min,
            sourceAxis.max,
            translate / 100,
          );
          translate = relativeProgress - sourceAxis.min;
        }
        if (typeof translate !== "number") return;
        let originPoint = mixNumber$1(originAxis.min, originAxis.max, origin);
        if (axis === originAxis) originPoint -= translate;
        axis.min = removePointDelta(
          axis.min,
          translate,
          scale,
          originPoint,
          boxScale,
        );
        axis.max = removePointDelta(
          axis.max,
          translate,
          scale,
          originPoint,
          boxScale,
        );
      }

      function removeAxisTransforms(
        axis,
        transforms,
        [key, scaleKey, originKey],
        origin,
        sourceAxis,
      ) {
        removeAxisDelta(
          axis,
          transforms[key],
          transforms[scaleKey],
          transforms[originKey],
          transforms.scale,
          origin,
          sourceAxis,
        );
      }

      const xKeys = ["x", "scaleX", "originX"];
      const yKeys = ["y", "scaleY", "originY"];

      function removeBoxTransforms(box, transforms, originBox, sourceBox) {
        removeAxisTransforms(
          box.x,
          transforms,
          xKeys,
          originBox ? originBox.x : undefined,
          sourceBox ? sourceBox.x : undefined,
        );
        removeAxisTransforms(
          box.y,
          transforms,
          yKeys,
          originBox ? originBox.y : undefined,
          sourceBox ? sourceBox.y : undefined,
        );
      }

      function copyAxisInto(axis, originAxis) {
        axis.min = originAxis.min;
        axis.max = originAxis.max;
      }

      function copyBoxInto(box, originBox) {
        copyAxisInto(box.x, originBox.x);
        copyAxisInto(box.y, originBox.y);
      }

      function copyAxisDeltaInto(delta, originDelta) {
        delta.translate = originDelta.translate;
        delta.scale = originDelta.scale;
        delta.originPoint = originDelta.originPoint;
        delta.origin = originDelta.origin;
      }

      function isAxisDeltaZero(delta) {
        return delta.translate === 0 && delta.scale === 1;
      }
      function isDeltaZero(delta) {
        return isAxisDeltaZero(delta.x) && isAxisDeltaZero(delta.y);
      }
      function axisEquals(a, b) {
        return a.min === b.min && a.max === b.max;
      }
      function boxEquals(a, b) {
        return axisEquals(a.x, b.x) && axisEquals(a.y, b.y);
      }
      function axisEqualsRounded(a, b) {
        return (
          Math.round(a.min) === Math.round(b.min) &&
          Math.round(a.max) === Math.round(b.max)
        );
      }
      function boxEqualsRounded(a, b) {
        return axisEqualsRounded(a.x, b.x) && axisEqualsRounded(a.y, b.y);
      }
      function aspectRatio(box) {
        return calcLength(box.x) / calcLength(box.y);
      }
      function axisDeltaEquals(a, b) {
        return (
          a.translate === b.translate &&
          a.scale === b.scale &&
          a.originPoint === b.originPoint
        );
      }

      function eachAxis(callback) {
        return [callback("x"), callback("y")];
      }

      function buildProjectionTransform(delta, treeScale, latestTransform) {
        let transform = "";

        const xTranslate = delta.x.translate / treeScale.x;
        const yTranslate = delta.y.translate / treeScale.y;
        const zTranslate = latestTransform?.z || 0;
        if (xTranslate || yTranslate || zTranslate) {
          transform = `translate3d(${xTranslate}px, ${yTranslate}px, ${zTranslate}px) `;
        }

        if (treeScale.x !== 1 || treeScale.y !== 1) {
          transform += `scale(${1 / treeScale.x}, ${1 / treeScale.y}) `;
        }
        if (latestTransform) {
          const {
            transformPerspective,
            rotate,
            rotateX,
            rotateY,
            skewX,
            skewY,
          } = latestTransform;
          if (transformPerspective)
            transform = `perspective(${transformPerspective}px) ${transform}`;
          if (rotate) transform += `rotate(${rotate}deg) `;
          if (rotateX) transform += `rotateX(${rotateX}deg) `;
          if (rotateY) transform += `rotateY(${rotateY}deg) `;
          if (skewX) transform += `skewX(${skewX}deg) `;
          if (skewY) transform += `skewY(${skewY}deg) `;
        }

        const elementScaleX = delta.x.scale * treeScale.x;
        const elementScaleY = delta.y.scale * treeScale.y;
        if (elementScaleX !== 1 || elementScaleY !== 1) {
          transform += `scale(${elementScaleX}, ${elementScaleY})`;
        }
        return transform || "none";
      }

      const borders = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"];
      const numBorders = borders.length;
      const asNumber = (value) =>
        typeof value === "string" ? parseFloat(value) : value;
      const isPx = (value) => typeof value === "number" || px.test(value);
      function mixValues(
        target,
        follow,
        lead,
        progress,
        shouldCrossfadeOpacity,
        isOnlyMember,
      ) {
        if (shouldCrossfadeOpacity) {
          target.opacity = mixNumber$1(
            0,
            lead.opacity ?? 1,
            easeCrossfadeIn(progress),
          );
          target.opacityExit = mixNumber$1(
            follow.opacity ?? 1,
            0,
            easeCrossfadeOut(progress),
          );
        } else if (isOnlyMember) {
          target.opacity = mixNumber$1(
            follow.opacity ?? 1,
            lead.opacity ?? 1,
            progress,
          );
        }

        for (let i = 0; i < numBorders; i++) {
          const borderLabel = `border${borders[i]}Radius`;
          let followRadius = getRadius(follow, borderLabel);
          let leadRadius = getRadius(lead, borderLabel);
          if (followRadius === undefined && leadRadius === undefined) continue;
          followRadius || (followRadius = 0);
          leadRadius || (leadRadius = 0);
          const canMix =
            followRadius === 0 ||
            leadRadius === 0 ||
            isPx(followRadius) === isPx(leadRadius);
          if (canMix) {
            target[borderLabel] = Math.max(
              mixNumber$1(
                asNumber(followRadius),
                asNumber(leadRadius),
                progress,
              ),
              0,
            );
            if (percent.test(leadRadius) || percent.test(followRadius)) {
              target[borderLabel] += "%";
            }
          } else {
            target[borderLabel] = leadRadius;
          }
        }

        if (follow.rotate || lead.rotate) {
          target.rotate = mixNumber$1(
            follow.rotate || 0,
            lead.rotate || 0,
            progress,
          );
        }
      }
      function getRadius(values, radiusName) {
        return values[radiusName] !== undefined
          ? values[radiusName]
          : values.borderRadius;
      }
      const easeCrossfadeIn = /*@__PURE__*/ compress(0, 0.5, circOut);
      const easeCrossfadeOut = /*@__PURE__*/ compress(0.5, 0.95, noop);
      function compress(min, max, easing) {
        return (p) => {
          // Could replace ifs with clamp
          if (p < min) return 0;
          if (p > max) return 1;
          return easing(progress(min, max, p));
        };
      }

      function delay(callback, timeout) {
        const start = time.now();
        const checkElapsed = ({ timestamp }) => {
          const elapsed = timestamp - start;
          if (elapsed >= timeout) {
            cancelFrame(checkElapsed);
            callback(elapsed - timeout);
          }
        };
        frame.setup(checkElapsed, true);
        return () => cancelFrame(checkElapsed);
      }

      function addDomEvent(
        target,
        eventName,
        handler,
        options = { passive: true },
      ) {
        target.addEventListener(eventName, handler, options);
        return () => target.removeEventListener(eventName, handler);
      }

      function resolveMotionValue(value) {
        return isMotionValue(value) ? value.get() : value;
      }

      function animateSingleValue(value, keyframes, options) {
        const motionValue$1 = isMotionValue(value) ? value : motionValue(value);
        motionValue$1.start(
          animateMotionValue("", motionValue$1, keyframes, options),
        );
        return motionValue$1.animation;
      }

      const compareByDepth = (a, b) => a.depth - b.depth;

      class FlatTree {
        constructor() {
          this.children = [];
          this.isDirty = false;
        }
        add(child) {
          addUniqueItem(this.children, child);
          this.isDirty = true;
        }
        remove(child) {
          removeItem(this.children, child);
          this.isDirty = true;
        }
        forEach(callback) {
          this.isDirty && this.children.sort(compareByDepth);
          this.isDirty = false;
          this.children.forEach(callback);
        }
      }

      class NodeStack {
        constructor() {
          this.members = [];
        }
        add(node) {
          addUniqueItem(this.members, node);
          node.scheduleRender();
        }
        remove(node) {
          removeItem(this.members, node);
          if (node === this.prevLead) {
            this.prevLead = undefined;
          }
          if (node === this.lead) {
            const prevLead = this.members[this.members.length - 1];
            if (prevLead) {
              this.promote(prevLead);
            }
          }
        }
        relegate(node) {
          const indexOfNode = this.members.findIndex(
            (member) => node === member,
          );
          if (indexOfNode === 0) return false;

          let prevLead;
          for (let i = indexOfNode; i >= 0; i--) {
            const member = this.members[i];
            if (member.isPresent !== false) {
              prevLead = member;
              break;
            }
          }
          if (prevLead) {
            this.promote(prevLead);
            return true;
          } else {
            return false;
          }
        }
        promote(node, preserveFollowOpacity) {
          const prevLead = this.lead;
          if (node === prevLead) return;
          this.prevLead = prevLead;
          this.lead = node;
          node.show();
          if (prevLead) {
            prevLead.instance && prevLead.scheduleRender();
            node.scheduleRender();
            node.resumeFrom = prevLead;
            if (preserveFollowOpacity) {
              node.resumeFrom.preserveOpacity = true;
            }
            if (prevLead.snapshot) {
              node.snapshot = prevLead.snapshot;
              node.snapshot.latestValues =
                prevLead.animationValues || prevLead.latestValues;
            }
            if (node.root && node.root.isUpdating) {
              node.isLayoutDirty = true;
            }
            const { crossfade } = node.options;
            if (crossfade === false) {
              prevLead.hide();
            }
          }
        }
        exitAnimationComplete() {
          this.members.forEach((node) => {
            const { options, resumingFrom } = node;
            options.onExitComplete && options.onExitComplete();
            if (resumingFrom) {
              resumingFrom.options.onExitComplete &&
                resumingFrom.options.onExitComplete();
            }
          });
        }
        scheduleRender() {
          this.members.forEach((node) => {
            node.instance && node.scheduleRender(false);
          });
        }

        removeLeadSnapshot() {
          if (this.lead && this.lead.snapshot) {
            this.lead.snapshot = undefined;
          }
        }
      }

      const globalProjectionState = {
        hasAnimatedSinceResize: true,

        hasEverUpdated: false,
      };

      const transformAxes = ["", "X", "Y", "Z"];

      const animationTarget = 1000;
      let id$1 = 0;
      function resetDistortingTransform(
        key,
        visualElement,
        values,
        sharedAnimationValues,
      ) {
        const { latestValues } = visualElement;
        // Record the distorting transform and then temporarily set it to 0
        if (latestValues[key]) {
          values[key] = latestValues[key];
          visualElement.setStaticValue(key, 0);
          if (sharedAnimationValues) {
            sharedAnimationValues[key] = 0;
          }
        }
      }
      function cancelTreeOptimisedTransformAnimations(projectionNode) {
        projectionNode.hasCheckedOptimisedAppear = true;
        if (projectionNode.root === projectionNode) return;
        const { visualElement } = projectionNode.options;
        if (!visualElement) return;
        const appearId = getOptimisedAppearId(visualElement);
        if (window.MotionHasOptimisedAnimation(appearId, "transform")) {
          const { layout, layoutId } = projectionNode.options;
          window.MotionCancelOptimisedAnimation(
            appearId,
            "transform",
            frame,
            !(layout || layoutId),
          );
        }
        const { parent } = projectionNode;
        if (parent && !parent.hasCheckedOptimisedAppear) {
          cancelTreeOptimisedTransformAnimations(parent);
        }
      }
      function createProjectionNode$1({
        attachResizeListener,
        defaultParent,
        measureScroll,
        checkIsScrollRoot,
        resetTransform,
      }) {
        return class ProjectionNode {
          constructor(latestValues = {}, parent = defaultParent?.()) {
            this.id = id$1++;

            this.animationId = 0;
            this.animationCommitId = 0;

            this.children = new Set();

            this.options = {};

            this.isTreeAnimating = false;
            this.isAnimationBlocked = false;

            this.isLayoutDirty = false;

            this.isProjectionDirty = false;

            this.isSharedProjectionDirty = false;

            this.isTransformDirty = false;

            this.updateManuallyBlocked = false;
            this.updateBlockedByResize = false;

            this.isUpdating = false;

            this.isSVG = false;

            this.needsReset = false;

            this.shouldResetTransform = false;

            this.hasCheckedOptimisedAppear = false;

            this.treeScale = { x: 1, y: 1 };

            this.eventHandlers = new Map();
            this.hasTreeAnimated = false;
            this.layoutVersion = 0;
            // Note: Currently only running on root node
            this.updateScheduled = false;
            this.scheduleUpdate = () => this.update();
            this.projectionUpdateScheduled = false;
            this.checkUpdateFailed = () => {
              if (this.isUpdating) {
                this.isUpdating = false;
                this.clearAllSnapshots();
              }
            };

            this.updateProjection = () => {
              this.projectionUpdateScheduled = false;
              this.nodes.forEach(propagateDirtyNodes);
              this.nodes.forEach(resolveTargetDelta);
              this.nodes.forEach(calcProjection);
              this.nodes.forEach(cleanDirtyNodes);
            };

            this.resolvedRelativeTargetAt = 0.0;
            this.linkedParentVersion = 0;
            this.hasProjected = false;
            this.isVisible = true;
            this.animationProgress = 0;

            // TODO Only running on root node
            this.sharedNodes = new Map();
            this.latestValues = latestValues;
            this.root = parent ? parent.root || parent : this;
            this.path = parent ? [...parent.path, parent] : [];
            this.parent = parent;
            this.depth = parent ? parent.depth + 1 : 0;
            for (let i = 0; i < this.path.length; i++) {
              this.path[i].shouldResetTransform = true;
            }
            if (this.root === this) this.nodes = new FlatTree();
          }
          addEventListener(name, handler) {
            if (!this.eventHandlers.has(name)) {
              this.eventHandlers.set(name, new SubscriptionManager());
            }
            return this.eventHandlers.get(name).add(handler);
          }
          notifyListeners(name, ...args) {
            const subscriptionManager = this.eventHandlers.get(name);
            subscriptionManager && subscriptionManager.notify(...args);
          }
          hasListeners(name) {
            return this.eventHandlers.has(name);
          }

          mount(instance) {
            if (this.instance) return;
            this.isSVG = isSVGElement(instance) && !isSVGSVGElement(instance);
            this.instance = instance;
            const { layoutId, layout, visualElement } = this.options;
            if (visualElement && !visualElement.current) {
              visualElement.mount(instance);
            }
            this.root.nodes.add(this);
            this.parent && this.parent.children.add(this);
            if (this.root.hasTreeAnimated && (layout || layoutId)) {
              this.isLayoutDirty = true;
            }
            if (attachResizeListener) {
              let cancelDelay;
              let innerWidth = 0;
              const resizeUnblockUpdate = () =>
                (this.root.updateBlockedByResize = false);
              // Set initial innerWidth in a frame.read callback to batch the read
              frame.read(() => {
                innerWidth = window.innerWidth;
              });
              attachResizeListener(instance, () => {
                const newInnerWidth = window.innerWidth;
                if (newInnerWidth === innerWidth) return;
                innerWidth = newInnerWidth;
                this.root.updateBlockedByResize = true;
                cancelDelay && cancelDelay();
                cancelDelay = delay(resizeUnblockUpdate, 250);
                if (globalProjectionState.hasAnimatedSinceResize) {
                  globalProjectionState.hasAnimatedSinceResize = false;
                  this.nodes.forEach(finishAnimation);
                }
              });
            }
            if (layoutId) {
              this.root.registerSharedNode(layoutId, this);
            }
            // Only register the handler if it requires layout animation
            if (
              this.options.animate !== false &&
              visualElement &&
              (layoutId || layout)
            ) {
              this.addEventListener(
                "didUpdate",
                ({
                  delta,
                  hasLayoutChanged,
                  hasRelativeLayoutChanged,
                  layout: newLayout,
                }) => {
                  if (this.isTreeAnimationBlocked()) {
                    this.target = undefined;
                    this.relativeTarget = undefined;
                    return;
                  }
                  // TODO: Check here if an animation exists
                  const layoutTransition =
                    this.options.transition ||
                    visualElement.getDefaultTransition() ||
                    defaultLayoutTransition;
                  const { onLayoutAnimationStart, onLayoutAnimationComplete } =
                    visualElement.getProps();

                  const hasTargetChanged =
                    !this.targetLayout ||
                    !boxEqualsRounded(this.targetLayout, newLayout);
                  /*
                   * Note: Disabled to fix relative animations always triggering new
                   * layout animations. If this causes further issues, we can try
                   * a different approach to detecting relative target changes.
                   */
                  // || hasRelativeLayoutChanged

                  const hasOnlyRelativeTargetChanged =
                    !hasLayoutChanged && hasRelativeLayoutChanged;
                  if (
                    this.options.layoutRoot ||
                    this.resumeFrom ||
                    hasOnlyRelativeTargetChanged ||
                    (hasLayoutChanged &&
                      (hasTargetChanged || !this.currentAnimation))
                  ) {
                    if (this.resumeFrom) {
                      this.resumingFrom = this.resumeFrom;
                      this.resumingFrom.resumingFrom = undefined;
                    }
                    const animationOptions = {
                      ...getValueTransition(layoutTransition, "layout"),
                      onPlay: onLayoutAnimationStart,
                      onComplete: onLayoutAnimationComplete,
                    };
                    if (
                      visualElement.shouldReduceMotion ||
                      this.options.layoutRoot
                    ) {
                      animationOptions.delay = 0;
                      animationOptions.type = false;
                    }
                    this.startAnimation(animationOptions);

                    this.setAnimationOrigin(
                      delta,
                      hasOnlyRelativeTargetChanged,
                    );
                  } else {
                    if (!hasLayoutChanged) {
                      finishAnimation(this);
                    }
                    if (this.isLead() && this.options.onExitComplete) {
                      this.options.onExitComplete();
                    }
                  }
                  this.targetLayout = newLayout;
                },
              );
            }
          }
          unmount() {
            this.options.layoutId && this.willUpdate();
            this.root.nodes.remove(this);
            const stack = this.getStack();
            stack && stack.remove(this);
            this.parent && this.parent.children.delete(this);
            this.instance = undefined;
            this.eventHandlers.clear();
            cancelFrame(this.updateProjection);
          }
          // only on the root
          blockUpdate() {
            this.updateManuallyBlocked = true;
          }
          unblockUpdate() {
            this.updateManuallyBlocked = false;
          }
          isUpdateBlocked() {
            return this.updateManuallyBlocked || this.updateBlockedByResize;
          }
          isTreeAnimationBlocked() {
            return (
              this.isAnimationBlocked ||
              (this.parent && this.parent.isTreeAnimationBlocked()) ||
              false
            );
          }
          // Note: currently only running on root node
          startUpdate() {
            if (this.isUpdateBlocked()) return;
            this.isUpdating = true;
            this.nodes && this.nodes.forEach(resetSkewAndRotation);
            this.animationId++;
          }
          getTransformTemplate() {
            const { visualElement } = this.options;
            return visualElement && visualElement.getProps().transformTemplate;
          }
          willUpdate(shouldNotifyListeners = true) {
            this.root.hasTreeAnimated = true;
            if (this.root.isUpdateBlocked()) {
              this.options.onExitComplete && this.options.onExitComplete();
              return;
            }

            if (
              window.MotionCancelOptimisedAnimation &&
              !this.hasCheckedOptimisedAppear
            ) {
              cancelTreeOptimisedTransformAnimations(this);
            }
            !this.root.isUpdating && this.root.startUpdate();
            if (this.isLayoutDirty) return;
            this.isLayoutDirty = true;
            for (let i = 0; i < this.path.length; i++) {
              const node = this.path[i];
              node.shouldResetTransform = true;
              node.updateScroll("snapshot");
              if (node.options.layoutRoot) {
                node.willUpdate(false);
              }
            }
            const { layoutId, layout } = this.options;
            if (layoutId === undefined && !layout) return;
            const transformTemplate = this.getTransformTemplate();
            this.prevTransformTemplateValue = transformTemplate
              ? transformTemplate(this.latestValues, "")
              : undefined;
            this.updateSnapshot();
            shouldNotifyListeners && this.notifyListeners("willUpdate");
          }
          update() {
            this.updateScheduled = false;
            const updateWasBlocked = this.isUpdateBlocked();
            // When doing an instant transition, we skip the layout update,
            // but should still clean up the measurements so that the next
            // snapshot could be taken correctly.
            if (updateWasBlocked) {
              this.unblockUpdate();
              this.clearAllSnapshots();
              this.nodes.forEach(clearMeasurements);
              return;
            }

            if (this.animationId <= this.animationCommitId) {
              this.nodes.forEach(clearIsLayoutDirty);
              return;
            }
            this.animationCommitId = this.animationId;
            if (!this.isUpdating) {
              this.nodes.forEach(clearIsLayoutDirty);
            } else {
              this.isUpdating = false;

              this.nodes.forEach(resetTransformStyle);

              // Update layout measurements of updated children
              this.nodes.forEach(updateLayout);

              // Notify listeners that the layout is updated
              this.nodes.forEach(notifyLayoutUpdate);
            }
            this.clearAllSnapshots();

            const now = time.now();
            frameData.delta = clamp(0, 1000 / 60, now - frameData.timestamp);
            frameData.timestamp = now;
            frameData.isProcessing = true;
            frameSteps.update.process(frameData);
            frameSteps.preRender.process(frameData);
            frameSteps.render.process(frameData);
            frameData.isProcessing = false;
          }
          didUpdate() {
            if (!this.updateScheduled) {
              this.updateScheduled = true;
              microtask.read(this.scheduleUpdate);
            }
          }
          clearAllSnapshots() {
            this.nodes.forEach(clearSnapshot);
            this.sharedNodes.forEach(removeLeadSnapshots);
          }
          scheduleUpdateProjection() {
            if (!this.projectionUpdateScheduled) {
              this.projectionUpdateScheduled = true;
              frame.preRender(this.updateProjection, false, true);
            }
          }
          scheduleCheckAfterUnmount() {
            frame.postRender(() => {
              if (this.isLayoutDirty) {
                this.root.didUpdate();
              } else {
                this.root.checkUpdateFailed();
              }
            });
          }

          updateSnapshot() {
            if (this.snapshot || !this.instance) return;
            this.snapshot = this.measure();
            if (
              this.snapshot &&
              !calcLength(this.snapshot.measuredBox.x) &&
              !calcLength(this.snapshot.measuredBox.y)
            ) {
              this.snapshot = undefined;
            }
          }
          updateLayout() {
            if (!this.instance) return;
            this.updateScroll();
            if (
              !(this.options.alwaysMeasureLayout && this.isLead()) &&
              !this.isLayoutDirty
            ) {
              return;
            }

            if (this.resumeFrom && !this.resumeFrom.instance) {
              for (let i = 0; i < this.path.length; i++) {
                const node = this.path[i];
                node.updateScroll();
              }
            }
            const prevLayout = this.layout;
            this.layout = this.measure(false);
            this.layoutVersion++;
            this.layoutCorrected = createBox();
            this.isLayoutDirty = false;
            this.projectionDelta = undefined;
            this.notifyListeners("measure", this.layout.layoutBox);
            const { visualElement } = this.options;
            visualElement &&
              visualElement.notify(
                "LayoutMeasure",
                this.layout.layoutBox,
                prevLayout ? prevLayout.layoutBox : undefined,
              );
          }
          updateScroll(phase = "measure") {
            let needsMeasurement = Boolean(
              this.options.layoutScroll && this.instance,
            );
            if (
              this.scroll &&
              this.scroll.animationId === this.root.animationId &&
              this.scroll.phase === phase
            ) {
              needsMeasurement = false;
            }
            if (needsMeasurement && this.instance) {
              const isRoot = checkIsScrollRoot(this.instance);
              this.scroll = {
                animationId: this.root.animationId,
                phase,
                isRoot,
                offset: measureScroll(this.instance),
                wasRoot: this.scroll ? this.scroll.isRoot : isRoot,
              };
            }
          }
          resetTransform() {
            if (!resetTransform) return;
            const isResetRequested =
              this.isLayoutDirty ||
              this.shouldResetTransform ||
              this.options.alwaysMeasureLayout;
            const hasProjection =
              this.projectionDelta && !isDeltaZero(this.projectionDelta);
            const transformTemplate = this.getTransformTemplate();
            const transformTemplateValue = transformTemplate
              ? transformTemplate(this.latestValues, "")
              : undefined;
            const transformTemplateHasChanged =
              transformTemplateValue !== this.prevTransformTemplateValue;
            if (
              isResetRequested &&
              this.instance &&
              (hasProjection ||
                hasTransform(this.latestValues) ||
                transformTemplateHasChanged)
            ) {
              resetTransform(this.instance, transformTemplateValue);
              this.shouldResetTransform = false;
              this.scheduleRender();
            }
          }
          measure(removeTransform = true) {
            const pageBox = this.measurePageBox();
            let layoutBox = this.removeElementScroll(pageBox);

            if (removeTransform) {
              layoutBox = this.removeTransform(layoutBox);
            }
            roundBox(layoutBox);
            return {
              animationId: this.root.animationId,
              measuredBox: pageBox,
              layoutBox,
              latestValues: {},
              source: this.id,
            };
          }
          measurePageBox() {
            const { visualElement } = this.options;
            if (!visualElement) return createBox();
            const box = visualElement.measureViewportBox();
            const wasInScrollRoot =
              this.scroll?.wasRoot || this.path.some(checkNodeWasScrollRoot);
            if (!wasInScrollRoot) {
              // Remove viewport scroll to give page-relative coordinates
              const { scroll } = this.root;
              if (scroll) {
                translateAxis(box.x, scroll.offset.x);
                translateAxis(box.y, scroll.offset.y);
              }
            }
            return box;
          }
          removeElementScroll(box) {
            const boxWithoutScroll = createBox();
            copyBoxInto(boxWithoutScroll, box);
            if (this.scroll?.wasRoot) {
              return boxWithoutScroll;
            }

            for (let i = 0; i < this.path.length; i++) {
              const node = this.path[i];
              const { scroll, options } = node;
              if (node !== this.root && scroll && options.layoutScroll) {
                if (scroll.wasRoot) {
                  copyBoxInto(boxWithoutScroll, box);
                }
                translateAxis(boxWithoutScroll.x, scroll.offset.x);
                translateAxis(boxWithoutScroll.y, scroll.offset.y);
              }
            }
            return boxWithoutScroll;
          }
          applyTransform(box, transformOnly = false) {
            const withTransforms = createBox();
            copyBoxInto(withTransforms, box);
            for (let i = 0; i < this.path.length; i++) {
              const node = this.path[i];
              if (
                !transformOnly &&
                node.options.layoutScroll &&
                node.scroll &&
                node !== node.root
              ) {
                transformBox(withTransforms, {
                  x: -node.scroll.offset.x,
                  y: -node.scroll.offset.y,
                });
              }
              if (!hasTransform(node.latestValues)) continue;
              transformBox(withTransforms, node.latestValues);
            }
            if (hasTransform(this.latestValues)) {
              transformBox(withTransforms, this.latestValues);
            }
            return withTransforms;
          }
          removeTransform(box) {
            const boxWithoutTransform = createBox();
            copyBoxInto(boxWithoutTransform, box);
            for (let i = 0; i < this.path.length; i++) {
              const node = this.path[i];
              if (!node.instance) continue;
              if (!hasTransform(node.latestValues)) continue;
              hasScale(node.latestValues) && node.updateSnapshot();
              const sourceBox = createBox();
              const nodeBox = node.measurePageBox();
              copyBoxInto(sourceBox, nodeBox);
              removeBoxTransforms(
                boxWithoutTransform,
                node.latestValues,
                node.snapshot ? node.snapshot.layoutBox : undefined,
                sourceBox,
              );
            }
            if (hasTransform(this.latestValues)) {
              removeBoxTransforms(boxWithoutTransform, this.latestValues);
            }
            return boxWithoutTransform;
          }
          setTargetDelta(delta) {
            this.targetDelta = delta;
            this.root.scheduleUpdateProjection();
            this.isProjectionDirty = true;
          }
          setOptions(options) {
            this.options = {
              ...this.options,
              ...options,
              crossfade:
                options.crossfade !== undefined ? options.crossfade : true,
            };
          }
          clearMeasurements() {
            this.scroll = undefined;
            this.layout = undefined;
            this.snapshot = undefined;
            this.prevTransformTemplateValue = undefined;
            this.targetDelta = undefined;
            this.target = undefined;
            this.isLayoutDirty = false;
          }
          forceRelativeParentToResolveTarget() {
            if (!this.relativeParent) return;

            if (
              this.relativeParent.resolvedRelativeTargetAt !==
              frameData.timestamp
            ) {
              this.relativeParent.resolveTargetDelta(true);
            }
          }
          resolveTargetDelta(forceRecalculation = false) {
            const lead = this.getLead();
            this.isProjectionDirty ||
              (this.isProjectionDirty = lead.isProjectionDirty);
            this.isTransformDirty ||
              (this.isTransformDirty = lead.isTransformDirty);
            this.isSharedProjectionDirty ||
              (this.isSharedProjectionDirty = lead.isSharedProjectionDirty);
            const isShared = Boolean(this.resumingFrom) || this !== lead;

            const canSkip = !(
              forceRecalculation ||
              (isShared && this.isSharedProjectionDirty) ||
              this.isProjectionDirty ||
              this.parent?.isProjectionDirty ||
              this.attemptToResolveRelativeTarget ||
              this.root.updateBlockedByResize
            );
            if (canSkip) return;
            const { layout, layoutId } = this.options;

            if (!this.layout || !(layout || layoutId)) return;
            this.resolvedRelativeTargetAt = frameData.timestamp;
            const relativeParent = this.getClosestProjectingParent();
            if (
              relativeParent &&
              this.linkedParentVersion !== relativeParent.layoutVersion &&
              !relativeParent.options.layoutRoot
            ) {
              this.removeRelativeTarget();
            }

            if (!this.targetDelta && !this.relativeTarget) {
              if (relativeParent && relativeParent.layout) {
                this.createRelativeTarget(
                  relativeParent,
                  this.layout.layoutBox,
                  relativeParent.layout.layoutBox,
                );
              } else {
                this.removeRelativeTarget();
              }
            }

            if (!this.relativeTarget && !this.targetDelta) return;

            if (!this.target) {
              this.target = createBox();
              this.targetWithTransforms = createBox();
            }

            if (
              this.relativeTarget &&
              this.relativeTargetOrigin &&
              this.relativeParent &&
              this.relativeParent.target
            ) {
              this.forceRelativeParentToResolveTarget();
              calcRelativeBox(
                this.target,
                this.relativeTarget,
                this.relativeParent.target,
              );
            } else if (this.targetDelta) {
              if (Boolean(this.resumingFrom)) {
                // TODO: This is creating a new object every frame
                this.target = this.applyTransform(this.layout.layoutBox);
              } else {
                copyBoxInto(this.target, this.layout.layoutBox);
              }
              applyBoxDelta(this.target, this.targetDelta);
            } else {
              copyBoxInto(this.target, this.layout.layoutBox);
            }

            if (this.attemptToResolveRelativeTarget) {
              this.attemptToResolveRelativeTarget = false;
              if (
                relativeParent &&
                Boolean(relativeParent.resumingFrom) ===
                  Boolean(this.resumingFrom) &&
                !relativeParent.options.layoutScroll &&
                relativeParent.target &&
                this.animationProgress !== 1
              ) {
                this.createRelativeTarget(
                  relativeParent,
                  this.target,
                  relativeParent.target,
                );
              } else {
                this.relativeParent = this.relativeTarget = undefined;
              }
            }
          }
          getClosestProjectingParent() {
            if (
              !this.parent ||
              hasScale(this.parent.latestValues) ||
              has2DTranslate(this.parent.latestValues)
            ) {
              return undefined;
            }
            if (this.parent.isProjecting()) {
              return this.parent;
            } else {
              return this.parent.getClosestProjectingParent();
            }
          }
          isProjecting() {
            return Boolean(
              (this.relativeTarget ||
                this.targetDelta ||
                this.options.layoutRoot) &&
              this.layout,
            );
          }
          createRelativeTarget(relativeParent, layout, parentLayout) {
            this.relativeParent = relativeParent;
            this.linkedParentVersion = relativeParent.layoutVersion;
            this.forceRelativeParentToResolveTarget();
            this.relativeTarget = createBox();
            this.relativeTargetOrigin = createBox();
            calcRelativePosition(
              this.relativeTargetOrigin,
              layout,
              parentLayout,
            );
            copyBoxInto(this.relativeTarget, this.relativeTargetOrigin);
          }
          removeRelativeTarget() {
            this.relativeParent = this.relativeTarget = undefined;
          }
          calcProjection() {
            const lead = this.getLead();
            const isShared = Boolean(this.resumingFrom) || this !== lead;
            let canSkip = true;

            if (this.isProjectionDirty || this.parent?.isProjectionDirty) {
              canSkip = false;
            }

            if (
              isShared &&
              (this.isSharedProjectionDirty || this.isTransformDirty)
            ) {
              canSkip = false;
            }

            if (this.resolvedRelativeTargetAt === frameData.timestamp) {
              canSkip = false;
            }
            if (canSkip) return;
            const { layout, layoutId } = this.options;

            this.isTreeAnimating = Boolean(
              (this.parent && this.parent.isTreeAnimating) ||
              this.currentAnimation ||
              this.pendingAnimation,
            );
            if (!this.isTreeAnimating) {
              this.targetDelta = this.relativeTarget = undefined;
            }
            if (!this.layout || !(layout || layoutId)) return;

            copyBoxInto(this.layoutCorrected, this.layout.layoutBox);

            const prevTreeScaleX = this.treeScale.x;
            const prevTreeScaleY = this.treeScale.y;

            applyTreeDeltas(
              this.layoutCorrected,
              this.treeScale,
              this.path,
              isShared,
            );

            if (
              lead.layout &&
              !lead.target &&
              (this.treeScale.x !== 1 || this.treeScale.y !== 1)
            ) {
              lead.target = lead.layout.layoutBox;
              lead.targetWithTransforms = createBox();
            }
            const { target } = lead;
            if (!target) {
              if (this.prevProjectionDelta) {
                this.createProjectionDeltas();
                this.scheduleRender();
              }
              return;
            }
            if (!this.projectionDelta || !this.prevProjectionDelta) {
              this.createProjectionDeltas();
            } else {
              copyAxisDeltaInto(
                this.prevProjectionDelta.x,
                this.projectionDelta.x,
              );
              copyAxisDeltaInto(
                this.prevProjectionDelta.y,
                this.projectionDelta.y,
              );
            }

            calcBoxDelta(
              this.projectionDelta,
              this.layoutCorrected,
              target,
              this.latestValues,
            );
            if (
              this.treeScale.x !== prevTreeScaleX ||
              this.treeScale.y !== prevTreeScaleY ||
              !axisDeltaEquals(
                this.projectionDelta.x,
                this.prevProjectionDelta.x,
              ) ||
              !axisDeltaEquals(
                this.projectionDelta.y,
                this.prevProjectionDelta.y,
              )
            ) {
              this.hasProjected = true;
              this.scheduleRender();
              this.notifyListeners("projectionUpdate", target);
            }
          }
          hide() {
            this.isVisible = false;
            // TODO: Schedule render
          }
          show() {
            this.isVisible = true;
            // TODO: Schedule render
          }
          scheduleRender(notifyAll = true) {
            this.options.visualElement?.scheduleRender();
            if (notifyAll) {
              const stack = this.getStack();
              stack && stack.scheduleRender();
            }
            if (this.resumingFrom && !this.resumingFrom.instance) {
              this.resumingFrom = undefined;
            }
          }
          createProjectionDeltas() {
            this.prevProjectionDelta = createDelta();
            this.projectionDelta = createDelta();
            this.projectionDeltaWithTransform = createDelta();
          }
          setAnimationOrigin(delta, hasOnlyRelativeTargetChanged = false) {
            const snapshot = this.snapshot;
            const snapshotLatestValues = snapshot ? snapshot.latestValues : {};
            const mixedValues = { ...this.latestValues };
            const targetDelta = createDelta();
            if (
              !this.relativeParent ||
              !this.relativeParent.options.layoutRoot
            ) {
              this.relativeTarget = this.relativeTargetOrigin = undefined;
            }
            this.attemptToResolveRelativeTarget = !hasOnlyRelativeTargetChanged;
            const relativeLayout = createBox();
            const snapshotSource = snapshot ? snapshot.source : undefined;
            const layoutSource = this.layout ? this.layout.source : undefined;
            const isSharedLayoutAnimation = snapshotSource !== layoutSource;
            const stack = this.getStack();
            const isOnlyMember = !stack || stack.members.length <= 1;
            const shouldCrossfadeOpacity = Boolean(
              isSharedLayoutAnimation &&
              !isOnlyMember &&
              this.options.crossfade === true &&
              !this.path.some(hasOpacityCrossfade),
            );
            this.animationProgress = 0;
            let prevRelativeTarget;
            this.mixTargetDelta = (latest) => {
              const progress = latest / 1000;
              mixAxisDelta(targetDelta.x, delta.x, progress);
              mixAxisDelta(targetDelta.y, delta.y, progress);
              this.setTargetDelta(targetDelta);
              if (
                this.relativeTarget &&
                this.relativeTargetOrigin &&
                this.layout &&
                this.relativeParent &&
                this.relativeParent.layout
              ) {
                calcRelativePosition(
                  relativeLayout,
                  this.layout.layoutBox,
                  this.relativeParent.layout.layoutBox,
                );
                mixBox(
                  this.relativeTarget,
                  this.relativeTargetOrigin,
                  relativeLayout,
                  progress,
                );

                if (
                  prevRelativeTarget &&
                  boxEquals(this.relativeTarget, prevRelativeTarget)
                ) {
                  this.isProjectionDirty = false;
                }
                if (!prevRelativeTarget) prevRelativeTarget = createBox();
                copyBoxInto(prevRelativeTarget, this.relativeTarget);
              }
              if (isSharedLayoutAnimation) {
                this.animationValues = mixedValues;
                mixValues(
                  mixedValues,
                  snapshotLatestValues,
                  this.latestValues,
                  progress,
                  shouldCrossfadeOpacity,
                  isOnlyMember,
                );
              }
              this.root.scheduleUpdateProjection();
              this.scheduleRender();
              this.animationProgress = progress;
            };
            this.mixTargetDelta(this.options.layoutRoot ? 1000 : 0);
          }
          startAnimation(options) {
            this.notifyListeners("animationStart");
            this.currentAnimation?.stop();
            this.resumingFrom?.currentAnimation?.stop();
            if (this.pendingAnimation) {
              cancelFrame(this.pendingAnimation);
              this.pendingAnimation = undefined;
            }

            this.pendingAnimation = frame.update(() => {
              globalProjectionState.hasAnimatedSinceResize = true;
              this.motionValue || (this.motionValue = motionValue(0));
              this.currentAnimation = animateSingleValue(
                this.motionValue,
                [0, 1000],
                {
                  ...options,
                  velocity: 0,
                  isSync: true,
                  onUpdate: (latest) => {
                    this.mixTargetDelta(latest);
                    options.onUpdate && options.onUpdate(latest);
                  },
                  onStop: () => {},
                  onComplete: () => {
                    options.onComplete && options.onComplete();
                    this.completeAnimation();
                  },
                },
              );
              if (this.resumingFrom) {
                this.resumingFrom.currentAnimation = this.currentAnimation;
              }
              this.pendingAnimation = undefined;
            });
          }
          completeAnimation() {
            if (this.resumingFrom) {
              this.resumingFrom.currentAnimation = undefined;
              this.resumingFrom.preserveOpacity = undefined;
            }
            const stack = this.getStack();
            stack && stack.exitAnimationComplete();
            this.resumingFrom =
              this.currentAnimation =
              this.animationValues =
                undefined;
            this.notifyListeners("animationComplete");
          }
          finishAnimation() {
            if (this.currentAnimation) {
              this.mixTargetDelta && this.mixTargetDelta(animationTarget);
              this.currentAnimation.stop();
            }
            this.completeAnimation();
          }
          applyTransformsToTarget() {
            const lead = this.getLead();
            let { targetWithTransforms, target, layout, latestValues } = lead;
            if (!targetWithTransforms || !target || !layout) return;

            if (
              this !== lead &&
              this.layout &&
              layout &&
              shouldAnimatePositionOnly(
                this.options.animationType,
                this.layout.layoutBox,
                layout.layoutBox,
              )
            ) {
              target = this.target || createBox();
              const xLength = calcLength(this.layout.layoutBox.x);
              target.x.min = lead.target.x.min;
              target.x.max = target.x.min + xLength;
              const yLength = calcLength(this.layout.layoutBox.y);
              target.y.min = lead.target.y.min;
              target.y.max = target.y.min + yLength;
            }
            copyBoxInto(targetWithTransforms, target);

            transformBox(targetWithTransforms, latestValues);

            calcBoxDelta(
              this.projectionDeltaWithTransform,
              this.layoutCorrected,
              targetWithTransforms,
              latestValues,
            );
          }
          registerSharedNode(layoutId, node) {
            if (!this.sharedNodes.has(layoutId)) {
              this.sharedNodes.set(layoutId, new NodeStack());
            }
            const stack = this.sharedNodes.get(layoutId);
            stack.add(node);
            const config = node.options.initialPromotionConfig;
            node.promote({
              transition: config ? config.transition : undefined,
              preserveFollowOpacity:
                config && config.shouldPreserveFollowOpacity
                  ? config.shouldPreserveFollowOpacity(node)
                  : undefined,
            });
          }
          isLead() {
            const stack = this.getStack();
            return stack ? stack.lead === this : true;
          }
          getLead() {
            const { layoutId } = this.options;
            return layoutId ? this.getStack()?.lead || this : this;
          }
          getPrevLead() {
            const { layoutId } = this.options;
            return layoutId ? this.getStack()?.prevLead : undefined;
          }
          getStack() {
            const { layoutId } = this.options;
            if (layoutId) return this.root.sharedNodes.get(layoutId);
          }
          promote({ needsReset, transition, preserveFollowOpacity } = {}) {
            const stack = this.getStack();
            if (stack) stack.promote(this, preserveFollowOpacity);
            if (needsReset) {
              this.projectionDelta = undefined;
              this.needsReset = true;
            }
            if (transition) this.setOptions({ transition });
          }
          relegate() {
            const stack = this.getStack();
            if (stack) {
              return stack.relegate(this);
            } else {
              return false;
            }
          }
          resetSkewAndRotation() {
            const { visualElement } = this.options;
            if (!visualElement) return;
            // If there's no detected skew or rotation values, we can early return without a forced render.
            let hasDistortingTransform = false;

            const { latestValues } = visualElement;
            if (
              latestValues.z ||
              latestValues.rotate ||
              latestValues.rotateX ||
              latestValues.rotateY ||
              latestValues.rotateZ ||
              latestValues.skewX ||
              latestValues.skewY
            ) {
              hasDistortingTransform = true;
            }
            // If there's no distorting values, we don't need to do any more.
            if (!hasDistortingTransform) return;
            const resetValues = {};
            if (latestValues.z) {
              resetDistortingTransform(
                "z",
                visualElement,
                resetValues,
                this.animationValues,
              );
            }
            // Check the skew and rotate value of all axes and reset to 0
            for (let i = 0; i < transformAxes.length; i++) {
              resetDistortingTransform(
                `rotate${transformAxes[i]}`,
                visualElement,
                resetValues,
                this.animationValues,
              );
              resetDistortingTransform(
                `skew${transformAxes[i]}`,
                visualElement,
                resetValues,
                this.animationValues,
              );
            }
            // Force a render of this element to apply the transform with all skews and rotations
            // set to 0.
            visualElement.render();
            // Put back all the values we reset
            for (const key in resetValues) {
              visualElement.setStaticValue(key, resetValues[key]);
              if (this.animationValues) {
                this.animationValues[key] = resetValues[key];
              }
            }
            // Schedule a render for the next frame. This ensures we won't visually
            // see the element with the reset rotate value applied.
            visualElement.scheduleRender();
          }
          applyProjectionStyles(
            targetStyle, // CSSStyleDeclaration - doesn't allow numbers to be assigned to properties
            styleProp,
          ) {
            if (!this.instance || this.isSVG) return;
            if (!this.isVisible) {
              targetStyle.visibility = "hidden";
              return;
            }
            const transformTemplate = this.getTransformTemplate();
            if (this.needsReset) {
              this.needsReset = false;
              targetStyle.visibility = "";
              targetStyle.opacity = "";
              targetStyle.pointerEvents =
                resolveMotionValue(styleProp?.pointerEvents) || "";
              targetStyle.transform = transformTemplate
                ? transformTemplate(this.latestValues, "")
                : "none";
              return;
            }
            const lead = this.getLead();
            if (!this.projectionDelta || !this.layout || !lead.target) {
              if (this.options.layoutId) {
                targetStyle.opacity =
                  this.latestValues.opacity !== undefined
                    ? this.latestValues.opacity
                    : 1;
                targetStyle.pointerEvents =
                  resolveMotionValue(styleProp?.pointerEvents) || "";
              }
              if (this.hasProjected && !hasTransform(this.latestValues)) {
                targetStyle.transform = transformTemplate
                  ? transformTemplate({}, "")
                  : "none";
                this.hasProjected = false;
              }
              return;
            }
            targetStyle.visibility = "";
            const valuesToRender = lead.animationValues || lead.latestValues;
            this.applyTransformsToTarget();
            let transform = buildProjectionTransform(
              this.projectionDeltaWithTransform,
              this.treeScale,
              valuesToRender,
            );
            if (transformTemplate) {
              transform = transformTemplate(valuesToRender, transform);
            }
            targetStyle.transform = transform;
            const { x, y } = this.projectionDelta;
            targetStyle.transformOrigin = `${x.origin * 100}% ${y.origin * 100}% 0`;
            if (lead.animationValues) {
              targetStyle.opacity =
                lead === this
                  ? (valuesToRender.opacity ?? this.latestValues.opacity ?? 1)
                  : this.preserveOpacity
                    ? this.latestValues.opacity
                    : valuesToRender.opacityExit;
            } else {
              targetStyle.opacity =
                lead === this
                  ? valuesToRender.opacity !== undefined
                    ? valuesToRender.opacity
                    : ""
                  : valuesToRender.opacityExit !== undefined
                    ? valuesToRender.opacityExit
                    : 0;
            }

            for (const key in scaleCorrectors) {
              if (valuesToRender[key] === undefined) continue;
              const { correct, applyTo, isCSSVariable } = scaleCorrectors[key];

              const corrected =
                transform === "none"
                  ? valuesToRender[key]
                  : correct(valuesToRender[key], lead);
              if (applyTo) {
                const num = applyTo.length;
                for (let i = 0; i < num; i++) {
                  targetStyle[applyTo[i]] = corrected;
                }
              } else {
                // If this is a CSS variable, set it directly on the instance.
                // Replacing this function from creating styles to setting them
                // would be a good place to remove per frame object creation
                if (isCSSVariable) {
                  this.options.visualElement.renderState.vars[key] = corrected;
                } else {
                  targetStyle[key] = corrected;
                }
              }
            }

            if (this.options.layoutId) {
              targetStyle.pointerEvents =
                lead === this
                  ? resolveMotionValue(styleProp?.pointerEvents) || ""
                  : "none";
            }
          }
          clearSnapshot() {
            this.resumeFrom = this.snapshot = undefined;
          }
          // Only run on root
          resetTree() {
            this.root.nodes.forEach((node) => node.currentAnimation?.stop());
            this.root.nodes.forEach(clearMeasurements);
            this.root.sharedNodes.clear();
          }
        };
      }
      function updateLayout(node) {
        node.updateLayout();
      }
      function notifyLayoutUpdate(node) {
        const snapshot = node.resumeFrom?.snapshot || node.snapshot;
        if (
          node.isLead() &&
          node.layout &&
          snapshot &&
          node.hasListeners("didUpdate")
        ) {
          const { layoutBox: layout, measuredBox: measuredLayout } =
            node.layout;
          const { animationType } = node.options;
          const isShared = snapshot.source !== node.layout.source;
          // TODO Maybe we want to also resize the layout snapshot so we don't trigger
          // animations for instance if layout="size" and an element has only changed position
          if (animationType === "size") {
            eachAxis((axis) => {
              const axisSnapshot = isShared
                ? snapshot.measuredBox[axis]
                : snapshot.layoutBox[axis];
              const length = calcLength(axisSnapshot);
              axisSnapshot.min = layout[axis].min;
              axisSnapshot.max = axisSnapshot.min + length;
            });
          } else if (
            shouldAnimatePositionOnly(animationType, snapshot.layoutBox, layout)
          ) {
            eachAxis((axis) => {
              const axisSnapshot = isShared
                ? snapshot.measuredBox[axis]
                : snapshot.layoutBox[axis];
              const length = calcLength(layout[axis]);
              axisSnapshot.max = axisSnapshot.min + length;

              if (node.relativeTarget && !node.currentAnimation) {
                node.isProjectionDirty = true;
                node.relativeTarget[axis].max =
                  node.relativeTarget[axis].min + length;
              }
            });
          }
          const layoutDelta = createDelta();
          calcBoxDelta(layoutDelta, layout, snapshot.layoutBox);
          const visualDelta = createDelta();
          if (isShared) {
            calcBoxDelta(
              visualDelta,
              node.applyTransform(measuredLayout, true),
              snapshot.measuredBox,
            );
          } else {
            calcBoxDelta(visualDelta, layout, snapshot.layoutBox);
          }
          const hasLayoutChanged = !isDeltaZero(layoutDelta);
          let hasRelativeLayoutChanged = false;
          if (!node.resumeFrom) {
            const relativeParent = node.getClosestProjectingParent();

            if (relativeParent && !relativeParent.resumeFrom) {
              const { snapshot: parentSnapshot, layout: parentLayout } =
                relativeParent;
              if (parentSnapshot && parentLayout) {
                const relativeSnapshot = createBox();
                calcRelativePosition(
                  relativeSnapshot,
                  snapshot.layoutBox,
                  parentSnapshot.layoutBox,
                );
                const relativeLayout = createBox();
                calcRelativePosition(
                  relativeLayout,
                  layout,
                  parentLayout.layoutBox,
                );
                if (!boxEqualsRounded(relativeSnapshot, relativeLayout)) {
                  hasRelativeLayoutChanged = true;
                }
                if (relativeParent.options.layoutRoot) {
                  node.relativeTarget = relativeLayout;
                  node.relativeTargetOrigin = relativeSnapshot;
                  node.relativeParent = relativeParent;
                }
              }
            }
          }
          node.notifyListeners("didUpdate", {
            layout,
            snapshot,
            delta: visualDelta,
            layoutDelta,
            hasLayoutChanged,
            hasRelativeLayoutChanged,
          });
        } else if (node.isLead()) {
          const { onExitComplete } = node.options;
          onExitComplete && onExitComplete();
        }

        node.options.transition = undefined;
      }
      function propagateDirtyNodes(node) {
        if (!node.parent) return;

        if (!node.isProjecting()) {
          node.isProjectionDirty = node.parent.isProjectionDirty;
        }

        node.isSharedProjectionDirty ||
          (node.isSharedProjectionDirty = Boolean(
            node.isProjectionDirty ||
            node.parent.isProjectionDirty ||
            node.parent.isSharedProjectionDirty,
          ));
        node.isTransformDirty ||
          (node.isTransformDirty = node.parent.isTransformDirty);
      }
      function cleanDirtyNodes(node) {
        node.isProjectionDirty =
          node.isSharedProjectionDirty =
          node.isTransformDirty =
            false;
      }
      function clearSnapshot(node) {
        node.clearSnapshot();
      }
      function clearMeasurements(node) {
        node.clearMeasurements();
      }
      function clearIsLayoutDirty(node) {
        node.isLayoutDirty = false;
      }
      function resetTransformStyle(node) {
        const { visualElement } = node.options;
        if (visualElement && visualElement.getProps().onBeforeLayoutMeasure) {
          visualElement.notify("BeforeLayoutMeasure");
        }
        node.resetTransform();
      }
      function finishAnimation(node) {
        node.finishAnimation();
        node.targetDelta = node.relativeTarget = node.target = undefined;
        node.isProjectionDirty = true;
      }
      function resolveTargetDelta(node) {
        node.resolveTargetDelta();
      }
      function calcProjection(node) {
        node.calcProjection();
      }
      function resetSkewAndRotation(node) {
        node.resetSkewAndRotation();
      }
      function removeLeadSnapshots(stack) {
        stack.removeLeadSnapshot();
      }
      function mixAxisDelta(output, delta, p) {
        output.translate = mixNumber$1(delta.translate, 0, p);
        output.scale = mixNumber$1(delta.scale, 1, p);
        output.origin = delta.origin;
        output.originPoint = delta.originPoint;
      }
      function mixAxis(output, from, to, p) {
        output.min = mixNumber$1(from.min, to.min, p);
        output.max = mixNumber$1(from.max, to.max, p);
      }
      function mixBox(output, from, to, p) {
        mixAxis(output.x, from.x, to.x, p);
        mixAxis(output.y, from.y, to.y, p);
      }
      function hasOpacityCrossfade(node) {
        return (
          node.animationValues && node.animationValues.opacityExit !== undefined
        );
      }
      const defaultLayoutTransition = {
        duration: 0.45,
        ease: [0.4, 0, 0.1, 1],
      };
      const userAgentContains = (string) =>
        typeof navigator !== "undefined" &&
        navigator.userAgent &&
        navigator.userAgent.toLowerCase().includes(string);

      const roundPoint =
        userAgentContains("applewebkit/") && !userAgentContains("chrome/")
          ? Math.round
          : noop;
      function roundAxis(axis) {
        // Round to the nearest .5 pixels to support subpixel layouts
        axis.min = roundPoint(axis.min);
        axis.max = roundPoint(axis.max);
      }
      function roundBox(box) {
        roundAxis(box.x);
        roundAxis(box.y);
      }
      function shouldAnimatePositionOnly(animationType, snapshot, layout) {
        return (
          animationType === "position" ||
          (animationType === "preserve-aspect" &&
            !isNear(aspectRatio(snapshot), aspectRatio(layout), 0.2))
        );
      }
      function checkNodeWasScrollRoot(node) {
        return node !== node.root && node.scroll?.wasRoot;
      }

      const DocumentProjectionNode = createProjectionNode$1({
        attachResizeListener: (ref, notify) =>
          addDomEvent(ref, "resize", notify),
        measureScroll: () => ({
          x: document.documentElement.scrollLeft || document.body.scrollLeft,
          y: document.documentElement.scrollTop || document.body.scrollTop,
        }),
        checkIsScrollRoot: () => true,
      });

      const rootProjectionNode = {
        current: undefined,
      };
      const HTMLProjectionNode = createProjectionNode$1({
        measureScroll: (instance) => ({
          x: instance.scrollLeft,
          y: instance.scrollTop,
        }),
        defaultParent: () => {
          if (!rootProjectionNode.current) {
            const documentNode = new DocumentProjectionNode({});
            documentNode.mount(window);
            documentNode.setOptions({ layoutScroll: true });
            rootProjectionNode.current = documentNode;
          }
          return rootProjectionNode.current;
        },
        resetTransform: (instance, value) => {
          instance.style.transform = value !== undefined ? value : "none";
        },
        checkIsScrollRoot: (instance) =>
          Boolean(window.getComputedStyle(instance).position === "fixed"),
      });

      const MotionConfigContext = reactExports.createContext({
        transformPagePoint: (p) => p,
        isStatic: false,
        reducedMotion: "never",
      });

      function setRef(ref, value) {
        if (typeof ref === "function") {
          return ref(value);
        } else if (ref !== null && ref !== undefined) {
          ref.current = value;
        }
      }

      function composeRefs(...refs) {
        return (node) => {
          let hasCleanup = false;
          const cleanups = refs.map((ref) => {
            const cleanup = setRef(ref, node);
            if (!hasCleanup && typeof cleanup === "function") {
              hasCleanup = true;
            }
            return cleanup;
          });
          // React <19 will log an error to the console if a callback ref returns a
          // value. We don't use ref cleanups internally so this will only happen if a
          // user's ref callback returns a value, which we only expect if they are
          // using the cleanup functionality added in React 19.
          if (hasCleanup) {
            return () => {
              for (let i = 0; i < cleanups.length; i++) {
                const cleanup = cleanups[i];
                if (typeof cleanup === "function") {
                  cleanup();
                } else {
                  setRef(refs[i], null);
                }
              }
            };
          }
        };
      }

      function useComposedRefs(...refs) {
        // eslint-disable-next-line react-hooks/exhaustive-deps
        return reactExports.useCallback(composeRefs(...refs), refs);
      }

      class PopChildMeasure extends reactExports.Component {
        getSnapshotBeforeUpdate(prevProps) {
          const element = this.props.childRef.current;
          if (element && prevProps.isPresent && !this.props.isPresent) {
            const parent = element.offsetParent;
            const parentWidth = isHTMLElement(parent)
              ? parent.offsetWidth || 0
              : 0;
            const size = this.props.sizeRef.current;
            size.height = element.offsetHeight || 0;
            size.width = element.offsetWidth || 0;
            size.top = element.offsetTop;
            size.left = element.offsetLeft;
            size.right = parentWidth - size.width - size.left;
          }
          return null;
        }

        componentDidUpdate() {}
        render() {
          return this.props.children;
        }
      }
      function PopChild({ children, isPresent, anchorX, root }) {
        const id = reactExports.useId();
        const ref = reactExports.useRef(null);
        const size = reactExports.useRef({
          width: 0,
          height: 0,
          top: 0,
          left: 0,
          right: 0,
        });
        const { nonce } = reactExports.useContext(MotionConfigContext);

        const childRef = children.props?.ref ?? children?.ref;
        const composedRef = useComposedRefs(ref, childRef);

        reactExports.useInsertionEffect(() => {
          const { width, height, top, left, right } = size.current;
          if (isPresent || !ref.current || !width || !height) return;
          const x = anchorX === "left" ? `left: ${left}` : `right: ${right}`;
          ref.current.dataset.motionPopId = id;
          const style = document.createElement("style");
          if (nonce) style.nonce = nonce;
          const parent = root ?? document.head;
          parent.appendChild(style);
          if (style.sheet) {
            style.sheet.insertRule(`
          [data-motion-pop-id="${id}"] {
            position: absolute !important;
            width: ${width}px !important;
            height: ${height}px !important;
            ${x}px !important;
            top: ${top}px !important;
          }
        `);
          }
          return () => {
            if (parent.contains(style)) {
              parent.removeChild(style);
            }
          };
        }, [isPresent]);
        return jsxRuntimeExports.jsx(PopChildMeasure, {
          isPresent: isPresent,
          childRef: ref,
          sizeRef: size,
          children: reactExports.cloneElement(children, { ref: composedRef }),
        });
      }

      const PresenceChild = ({
        children,
        initial,
        isPresent,
        onExitComplete,
        custom,
        presenceAffectsLayout,
        mode,
        anchorX,
        root,
      }) => {
        const presenceChildren = useConstant(newChildrenMap);
        const id = reactExports.useId();
        let isReusedContext = true;
        let context = reactExports.useMemo(() => {
          isReusedContext = false;
          return {
            id,
            initial,
            isPresent,
            custom,
            onExitComplete: (childId) => {
              presenceChildren.set(childId, true);
              for (const isComplete of presenceChildren.values()) {
                if (!isComplete) return; // can stop searching when any is incomplete
              }
              onExitComplete && onExitComplete();
            },
            register: (childId) => {
              presenceChildren.set(childId, false);
              return () => presenceChildren.delete(childId);
            },
          };
        }, [isPresent, presenceChildren, onExitComplete]);

        if (presenceAffectsLayout && isReusedContext) {
          context = { ...context };
        }
        reactExports.useMemo(() => {
          presenceChildren.forEach((_, key) =>
            presenceChildren.set(key, false),
          );
        }, [isPresent]);

        reactExports.useEffect(() => {
          !isPresent &&
            !presenceChildren.size &&
            onExitComplete &&
            onExitComplete();
        }, [isPresent]);
        if (mode === "popLayout") {
          children = jsxRuntimeExports.jsx(PopChild, {
            isPresent: isPresent,
            anchorX: anchorX,
            root: root,
            children: children,
          });
        }
        return jsxRuntimeExports.jsx(PresenceContext.Provider, {
          value: context,
          children: children,
        });
      };
      function newChildrenMap() {
        return new Map();
      }

      function usePresence(subscribe = true) {
        const context = reactExports.useContext(PresenceContext);
        if (context === null) return [true, null];
        const { isPresent, onExitComplete, register } = context;
        // It's safe to call the following hooks conditionally (after an early return) because the context will always
        // either be null or non-null for the lifespan of the component.
        const id = reactExports.useId();
        reactExports.useEffect(() => {
          if (subscribe) {
            return register(id);
          }
        }, [subscribe]);
        const safeToRemove = reactExports.useCallback(
          () => subscribe && onExitComplete && onExitComplete(id),
          [id, onExitComplete, subscribe],
        );
        return !isPresent && onExitComplete ? [false, safeToRemove] : [true];
      }

      const getChildKey = (child) => child.key || "";
      function onlyElements(children) {
        const filtered = [];
        // We use forEach here instead of map as map mutates the component key by preprending `.$`
        reactExports.Children.forEach(children, (child) => {
          if (reactExports.isValidElement(child)) filtered.push(child);
        });
        return filtered;
      }

      const AnimatePresence = ({
        children,
        custom,
        initial = true,
        onExitComplete,
        presenceAffectsLayout = true,
        mode = "sync",
        propagate = false,
        anchorX = "left",
        root,
      }) => {
        const [isParentPresent, safeToRemove] = usePresence(propagate);
        const presentChildren = reactExports.useMemo(
          () => onlyElements(children),
          [children],
        );
        const presentKeys =
          propagate && !isParentPresent ? [] : presentChildren.map(getChildKey);
        const isInitialRender = reactExports.useRef(true);
        const pendingPresentChildren = reactExports.useRef(presentChildren);
        const exitComplete = useConstant(() => /* @__PURE__ */ new Map());
        const exitingComponents = reactExports.useRef(
          /* @__PURE__ */ new Set(),
        );
        const [diffedChildren, setDiffedChildren] =
          reactExports.useState(presentChildren);
        const [renderedChildren, setRenderedChildren] =
          reactExports.useState(presentChildren);
        useIsomorphicLayoutEffect(() => {
          isInitialRender.current = false;
          pendingPresentChildren.current = presentChildren;
          for (let i = 0; i < renderedChildren.length; i++) {
            const key = getChildKey(renderedChildren[i]);
            if (!presentKeys.includes(key)) {
              if (exitComplete.get(key) !== true) {
                exitComplete.set(key, false);
              }
            } else {
              exitComplete.delete(key);
              exitingComponents.current.delete(key);
            }
          }
        }, [renderedChildren, presentKeys.length, presentKeys.join("-")]);
        const exitingChildren = [];
        if (presentChildren !== diffedChildren) {
          let nextChildren = [...presentChildren];
          for (let i = 0; i < renderedChildren.length; i++) {
            const child = renderedChildren[i];
            const key = getChildKey(child);
            if (!presentKeys.includes(key)) {
              nextChildren.splice(i, 0, child);
              exitingChildren.push(child);
            }
          }
          if (mode === "wait" && exitingChildren.length) {
            nextChildren = exitingChildren;
          }
          setRenderedChildren(onlyElements(nextChildren));
          setDiffedChildren(presentChildren);
          return null;
        }
        const { forceRender } = reactExports.useContext(LayoutGroupContext);
        return jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {
          children: renderedChildren.map((child) => {
            const key = getChildKey(child);
            const isPresent =
              propagate && !isParentPresent
                ? false
                : presentChildren === renderedChildren ||
                  presentKeys.includes(key);
            const onExit = () => {
              if (exitingComponents.current.has(key)) {
                return;
              }
              exitingComponents.current.add(key);
              if (exitComplete.has(key)) {
                exitComplete.set(key, true);
              } else {
                return;
              }
              let isEveryExitComplete = true;
              exitComplete.forEach((isExitComplete) => {
                if (!isExitComplete) isEveryExitComplete = false;
              });
              if (isEveryExitComplete) {
                forceRender?.();
                setRenderedChildren(pendingPresentChildren.current);
                propagate && safeToRemove?.();
                onExitComplete && onExitComplete();
              }
            };
            return jsxRuntimeExports.jsx(
              PresenceChild,
              {
                isPresent,
                initial: !isInitialRender.current || initial ? void 0 : false,
                custom,
                presenceAffectsLayout,
                mode,
                root,
                onExitComplete: isPresent ? void 0 : onExit,
                anchorX,
                children: child,
              },
              key,
            );
          }),
        });
      };

      const LazyContext = reactExports.createContext({ strict: false });

      const featureProps = {
        animation: [
          "animate",
          "variants",
          "whileHover",
          "whileTap",
          "exit",
          "whileInView",
          "whileFocus",
          "whileDrag",
        ],
        exit: ["exit"],
        drag: ["drag", "dragControls"],
        focus: ["whileFocus"],
        hover: ["whileHover", "onHoverStart", "onHoverEnd"],
        tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"],
        pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"],
        inView: ["whileInView", "onViewportEnter", "onViewportLeave"],
        layout: ["layout", "layoutId"],
      };
      let isInitialized = false;

      function initFeatureDefinitions() {
        if (isInitialized) return;
        const initialFeatureDefinitions = {};
        for (const key in featureProps) {
          initialFeatureDefinitions[key] = {
            isEnabled: (props) =>
              featureProps[key].some((name) => !!props[name]),
          };
        }
        setFeatureDefinitions(initialFeatureDefinitions);
        isInitialized = true;
      }

      function getInitializedFeatureDefinitions() {
        initFeatureDefinitions();
        return getFeatureDefinitions();
      }

      function loadFeatures(features) {
        const featureDefinitions = getInitializedFeatureDefinitions();
        for (const key in features) {
          featureDefinitions[key] = {
            ...featureDefinitions[key],
            ...features[key],
          };
        }
        setFeatureDefinitions(featureDefinitions);
      }

      const validMotionProps = new Set([
        "animate",
        "exit",
        "variants",
        "initial",
        "style",
        "values",
        "variants",
        "transition",
        "transformTemplate",
        "custom",
        "inherit",
        "onBeforeLayoutMeasure",
        "onAnimationStart",
        "onAnimationComplete",
        "onUpdate",
        "onDragStart",
        "onDrag",
        "onDragEnd",
        "onMeasureDragConstraints",
        "onDirectionLock",
        "onDragTransitionEnd",
        "_dragX",
        "_dragY",
        "onHoverStart",
        "onHoverEnd",
        "onViewportEnter",
        "onViewportLeave",
        "globalTapTarget",
        "ignoreStrict",
        "viewport",
      ]);

      function isValidMotionProp(key) {
        return (
          key.startsWith("while") ||
          (key.startsWith("drag") && key !== "draggable") ||
          key.startsWith("layout") ||
          key.startsWith("onTap") ||
          key.startsWith("onPan") ||
          key.startsWith("onLayout") ||
          validMotionProps.has(key)
        );
      }

      let shouldForward = (key) => !isValidMotionProp(key);
      function loadExternalIsValidProp(isValidProp) {
        if (typeof isValidProp !== "function") return;
        // Explicitly filter our events
        shouldForward = (key) =>
          key.startsWith("on") ? !isValidMotionProp(key) : isValidProp(key);
      }

      try {
        loadExternalIsValidProp(require("@emotion/is-prop-valid").default);
      } catch {
        // We don't need to actually do anything here - the fallback is the existing `isPropValid`.
      }
      function filterProps(props, isDom, forwardMotionProps) {
        const filteredProps = {};
        for (const key in props) {
          if (key === "values" && typeof props.values === "object") continue;
          if (
            shouldForward(key) ||
            (forwardMotionProps === true && isValidMotionProp(key)) ||
            (!isDom && !isValidMotionProp(key)) ||
            // If trying to use native HTML drag events, forward drag listeners
            (props["draggable"] && key.startsWith("onDrag"))
          ) {
            filteredProps[key] = props[key];
          }
        }
        return filteredProps;
      }

      const MotionContext = /* @__PURE__ */ reactExports.createContext({});

      function getCurrentTreeVariants(props, context) {
        if (isControllingVariants(props)) {
          const { initial, animate } = props;
          return {
            initial:
              initial === false || isVariantLabel(initial)
                ? initial
                : undefined,
            animate: isVariantLabel(animate) ? animate : undefined,
          };
        }
        return props.inherit !== false ? context : {};
      }

      function useCreateMotionContext(props) {
        const { initial, animate } = getCurrentTreeVariants(
          props,
          reactExports.useContext(MotionContext),
        );
        return reactExports.useMemo(
          () => ({ initial, animate }),
          [
            variantLabelsAsDependency(initial),
            variantLabelsAsDependency(animate),
          ],
        );
      }
      function variantLabelsAsDependency(prop) {
        return Array.isArray(prop) ? prop.join(" ") : prop;
      }

      const createHtmlRenderState = () => ({
        style: {},
        transform: {},
        transformOrigin: {},
        vars: {},
      });

      function copyRawValuesOnly(target, source, props) {
        for (const key in source) {
          if (!isMotionValue(source[key]) && !isForcedMotionValue(key, props)) {
            target[key] = source[key];
          }
        }
      }
      function useInitialMotionValues({ transformTemplate }, visualState) {
        return reactExports.useMemo(() => {
          const state = createHtmlRenderState();
          buildHTMLStyles(state, visualState, transformTemplate);
          return Object.assign({}, state.vars, state.style);
        }, [visualState]);
      }
      function useStyle(props, visualState) {
        const styleProp = props.style || {};
        const style = {};

        copyRawValuesOnly(style, styleProp, props);
        Object.assign(style, useInitialMotionValues(props, visualState));
        return style;
      }
      function useHTMLProps(props, visualState) {
        // The `any` isn't ideal but it is the type of createElement props argument
        const htmlProps = {};
        const style = useStyle(props, visualState);
        if (props.drag && props.dragListener !== false) {
          // Disable the ghost element when a user drags
          htmlProps.draggable = false;
          // Disable text selection
          style.userSelect =
            style.WebkitUserSelect =
            style.WebkitTouchCallout =
              "none";
          // Disable scrolling on the draggable direction
          style.touchAction =
            props.drag === true
              ? "none"
              : `pan-${props.drag === "x" ? "y" : "x"}`;
        }
        if (
          props.tabIndex === undefined &&
          (props.onTap || props.onTapStart || props.whileTap)
        ) {
          htmlProps.tabIndex = 0;
        }
        htmlProps.style = style;
        return htmlProps;
      }

      const createSvgRenderState = () => ({
        ...createHtmlRenderState(),
        attrs: {},
      });

      function useSVGProps(props, visualState, _isStatic, Component) {
        const visualProps = reactExports.useMemo(() => {
          const state = createSvgRenderState();
          buildSVGAttrs(
            state,
            visualState,
            isSVGTag(Component),
            props.transformTemplate,
            props.style,
          );
          return {
            ...state.attrs,
            style: { ...state.style },
          };
        }, [visualState]);
        if (props.style) {
          const rawStyles = {};
          copyRawValuesOnly(rawStyles, props.style, props);
          visualProps.style = { ...rawStyles, ...visualProps.style };
        }
        return visualProps;
      }

      const lowercaseSVGElements = [
        "animate",
        "circle",
        "defs",
        "desc",
        "ellipse",
        "g",
        "image",
        "line",
        "filter",
        "marker",
        "mask",
        "metadata",
        "path",
        "pattern",
        "polygon",
        "polyline",
        "rect",
        "stop",
        "switch",
        "symbol",
        "svg",
        "text",
        "tspan",
        "use",
        "view",
      ];

      function isSVGComponent(Component) {
        if (typeof Component !== "string" || Component.includes("-")) {
          return false;
        } else if (
          lowercaseSVGElements.indexOf(Component) > -1 ||
          /[A-Z]/u.test(Component)
        ) {
          return true;
        }
        return false;
      }

      function useRender(
        Component,
        props,
        ref,
        { latestValues },
        isStatic,
        forwardMotionProps = false,
        isSVG,
      ) {
        const useVisualProps =
          (isSVG ?? isSVGComponent(Component)) ? useSVGProps : useHTMLProps;
        const visualProps = useVisualProps(
          props,
          latestValues,
          isStatic,
          Component,
        );
        const filteredProps = filterProps(
          props,
          typeof Component === "string",
          forwardMotionProps,
        );
        const elementProps =
          Component !== reactExports.Fragment
            ? { ...filteredProps, ...visualProps, ref }
            : {};

        const { children } = props;
        const renderedChildren = reactExports.useMemo(
          () => (isMotionValue(children) ? children.get() : children),
          [children],
        );
        return reactExports.createElement(Component, {
          ...elementProps,
          children: renderedChildren,
        });
      }

      function makeState(
        { scrapeMotionValuesFromProps, createRenderState },
        props,
        context,
        presenceContext,
      ) {
        const state = {
          latestValues: makeLatestValues(
            props,
            context,
            presenceContext,
            scrapeMotionValuesFromProps,
          ),
          renderState: createRenderState(),
        };
        return state;
      }
      function makeLatestValues(
        props,
        context,
        presenceContext,
        scrapeMotionValues,
      ) {
        const values = {};
        const motionValues = scrapeMotionValues(props, {});
        for (const key in motionValues) {
          values[key] = resolveMotionValue(motionValues[key]);
        }
        let { initial, animate } = props;
        const isControllingVariants$1 = isControllingVariants(props);
        const isVariantNode$1 = isVariantNode(props);
        if (
          context &&
          isVariantNode$1 &&
          !isControllingVariants$1 &&
          props.inherit !== false
        ) {
          if (initial === undefined) initial = context.initial;
          if (animate === undefined) animate = context.animate;
        }
        let isInitialAnimationBlocked = presenceContext
          ? presenceContext.initial === false
          : false;
        isInitialAnimationBlocked =
          isInitialAnimationBlocked || initial === false;
        const variantToSet = isInitialAnimationBlocked ? animate : initial;
        if (
          variantToSet &&
          typeof variantToSet !== "boolean" &&
          !isAnimationControls(variantToSet)
        ) {
          const list = Array.isArray(variantToSet)
            ? variantToSet
            : [variantToSet];
          for (let i = 0; i < list.length; i++) {
            const resolved = resolveVariantFromProps(props, list[i]);
            if (resolved) {
              const { transitionEnd, transition, ...target } = resolved;
              for (const key in target) {
                let valueTarget = target[key];
                if (Array.isArray(valueTarget)) {
                  const index = isInitialAnimationBlocked
                    ? valueTarget.length - 1
                    : 0;
                  valueTarget = valueTarget[index];
                }
                if (valueTarget !== null) {
                  values[key] = valueTarget;
                }
              }
              for (const key in transitionEnd) {
                values[key] = transitionEnd[key];
              }
            }
          }
        }
        return values;
      }
      const makeUseVisualState = (config) => (props, isStatic) => {
        const context = reactExports.useContext(MotionContext);
        const presenceContext = reactExports.useContext(PresenceContext);
        const make = () => makeState(config, props, context, presenceContext);
        return isStatic ? make() : useConstant(make);
      };

      const useHTMLVisualState = /*@__PURE__*/ makeUseVisualState({
        scrapeMotionValuesFromProps: scrapeMotionValuesFromProps$1,
        createRenderState: createHtmlRenderState,
      });

      const useSVGVisualState = /*@__PURE__*/ makeUseVisualState({
        scrapeMotionValuesFromProps: scrapeMotionValuesFromProps,
        createRenderState: createSvgRenderState,
      });

      const motionComponentSymbol = Symbol.for("motionComponentSymbol");

      function useMotionRef(visualState, visualElement, externalRef) {
        const externalRefContainer = reactExports.useRef(externalRef);
        reactExports.useInsertionEffect(() => {
          externalRefContainer.current = externalRef;
        });
        // Store cleanup function returned by callback refs (React 19 feature)
        const refCleanup = reactExports.useRef(null);
        return reactExports.useCallback(
          (instance) => {
            if (instance) {
              visualState.onMount?.(instance);
            }
            if (visualElement) {
              instance
                ? visualElement.mount(instance)
                : visualElement.unmount();
            }
            const ref = externalRefContainer.current;
            if (typeof ref === "function") {
              if (instance) {
                const cleanup = ref(instance);
                if (typeof cleanup === "function") {
                  refCleanup.current = cleanup;
                }
              } else if (refCleanup.current) {
                refCleanup.current();
                refCleanup.current = null;
              } else {
                ref(instance);
              }
            } else if (ref) {
              ref.current = instance;
            }
          },
          [visualElement],
        );
      }

      const SwitchLayoutGroupContext = reactExports.createContext({});

      function isRefObject(ref) {
        return (
          ref &&
          typeof ref === "object" &&
          Object.prototype.hasOwnProperty.call(ref, "current")
        );
      }

      function useVisualElement(
        Component,
        visualState,
        props,
        createVisualElement,
        ProjectionNodeConstructor,
        isSVG,
      ) {
        const { visualElement: parent } =
          reactExports.useContext(MotionContext);
        const lazyContext = reactExports.useContext(LazyContext);
        const presenceContext = reactExports.useContext(PresenceContext);
        const reducedMotionConfig =
          reactExports.useContext(MotionConfigContext).reducedMotion;
        const visualElementRef = reactExports.useRef(null);

        createVisualElement = createVisualElement || lazyContext.renderer;
        if (!visualElementRef.current && createVisualElement) {
          visualElementRef.current = createVisualElement(Component, {
            visualState,
            parent,
            props,
            presenceContext,
            blockInitialAnimation: presenceContext
              ? presenceContext.initial === false
              : false,
            reducedMotionConfig,
            isSVG,
          });
        }
        const visualElement = visualElementRef.current;

        const initialLayoutGroupConfig = reactExports.useContext(
          SwitchLayoutGroupContext,
        );
        if (
          visualElement &&
          !visualElement.projection &&
          ProjectionNodeConstructor &&
          (visualElement.type === "html" || visualElement.type === "svg")
        ) {
          createProjectionNode(
            visualElementRef.current,
            props,
            ProjectionNodeConstructor,
            initialLayoutGroupConfig,
          );
        }
        const isMounted = reactExports.useRef(false);
        reactExports.useInsertionEffect(() => {
          if (visualElement && isMounted.current) {
            visualElement.update(props, presenceContext);
          }
        });

        const optimisedAppearId = props[optimizedAppearDataAttribute];
        const wantsHandoff = reactExports.useRef(
          Boolean(optimisedAppearId) &&
            !window.MotionHandoffIsComplete?.(optimisedAppearId) &&
            window.MotionHasOptimisedAnimation?.(optimisedAppearId),
        );
        useIsomorphicLayoutEffect(() => {
          if (!visualElement) return;
          isMounted.current = true;
          window.MotionIsMounted = true;
          visualElement.updateFeatures();
          visualElement.scheduleRenderMicrotask();

          if (wantsHandoff.current && visualElement.animationState) {
            visualElement.animationState.animateChanges();
          }
        });
        reactExports.useEffect(() => {
          if (!visualElement) return;
          if (!wantsHandoff.current && visualElement.animationState) {
            visualElement.animationState.animateChanges();
          }
          if (wantsHandoff.current) {
            // This ensures all future calls to animateChanges() in this component will run in useEffect
            queueMicrotask(() => {
              window.MotionHandoffMarkAsComplete?.(optimisedAppearId);
            });
            wantsHandoff.current = false;
          }

          visualElement.enteringChildren = undefined;
        });
        return visualElement;
      }
      function createProjectionNode(
        visualElement,
        props,
        ProjectionNodeConstructor,
        initialPromotionConfig,
      ) {
        const {
          layoutId,
          layout,
          drag,
          dragConstraints,
          layoutScroll,
          layoutRoot,
          layoutCrossfade,
        } = props;
        visualElement.projection = new ProjectionNodeConstructor(
          visualElement.latestValues,
          props["data-framer-portal-id"]
            ? undefined
            : getClosestProjectingNode(visualElement.parent),
        );
        visualElement.projection.setOptions({
          layoutId,
          layout,
          alwaysMeasureLayout:
            Boolean(drag) || (dragConstraints && isRefObject(dragConstraints)),
          visualElement,

          animationType: typeof layout === "string" ? layout : "both",
          initialPromotionConfig,
          crossfade: layoutCrossfade,
          layoutScroll,
          layoutRoot,
        });
      }
      function getClosestProjectingNode(visualElement) {
        if (!visualElement) return undefined;
        return visualElement.options.allowProjection !== false
          ? visualElement.projection
          : getClosestProjectingNode(visualElement.parent);
      }

      function createMotionComponent(
        Component,
        { forwardMotionProps = false, type } = {},
        preloadedFeatures,
        createVisualElement,
      ) {
        preloadedFeatures && loadFeatures(preloadedFeatures);
        const isSVG = type ? type === "svg" : isSVGComponent(Component);
        const useVisualState = isSVG ? useSVGVisualState : useHTMLVisualState;
        function MotionDOMComponent(props, externalRef) {
          let MeasureLayout;
          const configAndProps = {
            ...reactExports.useContext(MotionConfigContext),
            ...props,
            layoutId: useLayoutId(props),
          };
          const { isStatic } = configAndProps;
          const context = useCreateMotionContext(props);
          const visualState = useVisualState(props, isStatic);
          if (!isStatic && isBrowser$1) {
            useStrictMode();
            const layoutProjection = getProjectionFunctionality(configAndProps);
            MeasureLayout = layoutProjection.MeasureLayout;
            context.visualElement = useVisualElement(
              Component,
              visualState,
              configAndProps,
              createVisualElement,
              layoutProjection.ProjectionNode,
              isSVG,
            );
          }
          return jsxRuntimeExports.jsxs(MotionContext.Provider, {
            value: context,
            children: [
              MeasureLayout && context.visualElement
                ? jsxRuntimeExports.jsx(MeasureLayout, {
                    visualElement: context.visualElement,
                    ...configAndProps,
                  })
                : null,
              useRender(
                Component,
                props,
                useMotionRef(visualState, context.visualElement, externalRef),
                visualState,
                isStatic,
                forwardMotionProps,
                isSVG,
              ),
            ],
          });
        }
        MotionDOMComponent.displayName = `motion.${typeof Component === "string" ? Component : `create(${Component.displayName ?? Component.name ?? ""})`}`;
        const ForwardRefMotionComponent =
          reactExports.forwardRef(MotionDOMComponent);
        ForwardRefMotionComponent[motionComponentSymbol] = Component;
        return ForwardRefMotionComponent;
      }
      function useLayoutId({ layoutId }) {
        const layoutGroupId = reactExports.useContext(LayoutGroupContext).id;
        return layoutGroupId && layoutId !== void 0
          ? layoutGroupId + "-" + layoutId
          : layoutId;
      }
      function useStrictMode(configAndProps, preloadedFeatures) {
        reactExports.useContext(LazyContext).strict;
      }
      function getProjectionFunctionality(props) {
        const featureDefinitions = getInitializedFeatureDefinitions();
        const { drag, layout } = featureDefinitions;
        if (!drag && !layout) return {};
        const combined = { ...drag, ...layout };
        return {
          MeasureLayout:
            drag?.isEnabled(props) || layout?.isEnabled(props)
              ? combined.MeasureLayout
              : void 0,
          ProjectionNode: combined.ProjectionNode,
        };
      }

      function createMotionProxy(preloadedFeatures, createVisualElement) {
        if (typeof Proxy === "undefined") {
          return createMotionComponent;
        }
        const componentCache = /* @__PURE__ */ new Map();
        const factory = (Component, options) => {
          return createMotionComponent(
            Component,
            options,
            preloadedFeatures,
            createVisualElement,
          );
        };
        const deprecatedFactoryFunction = (Component, options) => {
          return factory(Component, options);
        };
        return new Proxy(deprecatedFactoryFunction, {
          get: (_target, key) => {
            if (key === "create") return factory;
            if (!componentCache.has(key)) {
              componentCache.set(
                key,
                createMotionComponent(
                  key,
                  void 0,
                  preloadedFeatures,
                  createVisualElement,
                ),
              );
            }
            return componentCache.get(key);
          },
        });
      }

      const createDomVisualElement = (Component, options) => {
        const isSVG = options.isSVG ?? isSVGComponent(Component);
        return isSVG
          ? new SVGVisualElement(options)
          : new HTMLVisualElement(options, {
              allowProjection: Component !== reactExports.Fragment,
            });
      };

      class AnimationFeature extends Feature {
        constructor(node) {
          super(node);
          node.animationState ||
            (node.animationState = createAnimationState(node));
        }
        updateAnimationControlsSubscription() {
          const { animate } = this.node.getProps();
          if (isAnimationControls(animate)) {
            this.unmountControls = animate.subscribe(this.node);
          }
        }

        mount() {
          this.updateAnimationControlsSubscription();
        }
        update() {
          const { animate } = this.node.getProps();
          const { animate: prevAnimate } = this.node.prevProps || {};
          if (animate !== prevAnimate) {
            this.updateAnimationControlsSubscription();
          }
        }
        unmount() {
          this.node.animationState.reset();
          this.unmountControls?.();
        }
      }

      let id = 0;
      class ExitAnimationFeature extends Feature {
        constructor() {
          super(...arguments);
          this.id = id++;
        }
        update() {
          if (!this.node.presenceContext) return;
          const { isPresent, onExitComplete } = this.node.presenceContext;
          const { isPresent: prevIsPresent } =
            this.node.prevPresenceContext || {};
          if (!this.node.animationState || isPresent === prevIsPresent) {
            return;
          }
          const exitAnimation = this.node.animationState.setActive(
            "exit",
            !isPresent,
          );
          if (onExitComplete && !isPresent) {
            exitAnimation.then(() => {
              onExitComplete(this.id);
            });
          }
        }
        mount() {
          const { register, onExitComplete } = this.node.presenceContext || {};
          if (onExitComplete) {
            onExitComplete(this.id);
          }
          if (register) {
            this.unmount = register(this.id);
          }
        }
        unmount() {}
      }

      const animations = {
        animation: {
          Feature: AnimationFeature,
        },
        exit: {
          Feature: ExitAnimationFeature,
        },
      };

      function extractEventInfo(event) {
        return {
          point: {
            x: event.pageX,
            y: event.pageY,
          },
        };
      }
      const addPointerInfo = (handler) => {
        return (event) =>
          isPrimaryPointer(event) && handler(event, extractEventInfo(event));
      };

      function addPointerEvent(target, eventName, handler, options) {
        return addDomEvent(target, eventName, addPointerInfo(handler), options);
      }

      // Fixes https://github.com/motiondivision/motion/issues/2270
      const getContextWindow = ({ current }) => {
        return current ? current.ownerDocument.defaultView : null;
      };

      const distance = (a, b) => Math.abs(a - b);
      function distance2D(a, b) {
        // Multi-dimensional
        const xDelta = distance(a.x, b.x);
        const yDelta = distance(a.y, b.y);
        return Math.sqrt(xDelta ** 2 + yDelta ** 2);
      }

      const overflowStyles = /*#__PURE__*/ new Set(["auto", "scroll"]);

      class PanSession {
        constructor(
          event,
          handlers,
          {
            transformPagePoint,
            contextWindow = window,
            dragSnapToOrigin = false,
            distanceThreshold = 3,
            element,
          } = {},
        ) {
          this.startEvent = null;

          this.lastMoveEvent = null;

          this.lastMoveEventInfo = null;

          this.handlers = {};

          this.contextWindow = window;

          this.scrollPositions = new Map();

          this.removeScrollListeners = null;
          this.onElementScroll = (event) => {
            this.handleScroll(event.target);
          };
          this.onWindowScroll = () => {
            this.handleScroll(window);
          };
          this.updatePoint = () => {
            if (!(this.lastMoveEvent && this.lastMoveEventInfo)) return;
            const info = getPanInfo(this.lastMoveEventInfo, this.history);
            const isPanStarted = this.startEvent !== null;
            // Only start panning if the offset is larger than 3 pixels. If we make it
            // any larger than this we'll want to reset the pointer history
            // on the first update to avoid visual snapping to the cursor.
            const isDistancePastThreshold =
              distance2D(info.offset, { x: 0, y: 0 }) >= this.distanceThreshold;
            if (!isPanStarted && !isDistancePastThreshold) return;
            const { point } = info;
            const { timestamp } = frameData;
            this.history.push({ ...point, timestamp });
            const { onStart, onMove } = this.handlers;
            if (!isPanStarted) {
              onStart && onStart(this.lastMoveEvent, info);
              this.startEvent = this.lastMoveEvent;
            }
            onMove && onMove(this.lastMoveEvent, info);
          };
          this.handlePointerMove = (event, info) => {
            this.lastMoveEvent = event;
            this.lastMoveEventInfo = transformPoint(
              info,
              this.transformPagePoint,
            );
            // Throttle mouse move event to once per frame
            frame.update(this.updatePoint, true);
          };
          this.handlePointerUp = (event, info) => {
            this.end();
            const { onEnd, onSessionEnd, resumeAnimation } = this.handlers;
            // Resume animation if dragSnapToOrigin is set OR if no drag started (user just clicked)
            // This ensures constraint animations continue when interrupted by a click
            if (this.dragSnapToOrigin || !this.startEvent) {
              resumeAnimation && resumeAnimation();
            }
            if (!(this.lastMoveEvent && this.lastMoveEventInfo)) return;
            const panInfo = getPanInfo(
              event.type === "pointercancel"
                ? this.lastMoveEventInfo
                : transformPoint(info, this.transformPagePoint),
              this.history,
            );
            if (this.startEvent && onEnd) {
              onEnd(event, panInfo);
            }
            onSessionEnd && onSessionEnd(event, panInfo);
          };
          // If we have more than one touch, don't start detecting this gesture
          if (!isPrimaryPointer(event)) return;
          this.dragSnapToOrigin = dragSnapToOrigin;
          this.handlers = handlers;
          this.transformPagePoint = transformPagePoint;
          this.distanceThreshold = distanceThreshold;
          this.contextWindow = contextWindow || window;
          const info = extractEventInfo(event);
          const initialInfo = transformPoint(info, this.transformPagePoint);
          const { point } = initialInfo;
          const { timestamp } = frameData;
          this.history = [{ ...point, timestamp }];
          const { onSessionStart } = handlers;
          onSessionStart &&
            onSessionStart(event, getPanInfo(initialInfo, this.history));
          this.removeListeners = pipe(
            addPointerEvent(
              this.contextWindow,
              "pointermove",
              this.handlePointerMove,
            ),
            addPointerEvent(
              this.contextWindow,
              "pointerup",
              this.handlePointerUp,
            ),
            addPointerEvent(
              this.contextWindow,
              "pointercancel",
              this.handlePointerUp,
            ),
          );
          // Start scroll tracking if element provided
          if (element) {
            this.startScrollTracking(element);
          }
        }

        startScrollTracking(element) {
          // Store initial scroll positions for scrollable ancestors
          let current = element.parentElement;
          while (current) {
            const style = getComputedStyle(current);
            if (
              overflowStyles.has(style.overflowX) ||
              overflowStyles.has(style.overflowY)
            ) {
              this.scrollPositions.set(current, {
                x: current.scrollLeft,
                y: current.scrollTop,
              });
            }
            current = current.parentElement;
          }
          // Track window scroll
          this.scrollPositions.set(window, {
            x: window.scrollX,
            y: window.scrollY,
          });
          // Capture listener catches element scroll events as they bubble
          window.addEventListener("scroll", this.onElementScroll, {
            capture: true,
            passive: true,
          });
          // Direct window scroll listener (window scroll doesn't bubble)
          window.addEventListener("scroll", this.onWindowScroll, {
            passive: true,
          });
          this.removeScrollListeners = () => {
            window.removeEventListener("scroll", this.onElementScroll, {
              capture: true,
            });
            window.removeEventListener("scroll", this.onWindowScroll);
          };
        }

        handleScroll(target) {
          const initial = this.scrollPositions.get(target);
          if (!initial) return;
          const isWindow = target === window;
          const current = isWindow
            ? { x: window.scrollX, y: window.scrollY }
            : {
                x: target.scrollLeft,
                y: target.scrollTop,
              };
          const delta = { x: current.x - initial.x, y: current.y - initial.y };
          if (delta.x === 0 && delta.y === 0) return;
          if (isWindow) {
            // Window scroll: pageX/pageY changes, so update lastMoveEventInfo
            if (this.lastMoveEventInfo) {
              this.lastMoveEventInfo.point.x += delta.x;
              this.lastMoveEventInfo.point.y += delta.y;
            }
          } else {
            // Element scroll: pageX/pageY unchanged, so adjust history origin
            if (this.history.length > 0) {
              this.history[0].x -= delta.x;
              this.history[0].y -= delta.y;
            }
          }
          this.scrollPositions.set(target, current);
          frame.update(this.updatePoint, true);
        }
        updateHandlers(handlers) {
          this.handlers = handlers;
        }
        end() {
          this.removeListeners && this.removeListeners();
          this.removeScrollListeners && this.removeScrollListeners();
          this.scrollPositions.clear();
          cancelFrame(this.updatePoint);
        }
      }
      function transformPoint(info, transformPagePoint) {
        return transformPagePoint
          ? { point: transformPagePoint(info.point) }
          : info;
      }
      function subtractPoint(a, b) {
        return { x: a.x - b.x, y: a.y - b.y };
      }
      function getPanInfo({ point }, history) {
        return {
          point,
          delta: subtractPoint(point, lastDevicePoint(history)),
          offset: subtractPoint(point, startDevicePoint(history)),
          velocity: getVelocity(history, 0.1),
        };
      }
      function startDevicePoint(history) {
        return history[0];
      }
      function lastDevicePoint(history) {
        return history[history.length - 1];
      }
      function getVelocity(history, timeDelta) {
        if (history.length < 2) {
          return { x: 0, y: 0 };
        }
        let i = history.length - 1;
        let timestampedPoint = null;
        const lastPoint = lastDevicePoint(history);
        while (i >= 0) {
          timestampedPoint = history[i];
          if (
            lastPoint.timestamp - timestampedPoint.timestamp >
            secondsToMilliseconds(timeDelta)
          ) {
            break;
          }
          i--;
        }
        if (!timestampedPoint) {
          return { x: 0, y: 0 };
        }
        const time = millisecondsToSeconds(
          lastPoint.timestamp - timestampedPoint.timestamp,
        );
        if (time === 0) {
          return { x: 0, y: 0 };
        }
        const currentVelocity = {
          x: (lastPoint.x - timestampedPoint.x) / time,
          y: (lastPoint.y - timestampedPoint.y) / time,
        };
        if (currentVelocity.x === Infinity) {
          currentVelocity.x = 0;
        }
        if (currentVelocity.y === Infinity) {
          currentVelocity.y = 0;
        }
        return currentVelocity;
      }

      function applyConstraints(point, { min, max }, elastic) {
        if (min !== undefined && point < min) {
          // If we have a min point defined, and this is outside of that, constrain
          point = elastic
            ? mixNumber$1(min, point, elastic.min)
            : Math.max(point, min);
        } else if (max !== undefined && point > max) {
          // If we have a max point defined, and this is outside of that, constrain
          point = elastic
            ? mixNumber$1(max, point, elastic.max)
            : Math.min(point, max);
        }
        return point;
      }

      function calcRelativeAxisConstraints(axis, min, max) {
        return {
          min: min !== undefined ? axis.min + min : undefined,
          max:
            max !== undefined
              ? axis.max + max - (axis.max - axis.min)
              : undefined,
        };
      }

      function calcRelativeConstraints(
        layoutBox,
        { top, left, bottom, right },
      ) {
        return {
          x: calcRelativeAxisConstraints(layoutBox.x, left, right),
          y: calcRelativeAxisConstraints(layoutBox.y, top, bottom),
        };
      }

      function calcViewportAxisConstraints(layoutAxis, constraintsAxis) {
        let min = constraintsAxis.min - layoutAxis.min;
        let max = constraintsAxis.max - layoutAxis.max;
        // If the constraints axis is actually smaller than the layout axis then we can
        // flip the constraints
        if (
          constraintsAxis.max - constraintsAxis.min <
          layoutAxis.max - layoutAxis.min
        ) {
          [min, max] = [max, min];
        }
        return { min, max };
      }

      function calcViewportConstraints(layoutBox, constraintsBox) {
        return {
          x: calcViewportAxisConstraints(layoutBox.x, constraintsBox.x),
          y: calcViewportAxisConstraints(layoutBox.y, constraintsBox.y),
        };
      }

      function calcOrigin(source, target) {
        let origin = 0.5;
        const sourceLength = calcLength(source);
        const targetLength = calcLength(target);
        if (targetLength > sourceLength) {
          origin = progress(target.min, target.max - sourceLength, source.min);
        } else if (sourceLength > targetLength) {
          origin = progress(source.min, source.max - targetLength, target.min);
        }
        return clamp(0, 1, origin);
      }

      function rebaseAxisConstraints(layout, constraints) {
        const relativeConstraints = {};
        if (constraints.min !== undefined) {
          relativeConstraints.min = constraints.min - layout.min;
        }
        if (constraints.max !== undefined) {
          relativeConstraints.max = constraints.max - layout.min;
        }
        return relativeConstraints;
      }
      const defaultElastic = 0.35;

      function resolveDragElastic(dragElastic = defaultElastic) {
        if (dragElastic === false) {
          dragElastic = 0;
        } else if (dragElastic === true) {
          dragElastic = defaultElastic;
        }
        return {
          x: resolveAxisElastic(dragElastic, "left", "right"),
          y: resolveAxisElastic(dragElastic, "top", "bottom"),
        };
      }
      function resolveAxisElastic(dragElastic, minLabel, maxLabel) {
        return {
          min: resolvePointElastic(dragElastic, minLabel),
          max: resolvePointElastic(dragElastic, maxLabel),
        };
      }
      function resolvePointElastic(dragElastic, label) {
        return typeof dragElastic === "number"
          ? dragElastic
          : dragElastic[label] || 0;
      }

      const elementDragControls = new WeakMap();
      class VisualElementDragControls {
        constructor(visualElement) {
          this.openDragLock = null;
          this.isDragging = false;
          this.currentDirection = null;
          this.originPoint = { x: 0, y: 0 };

          this.constraints = false;
          this.hasMutatedConstraints = false;

          this.elastic = createBox();

          this.latestPointerEvent = null;

          this.latestPanInfo = null;
          this.visualElement = visualElement;
        }
        start(originEvent, { snapToCursor = false, distanceThreshold } = {}) {
          const { presenceContext } = this.visualElement;
          if (presenceContext && presenceContext.isPresent === false) return;
          const onSessionStart = (event) => {
            // Stop or pause animations based on context:
            // - snapToCursor: stop because we'll set new position values
            // - otherwise: pause to allow resume if no drag starts (for constraint animations)
            if (snapToCursor) {
              this.stopAnimation();
              this.snapToCursor(extractEventInfo(event).point);
            } else {
              this.pauseAnimation();
            }
          };
          const onStart = (event, info) => {
            // Stop any paused animation so motion values reflect true current position
            // (pauseAnimation was called in onSessionStart to allow resume if no drag started)
            this.stopAnimation();
            // Attempt to grab the global drag gesture lock - maybe make this part of PanSession
            const { drag, dragPropagation, onDragStart } = this.getProps();
            if (drag && !dragPropagation) {
              if (this.openDragLock) this.openDragLock();
              this.openDragLock = setDragLock(drag);
              // If we don 't have the lock, don't start dragging
              if (!this.openDragLock) return;
            }
            this.latestPointerEvent = event;
            this.latestPanInfo = info;
            this.isDragging = true;
            this.currentDirection = null;
            this.resolveConstraints();
            if (this.visualElement.projection) {
              this.visualElement.projection.isAnimationBlocked = true;
              this.visualElement.projection.target = undefined;
            }

            eachAxis((axis) => {
              let current = this.getAxisMotionValue(axis).get() || 0;

              if (percent.test(current)) {
                const { projection } = this.visualElement;
                if (projection && projection.layout) {
                  const measuredAxis = projection.layout.layoutBox[axis];
                  if (measuredAxis) {
                    const length = calcLength(measuredAxis);
                    current = length * (parseFloat(current) / 100);
                  }
                }
              }
              this.originPoint[axis] = current;
            });
            // Fire onDragStart event
            if (onDragStart) {
              frame.postRender(() => onDragStart(event, info));
            }
            addValueToWillChange(this.visualElement, "transform");
            const { animationState } = this.visualElement;
            animationState && animationState.setActive("whileDrag", true);
          };
          const onMove = (event, info) => {
            this.latestPointerEvent = event;
            this.latestPanInfo = info;
            const {
              dragPropagation,
              dragDirectionLock,
              onDirectionLock,
              onDrag,
            } = this.getProps();
            // If we didn't successfully receive the gesture lock, early return.
            if (!dragPropagation && !this.openDragLock) return;
            const { offset } = info;
            // Attempt to detect drag direction if directionLock is true
            if (dragDirectionLock && this.currentDirection === null) {
              this.currentDirection = getCurrentDirection(offset);
              // If we've successfully set a direction, notify listener
              if (this.currentDirection !== null) {
                onDirectionLock && onDirectionLock(this.currentDirection);
              }
              return;
            }
            // Update each point with the latest position
            this.updateAxis("x", info.point, offset);
            this.updateAxis("y", info.point, offset);

            this.visualElement.render();

            onDrag && onDrag(event, info);
          };
          const onSessionEnd = (event, info) => {
            this.latestPointerEvent = event;
            this.latestPanInfo = info;
            this.stop(event, info);
            this.latestPointerEvent = null;
            this.latestPanInfo = null;
          };
          const resumeAnimation = () =>
            eachAxis(
              (axis) =>
                this.getAnimationState(axis) === "paused" &&
                this.getAxisMotionValue(axis).animation?.play(),
            );
          const { dragSnapToOrigin } = this.getProps();
          this.panSession = new PanSession(
            originEvent,
            {
              onSessionStart,
              onStart,
              onMove,
              onSessionEnd,
              resumeAnimation,
            },
            {
              transformPagePoint: this.visualElement.getTransformPagePoint(),
              dragSnapToOrigin,
              distanceThreshold,
              contextWindow: getContextWindow(this.visualElement),
              element: this.visualElement.current,
            },
          );
        }

        stop(event, panInfo) {
          const finalEvent = event || this.latestPointerEvent;
          const finalPanInfo = panInfo || this.latestPanInfo;
          const isDragging = this.isDragging;
          this.cancel();
          if (!isDragging || !finalPanInfo || !finalEvent) return;
          const { velocity } = finalPanInfo;
          this.startAnimation(velocity);
          const { onDragEnd } = this.getProps();
          if (onDragEnd) {
            frame.postRender(() => onDragEnd(finalEvent, finalPanInfo));
          }
        }

        cancel() {
          this.isDragging = false;
          const { projection, animationState } = this.visualElement;
          if (projection) {
            projection.isAnimationBlocked = false;
          }
          this.panSession && this.panSession.end();
          this.panSession = undefined;
          const { dragPropagation } = this.getProps();
          if (!dragPropagation && this.openDragLock) {
            this.openDragLock();
            this.openDragLock = null;
          }
          animationState && animationState.setActive("whileDrag", false);
        }
        updateAxis(axis, _point, offset) {
          const { drag } = this.getProps();
          // If we're not dragging this axis, do an early return.
          if (!offset || !shouldDrag(axis, drag, this.currentDirection)) return;
          const axisValue = this.getAxisMotionValue(axis);
          let next = this.originPoint[axis] + offset[axis];
          // Apply constraints
          if (this.constraints && this.constraints[axis]) {
            next = applyConstraints(
              next,
              this.constraints[axis],
              this.elastic[axis],
            );
          }
          axisValue.set(next);
        }
        resolveConstraints() {
          const { dragConstraints, dragElastic } = this.getProps();
          const layout =
            this.visualElement.projection &&
            !this.visualElement.projection.layout
              ? this.visualElement.projection.measure(false)
              : this.visualElement.projection?.layout;
          const prevConstraints = this.constraints;
          if (dragConstraints && isRefObject(dragConstraints)) {
            if (!this.constraints) {
              this.constraints = this.resolveRefConstraints();
            }
          } else {
            if (dragConstraints && layout) {
              this.constraints = calcRelativeConstraints(
                layout.layoutBox,
                dragConstraints,
              );
            } else {
              this.constraints = false;
            }
          }
          this.elastic = resolveDragElastic(dragElastic);

          if (
            prevConstraints !== this.constraints &&
            layout &&
            this.constraints &&
            !this.hasMutatedConstraints
          ) {
            eachAxis((axis) => {
              if (this.constraints !== false && this.getAxisMotionValue(axis)) {
                this.constraints[axis] = rebaseAxisConstraints(
                  layout.layoutBox[axis],
                  this.constraints[axis],
                );
              }
            });
          }
        }
        resolveRefConstraints() {
          const { dragConstraints: constraints, onMeasureDragConstraints } =
            this.getProps();
          if (!constraints || !isRefObject(constraints)) return false;
          const constraintsElement = constraints.current;
          const { projection } = this.visualElement;
          // TODO
          if (!projection || !projection.layout) return false;
          const constraintsBox = measurePageBox(
            constraintsElement,
            projection.root,
            this.visualElement.getTransformPagePoint(),
          );
          let measuredConstraints = calcViewportConstraints(
            projection.layout.layoutBox,
            constraintsBox,
          );

          if (onMeasureDragConstraints) {
            const userConstraints = onMeasureDragConstraints(
              convertBoxToBoundingBox(measuredConstraints),
            );
            this.hasMutatedConstraints = !!userConstraints;
            if (userConstraints) {
              measuredConstraints = convertBoundingBoxToBox(userConstraints);
            }
          }
          return measuredConstraints;
        }
        startAnimation(velocity) {
          const {
            drag,
            dragMomentum,
            dragElastic,
            dragTransition,
            dragSnapToOrigin,
            onDragTransitionEnd,
          } = this.getProps();
          const constraints = this.constraints || {};
          const momentumAnimations = eachAxis((axis) => {
            if (!shouldDrag(axis, drag, this.currentDirection)) {
              return;
            }
            let transition = (constraints && constraints[axis]) || {};
            if (dragSnapToOrigin) transition = { min: 0, max: 0 };

            const bounceStiffness = dragElastic ? 200 : 1000000;
            const bounceDamping = dragElastic ? 40 : 10000000;
            const inertia = {
              type: "inertia",
              velocity: dragMomentum ? velocity[axis] : 0,
              bounceStiffness,
              bounceDamping,
              timeConstant: 750,
              restDelta: 1,
              restSpeed: 10,
              ...dragTransition,
              ...transition,
            };
            // If we're not animating on an externally-provided `MotionValue` we can use the
            // component's animation controls which will handle interactions with whileHover (etc),
            // otherwise we just have to animate the `MotionValue` itself.
            return this.startAxisValueAnimation(axis, inertia);
          });
          // Run all animations and then resolve the new drag constraints.
          return Promise.all(momentumAnimations).then(onDragTransitionEnd);
        }
        startAxisValueAnimation(axis, transition) {
          const axisValue = this.getAxisMotionValue(axis);
          addValueToWillChange(this.visualElement, axis);
          return axisValue.start(
            animateMotionValue(
              axis,
              axisValue,
              0,
              transition,
              this.visualElement,
              false,
            ),
          );
        }
        stopAnimation() {
          eachAxis((axis) => this.getAxisMotionValue(axis).stop());
        }
        pauseAnimation() {
          eachAxis((axis) => this.getAxisMotionValue(axis).animation?.pause());
        }
        getAnimationState(axis) {
          return this.getAxisMotionValue(axis).animation?.state;
        }

        getAxisMotionValue(axis) {
          const dragKey = `_drag${axis.toUpperCase()}`;
          const props = this.visualElement.getProps();
          const externalMotionValue = props[dragKey];
          return externalMotionValue
            ? externalMotionValue
            : this.visualElement.getValue(
                axis,
                (props.initial ? props.initial[axis] : undefined) || 0,
              );
        }
        snapToCursor(point) {
          eachAxis((axis) => {
            const { drag } = this.getProps();
            // If we're not dragging this axis, do an early return.
            if (!shouldDrag(axis, drag, this.currentDirection)) return;
            const { projection } = this.visualElement;
            const axisValue = this.getAxisMotionValue(axis);
            if (projection && projection.layout) {
              const { min, max } = projection.layout.layoutBox[axis];

              const current = axisValue.get() || 0;
              axisValue.set(point[axis] - mixNumber$1(min, max, 0.5) + current);
            }
          });
        }

        scalePositionWithinConstraints() {
          if (!this.visualElement.current) return;
          const { drag, dragConstraints } = this.getProps();
          const { projection } = this.visualElement;
          if (!isRefObject(dragConstraints) || !projection || !this.constraints)
            return;

          this.stopAnimation();

          const boxProgress = { x: 0, y: 0 };
          eachAxis((axis) => {
            const axisValue = this.getAxisMotionValue(axis);
            if (axisValue && this.constraints !== false) {
              const latest = axisValue.get();
              boxProgress[axis] = calcOrigin(
                { min: latest, max: latest },
                this.constraints[axis],
              );
            }
          });

          const { transformTemplate } = this.visualElement.getProps();
          this.visualElement.current.style.transform = transformTemplate
            ? transformTemplate({}, "")
            : "none";
          projection.root && projection.root.updateScroll();
          projection.updateLayout();
          this.resolveConstraints();

          eachAxis((axis) => {
            if (!shouldDrag(axis, drag, null)) return;

            const axisValue = this.getAxisMotionValue(axis);
            const { min, max } = this.constraints[axis];
            axisValue.set(mixNumber$1(min, max, boxProgress[axis]));
          });
        }
        addListeners() {
          if (!this.visualElement.current) return;
          elementDragControls.set(this.visualElement, this);
          const element = this.visualElement.current;

          const stopPointerListener = addPointerEvent(
            element,
            "pointerdown",
            (event) => {
              const { drag, dragListener = true } = this.getProps();
              if (
                drag &&
                dragListener &&
                !isElementKeyboardAccessible(event.target)
              ) {
                this.start(event);
              }
            },
          );
          const measureDragConstraints = () => {
            const { dragConstraints } = this.getProps();
            if (isRefObject(dragConstraints) && dragConstraints.current) {
              this.constraints = this.resolveRefConstraints();
            }
          };
          const { projection } = this.visualElement;
          const stopMeasureLayoutListener = projection.addEventListener(
            "measure",
            measureDragConstraints,
          );
          if (projection && !projection.layout) {
            projection.root && projection.root.updateScroll();
            projection.updateLayout();
          }
          frame.read(measureDragConstraints);

          const stopResizeListener = addDomEvent(window, "resize", () =>
            this.scalePositionWithinConstraints(),
          );

          const stopLayoutUpdateListener = projection.addEventListener(
            "didUpdate",
            ({ delta, hasLayoutChanged }) => {
              if (this.isDragging && hasLayoutChanged) {
                eachAxis((axis) => {
                  const motionValue = this.getAxisMotionValue(axis);
                  if (!motionValue) return;
                  this.originPoint[axis] += delta[axis].translate;
                  motionValue.set(motionValue.get() + delta[axis].translate);
                });
                this.visualElement.render();
              }
            },
          );
          return () => {
            stopResizeListener();
            stopPointerListener();
            stopMeasureLayoutListener();
            stopLayoutUpdateListener && stopLayoutUpdateListener();
          };
        }
        getProps() {
          const props = this.visualElement.getProps();
          const {
            drag = false,
            dragDirectionLock = false,
            dragPropagation = false,
            dragConstraints = false,
            dragElastic = defaultElastic,
            dragMomentum = true,
          } = props;
          return {
            ...props,
            drag,
            dragDirectionLock,
            dragPropagation,
            dragConstraints,
            dragElastic,
            dragMomentum,
          };
        }
      }
      function shouldDrag(direction, drag, currentDirection) {
        return (
          (drag === true || drag === direction) &&
          (currentDirection === null || currentDirection === direction)
        );
      }

      function getCurrentDirection(offset, lockThreshold = 10) {
        let direction = null;
        if (Math.abs(offset.y) > lockThreshold) {
          direction = "y";
        } else if (Math.abs(offset.x) > lockThreshold) {
          direction = "x";
        }
        return direction;
      }

      class DragGesture extends Feature {
        constructor(node) {
          super(node);
          this.removeGroupControls = noop;
          this.removeListeners = noop;
          this.controls = new VisualElementDragControls(node);
        }
        mount() {
          // If we've been provided a DragControls for manual control over the drag gesture,
          // subscribe this component to it on mount.
          const { dragControls } = this.node.getProps();
          if (dragControls) {
            this.removeGroupControls = dragControls.subscribe(this.controls);
          }
          this.removeListeners = this.controls.addListeners() || noop;
        }
        update() {
          const { dragControls } = this.node.getProps();
          const { dragControls: prevDragControls } = this.node.prevProps || {};
          if (dragControls !== prevDragControls) {
            this.removeGroupControls();
            if (dragControls) {
              this.removeGroupControls = dragControls.subscribe(this.controls);
            }
          }
        }
        unmount() {
          this.removeGroupControls();
          this.removeListeners();
        }
      }

      const asyncHandler = (handler) => (event, info) => {
        if (handler) {
          frame.postRender(() => handler(event, info));
        }
      };
      class PanGesture extends Feature {
        constructor() {
          super(...arguments);
          this.removePointerDownListener = noop;
        }
        onPointerDown(pointerDownEvent) {
          this.session = new PanSession(
            pointerDownEvent,
            this.createPanHandlers(),
            {
              transformPagePoint: this.node.getTransformPagePoint(),
              contextWindow: getContextWindow(this.node),
            },
          );
        }
        createPanHandlers() {
          const { onPanSessionStart, onPanStart, onPan, onPanEnd } =
            this.node.getProps();
          return {
            onSessionStart: asyncHandler(onPanSessionStart),
            onStart: asyncHandler(onPanStart),
            onMove: onPan,
            onEnd: (event, info) => {
              delete this.session;
              if (onPanEnd) {
                frame.postRender(() => onPanEnd(event, info));
              }
            },
          };
        }
        mount() {
          this.removePointerDownListener = addPointerEvent(
            this.node.current,
            "pointerdown",
            (event) => this.onPointerDown(event),
          );
        }
        update() {
          this.session && this.session.updateHandlers(this.createPanHandlers());
        }
        unmount() {
          this.removePointerDownListener();
          this.session && this.session.end();
        }
      }

      let hasTakenAnySnapshot = false;
      class MeasureLayoutWithContext extends reactExports.Component {
        componentDidMount() {
          const { visualElement, layoutGroup, switchLayoutGroup, layoutId } =
            this.props;
          const { projection } = visualElement;
          if (projection) {
            if (layoutGroup.group) layoutGroup.group.add(projection);
            if (switchLayoutGroup && switchLayoutGroup.register && layoutId) {
              switchLayoutGroup.register(projection);
            }
            if (hasTakenAnySnapshot) {
              projection.root.didUpdate();
            }
            projection.addEventListener("animationComplete", () => {
              this.safeToRemove();
            });
            projection.setOptions({
              ...projection.options,
              onExitComplete: () => this.safeToRemove(),
            });
          }
          globalProjectionState.hasEverUpdated = true;
        }
        getSnapshotBeforeUpdate(prevProps) {
          const { layoutDependency, visualElement, drag, isPresent } =
            this.props;
          const { projection } = visualElement;
          if (!projection) return null;

          projection.isPresent = isPresent;
          hasTakenAnySnapshot = true;
          if (
            drag ||
            prevProps.layoutDependency !== layoutDependency ||
            layoutDependency === undefined ||
            prevProps.isPresent !== isPresent
          ) {
            projection.willUpdate();
          } else {
            this.safeToRemove();
          }
          if (prevProps.isPresent !== isPresent) {
            if (isPresent) {
              projection.promote();
            } else if (!projection.relegate()) {
              frame.postRender(() => {
                const stack = projection.getStack();
                if (!stack || !stack.members.length) {
                  this.safeToRemove();
                }
              });
            }
          }
          return null;
        }
        componentDidUpdate() {
          const { projection } = this.props.visualElement;
          if (projection) {
            projection.root.didUpdate();
            microtask.postRender(() => {
              if (!projection.currentAnimation && projection.isLead()) {
                this.safeToRemove();
              }
            });
          }
        }
        componentWillUnmount() {
          const {
            visualElement,
            layoutGroup,
            switchLayoutGroup: promoteContext,
          } = this.props;
          const { projection } = visualElement;
          hasTakenAnySnapshot = true;
          if (projection) {
            projection.scheduleCheckAfterUnmount();
            if (layoutGroup && layoutGroup.group)
              layoutGroup.group.remove(projection);
            if (promoteContext && promoteContext.deregister)
              promoteContext.deregister(projection);
          }
        }
        safeToRemove() {
          const { safeToRemove } = this.props;
          safeToRemove && safeToRemove();
        }
        render() {
          return null;
        }
      }
      function MeasureLayout(props) {
        const [isPresent, safeToRemove] = usePresence();
        const layoutGroup = reactExports.useContext(LayoutGroupContext);
        return jsxRuntimeExports.jsx(MeasureLayoutWithContext, {
          ...props,
          layoutGroup: layoutGroup,
          switchLayoutGroup: reactExports.useContext(SwitchLayoutGroupContext),
          isPresent: isPresent,
          safeToRemove: safeToRemove,
        });
      }

      const drag = {
        pan: {
          Feature: PanGesture,
        },
        drag: {
          Feature: DragGesture,
          ProjectionNode: HTMLProjectionNode,
          MeasureLayout,
        },
      };

      function handleHoverEvent(node, event, lifecycle) {
        const { props } = node;
        if (node.animationState && props.whileHover) {
          node.animationState.setActive("whileHover", lifecycle === "Start");
        }
        const eventName = "onHover" + lifecycle;
        const callback = props[eventName];
        if (callback) {
          frame.postRender(() => callback(event, extractEventInfo(event)));
        }
      }
      class HoverGesture extends Feature {
        mount() {
          const { current } = this.node;
          if (!current) return;
          this.unmount = hover(current, (_element, startEvent) => {
            handleHoverEvent(this.node, startEvent, "Start");
            return (endEvent) => handleHoverEvent(this.node, endEvent, "End");
          });
        }
        unmount() {}
      }

      class FocusGesture extends Feature {
        constructor() {
          super(...arguments);
          this.isActive = false;
        }
        onFocus() {
          let isFocusVisible = false;

          try {
            isFocusVisible = this.node.current.matches(":focus-visible");
          } catch (e) {
            isFocusVisible = true;
          }
          if (!isFocusVisible || !this.node.animationState) return;
          this.node.animationState.setActive("whileFocus", true);
          this.isActive = true;
        }
        onBlur() {
          if (!this.isActive || !this.node.animationState) return;
          this.node.animationState.setActive("whileFocus", false);
          this.isActive = false;
        }
        mount() {
          this.unmount = pipe(
            addDomEvent(this.node.current, "focus", () => this.onFocus()),
            addDomEvent(this.node.current, "blur", () => this.onBlur()),
          );
        }
        unmount() {}
      }

      function handlePressEvent(node, event, lifecycle) {
        const { props } = node;
        if (
          node.current instanceof HTMLButtonElement &&
          node.current.disabled
        ) {
          return;
        }
        if (node.animationState && props.whileTap) {
          node.animationState.setActive("whileTap", lifecycle === "Start");
        }
        const eventName = "onTap" + (lifecycle === "End" ? "" : lifecycle);
        const callback = props[eventName];
        if (callback) {
          frame.postRender(() => callback(event, extractEventInfo(event)));
        }
      }
      class PressGesture extends Feature {
        mount() {
          const { current } = this.node;
          if (!current) return;
          this.unmount = press(
            current,
            (_element, startEvent) => {
              handlePressEvent(this.node, startEvent, "Start");
              return (endEvent, { success }) =>
                handlePressEvent(
                  this.node,
                  endEvent,
                  success ? "End" : "Cancel",
                );
            },
            { useGlobalTarget: this.node.props.globalTapTarget },
          );
        }
        unmount() {}
      }

      const observerCallbacks = new WeakMap();

      const observers = new WeakMap();
      const fireObserverCallback = (entry) => {
        const callback = observerCallbacks.get(entry.target);
        callback && callback(entry);
      };
      const fireAllObserverCallbacks = (entries) => {
        entries.forEach(fireObserverCallback);
      };
      function initIntersectionObserver({ root, ...options }) {
        const lookupRoot = root || document;

        if (!observers.has(lookupRoot)) {
          observers.set(lookupRoot, {});
        }
        const rootObservers = observers.get(lookupRoot);
        const key = JSON.stringify(options);

        if (!rootObservers[key]) {
          rootObservers[key] = new IntersectionObserver(
            fireAllObserverCallbacks,
            { root, ...options },
          );
        }
        return rootObservers[key];
      }
      function observeIntersection(element, options, callback) {
        const rootInteresectionObserver = initIntersectionObserver(options);
        observerCallbacks.set(element, callback);
        rootInteresectionObserver.observe(element);
        return () => {
          observerCallbacks.delete(element);
          rootInteresectionObserver.unobserve(element);
        };
      }

      const thresholdNames = {
        some: 0,
        all: 1,
      };
      class InViewFeature extends Feature {
        constructor() {
          super(...arguments);
          this.hasEnteredView = false;
          this.isInView = false;
        }
        startObserver() {
          this.unmount();
          const { viewport = {} } = this.node.getProps();
          const { root, margin: rootMargin, amount = "some", once } = viewport;
          const options = {
            root: root ? root.current : undefined,
            rootMargin,
            threshold:
              typeof amount === "number" ? amount : thresholdNames[amount],
          };
          const onIntersectionUpdate = (entry) => {
            const { isIntersecting } = entry;

            if (this.isInView === isIntersecting) return;
            this.isInView = isIntersecting;

            if (once && !isIntersecting && this.hasEnteredView) {
              return;
            } else if (isIntersecting) {
              this.hasEnteredView = true;
            }
            if (this.node.animationState) {
              this.node.animationState.setActive("whileInView", isIntersecting);
            }

            const { onViewportEnter, onViewportLeave } = this.node.getProps();
            const callback = isIntersecting ? onViewportEnter : onViewportLeave;
            callback && callback(entry);
          };
          return observeIntersection(
            this.node.current,
            options,
            onIntersectionUpdate,
          );
        }
        mount() {
          this.startObserver();
        }
        update() {
          if (typeof IntersectionObserver === "undefined") return;
          const { props, prevProps } = this.node;
          const hasOptionsChanged = ["amount", "margin", "root"].some(
            hasViewportOptionChanged(props, prevProps),
          );
          if (hasOptionsChanged) {
            this.startObserver();
          }
        }
        unmount() {}
      }
      function hasViewportOptionChanged(
        { viewport = {} },
        { viewport: prevViewport = {} } = {},
      ) {
        return (name) => viewport[name] !== prevViewport[name];
      }

      const gestureAnimations = {
        inView: {
          Feature: InViewFeature,
        },
        tap: {
          Feature: PressGesture,
        },
        focus: {
          Feature: FocusGesture,
        },
        hover: {
          Feature: HoverGesture,
        },
      };

      const layout = {
        layout: {
          ProjectionNode: HTMLProjectionNode,
          MeasureLayout,
        },
      };

      const featureBundle = {
        ...animations,
        ...gestureAnimations,
        ...drag,
        ...layout,
      };

      const motion = /*@__PURE__*/ createMotionProxy(
        featureBundle,
        createDomVisualElement,
      );

      const buttonVariants = cva(
        "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
        {
          variants: {
            variant: {
              default: "bg-primary text-primary-foreground hover:bg-primary/90",
              destructive:
                "bg-destructive text-destructive-foreground hover:bg-destructive/90",
              outline:
                "border border-input bg-background hover:bg-accent hover:text-accent-foreground",
              secondary:
                "bg-secondary text-secondary-foreground hover:bg-secondary/80",
              ghost: "hover:bg-accent hover:text-accent-foreground",
              link: "text-primary underline-offset-4 hover:underline",
            },
            size: {
              default: "h-10 px-4 py-2",
              sm: "h-9 rounded-md px-3",
              lg: "h-11 rounded-md px-8",
              icon: "h-10 w-10",
            },
          },
          defaultVariants: {
            variant: "default",
            size: "default",
          },
        },
      );
      const Button = reactExports.forwardRef(
        ({ className, variant, size, asChild = false, ...props }, ref) => {
          const Comp = asChild ? Slot : "button";
          return /* @__PURE__ */ jsxRuntimeExports.jsx(Comp, {
            className: cn(buttonVariants({ variant, size, className })),
            ref,
            ...props,
          });
        },
      );
      Button.displayName = "Button";

      function Header({
        title,
        instruction,
        onPrev,
        onNext,
        canGoPrev,
        canGoNext,
        currentPage,
        totalPages,
      }) {
        return /* @__PURE__ */ jsxRuntimeExports.jsxs("header", {
          className:
            "relative flex items-center justify-between px-6 py-4 bg-card border-b-2 border-primary/30 shadow-lg z-10",
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
              className:
                "absolute top-0 left-0 right-0 h-1 hazard-stripes opacity-60",
            }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(Button, {
              variant: "outline",
              onClick: onPrev,
              disabled: !canGoPrev,
              className:
                "min-w-16 min-h-14 gap-2 bg-muted border-2 border-primary/30 text-primary hover:border-primary hover:bg-primary/10 hover:shadow-glow transition-all disabled:opacity-30 rounded-none",
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(ChevronLeft, {
                  className: "w-5 h-5",
                }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
                  className:
                    "hidden sm:inline uppercase tracking-wider text-sm",
                  children: "Назад",
                }),
              ],
            }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(
              motion.div,
              {
                className: "text-center flex-1 px-4",
                initial: { opacity: 0, y: -10 },
                animate: { opacity: 1, y: 0 },
                transition: { duration: 0.3 },
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", {
                    className: "flex items-center justify-center gap-3 mb-1",
                    children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(FlaskRound, {
                        className: "w-7 h-7 text-accent",
                      }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("h1", {
                        className:
                          "text-2xl sm:text-3xl font-bold uppercase tracking-wider gradient-text",
                        children: title,
                      }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(Skull, {
                        className: "w-6 h-6 text-primary/60",
                      }),
                    ],
                  }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("p", {
                    className:
                      "text-sm text-muted-foreground font-mono-chem tracking-wide",
                    children: instruction,
                  }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", {
                    className: "flex items-center justify-center gap-2 mt-2",
                    children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsxs("span", {
                        className: "text-xs text-primary/60 font-mono-chem",
                        children: ["УРОВЕНЬ ", currentPage, "/", totalPages],
                      }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
                        className: "text-primary/40",
                        children: "|",
                      }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
                        className:
                          "text-xs text-accent font-mono-chem animate-pulse",
                        children: "☢ ОПАСНО",
                      }),
                    ],
                  }),
                ],
              },
              title,
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(Button, {
              variant: "outline",
              onClick: onNext,
              disabled: !canGoNext,
              className:
                "min-w-16 min-h-14 gap-2 bg-muted border-2 border-primary/30 text-primary hover:border-primary hover:bg-primary/10 hover:shadow-glow transition-all disabled:opacity-30 rounded-none",
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
                  className:
                    "hidden sm:inline uppercase tracking-wider text-sm",
                  children: "Далее",
                }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(ChevronRight, {
                  className: "w-5 h-5",
                }),
              ],
            }),
          ],
        });
      }

      function Footer({ onCheck, onReset, isAllColored }) {
        return /* @__PURE__ */ jsxRuntimeExports.jsxs("footer", {
          className:
            "relative flex justify-center gap-4 px-6 py-4 bg-card border-t-2 border-primary/30",
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
              className:
                "absolute bottom-0 left-0 right-0 h-1 hazard-stripes opacity-60",
            }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(motion.div, {
              whileHover: { scale: 1.02 },
              whileTap: { scale: 0.98 },
              children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Button, {
                onClick: onCheck,
                disabled: !isAllColored,
                className:
                  "min-w-48 min-h-14 gap-3 text-lg font-bold uppercase tracking-wider gradient-bg-success text-foreground border-none rounded-none hover:shadow-toxic hover:-translate-y-0.5 transition-all disabled:opacity-30",
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Check, {
                    className: "w-5 h-5",
                  }),
                  "Проверить",
                ],
              }),
            }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(motion.div, {
              whileHover: { scale: 1.02 },
              whileTap: { scale: 0.98 },
              children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Button, {
                variant: "outline",
                onClick: onReset,
                className:
                  "min-w-48 min-h-14 gap-3 text-lg font-bold uppercase tracking-wider bg-muted border-2 border-destructive/50 text-destructive rounded-none hover:border-destructive hover:bg-destructive/10 hover:-translate-y-0.5 transition-all",
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(RotateCcw, {
                    className: "w-5 h-5",
                  }),
                  "Сбросить",
                ],
              }),
            }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
              className: "absolute right-4 top-1/2 -translate-y-1/2 opacity-20",
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(Radiation, {
                className: "w-8 h-8 text-primary animate-pulse",
              }),
            }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
              className: "absolute left-4 top-1/2 -translate-y-1/2 opacity-20",
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(Radiation, {
                className: "w-8 h-8 text-primary animate-pulse",
              }),
            }),
          ],
        });
      }

      function ColorPalette({
        colors,
        selectedColor,
        onSelectColor,
        availableColors,
        onGlobalDrop,
      }) {
        const filteredColors = availableColors
          ? colors.filter((c) => availableColors.includes(c.key))
          : colors;
        const dragImagesRef = React.useRef(/* @__PURE__ */ new Map());
        React.useEffect(() => {
          filteredColors.forEach((colorInfo) => {
            const canvas = document.createElement("canvas");
            canvas.width = 60;
            canvas.height = 60;
            const ctx = canvas.getContext("2d");
            if (ctx) {
              ctx.fillStyle = colorInfo.color;
              ctx.beginPath();
              ctx.arc(30, 30, 28, 0, Math.PI * 2);
              ctx.fill();
              ctx.strokeStyle = "white";
              ctx.lineWidth = 4;
              ctx.stroke();
            }
            const img = new Image();
            img.src = canvas.toDataURL();
            dragImagesRef.current.set(colorInfo.key, img);
          });
        }, [filteredColors]);
        return /* @__PURE__ */ jsxRuntimeExports.jsxs("aside", {
          className:
            "w-56 min-w-56 bg-card border-r-2 border-primary/20 p-5 overflow-y-auto flex flex-col",
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", {
              className:
                "flex items-center justify-center gap-2 mb-4 pb-3 border-b border-primary/20",
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Beaker, {
                  className: "w-5 h-5 text-accent",
                }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("h2", {
                  className:
                    "text-sm font-bold text-primary uppercase tracking-widest",
                  children: "Реагенты",
                }),
              ],
            }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
              className: "flex flex-col gap-3",
              children: filteredColors.map((colorInfo, index) =>
                /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  motion.button,
                  {
                    initial: { opacity: 0, x: -20 },
                    animate: { opacity: 1, x: 0 },
                    transition: { delay: index * 0.05 },
                    onClick: () => onSelectColor(colorInfo.key),
                    draggable: true,
                    onTouchStart: (e) => {
                      const touch = e.touches[0];
                      const ghost = document.createElement("div");
                      ghost.style.position = "fixed";
                      ghost.style.width = "60px";
                      ghost.style.height = "60px";
                      ghost.style.borderRadius = "50%";
                      ghost.style.backgroundColor = colorInfo.color;
                      ghost.style.border = "4px solid white";
                      ghost.style.boxShadow = "0 0 20px rgba(0,0,0,0.5)";
                      ghost.style.zIndex = "2147483647";
                      ghost.style.pointerEvents = "none";
                      ghost.id = `touch-ghost-${colorInfo.key}`;
                      ghost.style.left = `${touch.clientX - 30}px`;
                      ghost.style.top = `${touch.clientY - 30}px`;
                      document.body.appendChild(ghost);
                      const moveHandler = (tm) => {
                        if (tm.cancelable) tm.preventDefault();
                        const t = tm.touches[0];
                        ghost.style.left = `${t.clientX - 30}px`;
                        ghost.style.top = `${t.clientY - 30}px`;
                      };
                      const endHandler = (te) => {
                        const t = te.changedTouches[0];
                        if (onGlobalDrop) {
                          onGlobalDrop(t.clientX, t.clientY, colorInfo.key);
                        }
                        if (ghost.parentNode) {
                          ghost.parentNode.removeChild(ghost);
                        }
                        window.removeEventListener("touchmove", moveHandler);
                        window.removeEventListener("touchend", endHandler);
                      };
                      window.addEventListener("touchmove", moveHandler, {
                        passive: false,
                      });
                      window.addEventListener("touchend", endHandler);
                    },
                    onDragStart: (e) => {
                      e.dataTransfer.setData("text/plain", colorInfo.key);
                      e.dataTransfer.effectAllowed = "copy";
                      const img = dragImagesRef.current.get(colorInfo.key);
                      if (img) {
                        e.dataTransfer.setDragImage(img, 30, 30);
                      }
                    },
                    className: cn(
                      "relative flex items-center gap-3 p-3 bg-muted border-2 border-transparent cursor-pointer transition-all duration-200 min-h-16 rounded-none",
                      selectedColor === colorInfo.key
                        ? "border-primary shadow-glow bg-primary/10"
                        : "border-muted-foreground/20 hover:border-primary/50 hover:bg-primary/5",
                    ),
                    children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", {
                        className: "relative",
                        children: [
                          /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
                            className:
                              "w-10 h-10 min-w-10 shadow-md border border-foreground/20",
                            style: {
                              backgroundColor: colorInfo.color,
                              clipPath:
                                "polygon(10% 0, 90% 0, 100% 100%, 0 100%)",
                            },
                          }),
                          selectedColor === colorInfo.key &&
                            /* @__PURE__ */ jsxRuntimeExports.jsx(motion.div, {
                              initial: { scale: 0 },
                              animate: { scale: 1 },
                              className:
                                "absolute -top-1 -right-1 w-4 h-4 bg-primary flex items-center justify-center text-xs text-background font-bold",
                              children: "✓",
                            }),
                        ],
                      }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
                        className:
                          "text-sm font-semibold text-foreground leading-tight font-mono-chem",
                        children: colorInfo.label,
                      }),
                      selectedColor === colorInfo.key &&
                        /* @__PURE__ */ jsxRuntimeExports.jsx(motion.div, {
                          layoutId: "selectedIndicator",
                          className:
                            "absolute left-0 top-0 bottom-0 w-1 bg-primary",
                        }),
                    ],
                  },
                  colorInfo.key,
                ),
              ),
            }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
              className: "mt-auto pt-4 border-t border-primary/20",
              children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
                className: "text-center",
                children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
                  className: "text-xs text-destructive font-mono-chem",
                  children: "⚠ ТОКСИЧНО",
                }),
              }),
            }),
          ],
        });
      }

      const COLOR_PALETTES = {
        saltEnvironment: {
          id: "saltEnvironment",
          name: "Среда солей",
          colors: [
            { key: "acidic", color: "#E74C3C", label: "Кислая" },
            { key: "neutral", color: "#2ECC71", label: "Нейтральная" },
            { key: "alkaline", color: "#F1C40F", label: "Щелочная" },
          ],
        },
        flameColors: {
          id: "flameColors",
          name: "Цвет пламени",
          colors: [
            { key: "yellow", color: "#FFD700", label: "Na⁺ — Жёлтый" },
            { key: "violet", color: "#9B59B6", label: "K⁺ — Фиолетовый" },
            { key: "red", color: "#C0392B", label: "Sr²⁺, Li⁺ — Красный" },
            { key: "green", color: "#27AE60", label: "Ba²⁺ — Зелёный" },
            { key: "orange", color: "#E67E22", label: "Ca²⁺ — Оранжевый" },
            { key: "colorless", color: "#D5D5D5", label: "Бесцветный" },
          ],
        },
        substanceColors: {
          id: "substanceColors",
          name: "Цвета веществ",
          colors: [
            { key: "white", color: "#FFFFFF", label: "Белый" },
            { key: "black", color: "#000000", label: "Чёрный" },
            { key: "green", color: "#27AE60", label: "Зелёный" },
            { key: "brown", color: "#8B4513", label: "Коричневый" },
            { key: "yellow", color: "#F1C40F", label: "Жёлтый" },
            { key: "orange", color: "#E67E22", label: "Оранжевый" },
            { key: "red", color: "#E74C3C", label: "Красный" },
            { key: "blue", color: "#3498DB", label: "Синий" },
            { key: "gray", color: "#95A5A6", label: "Серый" },
            { key: "violet", color: "#9B59B6", label: "Фиолетовый" },
            { key: "pink", color: "#E91E63", label: "Розовый" },
            // New colors from user images (Legacy Compat)
            { key: "red_deep", color: "#D50D09", label: "Тёмно-красный" },
            { key: "red_orange", color: "#EF3F0E", label: "Красно-оранжевый" },
            { key: "pink_hot", color: "#FB4B82", label: "Ярко-розовый" },
            { key: "red_bordeaux", color: "#A01A14", label: "Бордовый" },
            { key: "pink_pale", color: "#C2756E", label: "Бледно-розовый" },
            { key: "orange_bright", color: "#FE5D00", label: "Ярко-оранжевый" },
            { key: "yellow_bright", color: "#FDE801", label: "Ярко-жёлтый" },
            { key: "orange_burnt", color: "#E36820", label: "Рыжий" },
            { key: "salmon", color: "#E28366", label: "Лососевый" },
            { key: "sand", color: "#F2DE97", label: "Песочный" },
            { key: "green_forest", color: "#206A16", label: "Лесной зелёный" },
            { key: "green_bright", color: "#44D162", label: "Ярко-зелёный" },
            { key: "green_pale", color: "#78AC62", label: "Бледно-зелёный" },
            { key: "mint", color: "#BAFDCE", label: "Мятный" },
            { key: "turquoise", color: "#3FE5B9", label: "Бирюзовый" },
            { key: "blue_bright", color: "#1152C2", label: "Ярко-синий" },
            { key: "sky_blue", color: "#288CDE", label: "Голубой" },
            { key: "pale_blue", color: "#B9E3D0", label: "Бледно-голубой" },
            { key: "lilac", color: "#9C7AAC", label: "Сиреневый" },
            { key: "purple_deep", color: "#905AAE", label: "Тёмно-фиолетовый" },
            { key: "brown_red", color: "#6B2616", label: "Красно-коричневый" },
            { key: "brown_dark", color: "#4B1C0A", label: "Тёмно-коричневый" },
            { key: "chocolate", color: "#57290F", label: "Шоколадный" },
            { key: "gray_light", color: "#A6A6A6", label: "Светло-серый" },
          ],
        },
      };
      const COLORING_PAGES = [
        {
          id: "bells",
          title: "Колокольчики",
          instruction: "Раскрась участки рисунка в зависимости от среды солей",
          palette: "saltEnvironment",
          icon: "🔔",
          zones: [
            { id: "KClO4", formula: "KClO₄", correctColor: "neutral" },
            { id: "MgSO4", formula: "MgSO₄", correctColor: "acidic" },
            { id: "FeCl3", formula: "FeCl₃", correctColor: "acidic" },
            { id: "Na2Cr2O7", formula: "Na₂Cr₂O₇", correctColor: "neutral" },
            { id: "CuBr2", formula: "CuBr₂", correctColor: "acidic" },
            { id: "ZnNO32", formula: "Zn(NO₃)₂", correctColor: "acidic" },
            { id: "Al2SO43", formula: "Al₂(SO₄)₃", correctColor: "acidic" },
            { id: "FeCl2", formula: "FeCl₂", correctColor: "acidic" },
            { id: "NH4I", formula: "NH₄I", correctColor: "acidic" },
            { id: "K3PO4", formula: "K₃PO₄", correctColor: "alkaline" },
            { id: "Na2HPO4", formula: "Na₂HPO₄", correctColor: "alkaline" },
            { id: "Na2SiO3", formula: "Na₂SiO₃", correctColor: "alkaline" },
            { id: "Rb2S", formula: "Rb₂S", correctColor: "alkaline" },
            { id: "BaNO32", formula: "Ba(NO₃)₂", correctColor: "neutral" },
            { id: "Li2CO3", formula: "Li₂CO₃", correctColor: "alkaline" },
          ],
        },
        {
          id: "tree",
          title: "Новогодняя ёлка",
          instruction: "Раскрась по цвету пламени указанных ионов",
          palette: "flameColors",
          icon: "🎄",
          zones: [
            { id: "Na1", formula: "Na⁺", correctColor: "yellow" },
            { id: "Ba1", formula: "Ba²⁺", correctColor: "green" },
            { id: "K1", formula: "K⁺", correctColor: "violet" },
            { id: "K2", formula: "K⁺", correctColor: "violet" },
            { id: "Sr1", formula: "Sr²⁺", correctColor: "red" },
            { id: "Sr2", formula: "Sr²⁺", correctColor: "red" },
            { id: "Sr3", formula: "Sr²⁺", correctColor: "red" },
            { id: "Ca1", formula: "Ca²⁺", correctColor: "orange" },
            { id: "Na2", formula: "Na⁺", correctColor: "yellow" },
            { id: "Na3", formula: "Na⁺", correctColor: "yellow" },
            { id: "Ba2", formula: "Ba²⁺", correctColor: "green" },
            { id: "Zn1", formula: "Zn²⁺", correctColor: "colorless" },
            { id: "Li1", formula: "Li⁺", correctColor: "red" },
            { id: "K3", formula: "K⁺", correctColor: "violet" },
            { id: "Ba3", formula: "Ba²⁺", correctColor: "green" },
          ],
        },
        {
          id: "sock",
          title: "Рождественский носок",
          instruction: "Раскрась по цветам указанных веществ",
          palette: "substanceColors",
          icon: "🧦",
          zones: [
            { id: "AgCl", formula: "AgCl", correctColor: "white" },
            { id: "BaCO3", formula: "BaCO₃", correctColor: "white" },
            { id: "CrOH3", formula: "Cr(OH)₃", correctColor: "green" },
            { id: "Br2", formula: "Br₂", correctColor: "brown" },
            { id: "CrO3", formula: "CrO₃", correctColor: "orange" },
            { id: "PbI2", formula: "PbI₂", correctColor: "yellow" },
            { id: "KMnO4", formula: "KMnO₄", correctColor: "violet" },
          ],
        },
        {
          id: "wreath",
          title: "Рождественский венок",
          instruction: "Раскрась по цветам указанных веществ",
          palette: "substanceColors",
          icon: "🎀",
          zones: [
            { id: "CrO3_1", formula: "CrO₃", correctColor: "orange" },
            { id: "Cu1", formula: "Cu", correctColor: "red" },
            { id: "Cu2", formula: "Cu", correctColor: "red" },
            { id: "Cr2O3_1", formula: "Cr₂O₃", correctColor: "green" },
            { id: "Cr2O3_2", formula: "Cr₂O₃", correctColor: "green" },
            { id: "S1", formula: "S", correctColor: "yellow" },
            { id: "S2", formula: "S", correctColor: "yellow" },
            { id: "BaS1", formula: "BaS", correctColor: "white" },
            { id: "AgI1", formula: "AgI", correctColor: "yellow" },
            { id: "AgCl1", formula: "AgCl", correctColor: "white" },
            { id: "PbI2", formula: "PbI₂", correctColor: "yellow" },
          ],
        },
        {
          id: "candle",
          title: "Праздничная свеча",
          instruction: "Раскрась по цветам указанных веществ",
          palette: "substanceColors",
          icon: "🕯️",
          zones: [
            { id: "K2Cr2O7", formula: "K₂Cr₂O₇", correctColor: "orange" },
            { id: "ZnOH2", formula: "Zn(OH)₂", correctColor: "white" },
            { id: "SiO2", formula: "SiO₂", correctColor: "white" },
            { id: "AgBr", formula: "AgBr", correctColor: "yellow" },
            { id: "Ba3PO42", formula: "Ba₃(PO₄)₂", correctColor: "white" },
            { id: "Ag3PO4", formula: "Ag₃PO₄", correctColor: "yellow" },
            { id: "CuSO4_dry", formula: "CuSO₄", correctColor: "white" },
            { id: "Cl2", formula: "Cl₂", correctColor: "yellow" },
            { id: "CaCO3", formula: "CaCO₃", correctColor: "white" },
            { id: "FeOH2", formula: "Fe(OH)₂", correctColor: "white" },
            { id: "CrO3_1", formula: "CrO₃", correctColor: "orange" },
            { id: "CrO3_2", formula: "CrO₃", correctColor: "orange" },
          ],
        },
      ];
      function getAvailableColors(page) {
        const usedColors = new Set(page.zones.map((z) => z.correctColor));
        return Array.from(usedColors);
      }
      function getAllPages() {
        let pages = [...COLORING_PAGES];
        if (window.CUSTOM_PAGES) {
          Object.values(window.CUSTOM_PAGES).forEach((customPage) => {
            const existingIndex = pages.findIndex(
              (p) => p.id === customPage.id,
            );
            const mergedPage =
              existingIndex >= 0
                ? { ...pages[existingIndex], ...customPage }
                : customPage;
            if (!mergedPage.image) {
              mergedPage.image = `images/${mergedPage.id}.png`;
            }
            if (!mergedPage.icon) mergedPage.icon = "🎨";
            if (existingIndex >= 0) {
              pages[existingIndex] = mergedPage;
            } else {
              pages.push(mergedPage);
            }
          });
        }
        if (window.DATA_MANIFEST && Array.isArray(window.DATA_MANIFEST)) {
          new Set(
            window.DATA_MANIFEST.map((filename) =>
              filename.replace(/\.js$/, ""),
            ),
          );
          const orderedPages = [];
          window.DATA_MANIFEST.forEach((filename) => {
            const id = filename.replace(/\.js$/, "");
            const page = pages.find((p) => p.id === id);
            if (page) {
              if (!orderedPages.find((p) => p.id === id)) {
                orderedPages.push(page);
              }
            }
          });
          return orderedPages;
        }
        return pages;
      }

      const ColoringArea = reactExports.forwardRef(
        (
          {
            zones,
            coloredZones,
            selectedColor,
            paletteId,
            verificationResult,
            onZoneClick,
            onZoneDrop,
            imagePath,
          },
          ref,
        ) => {
          const canvasRef = reactExports.useRef(null);
          const [image, setImage] = reactExports.useState(null);
          const containerRef = reactExports.useRef(null);
          const [scale, setScale] = reactExports.useState(1);
          reactExports.useEffect(() => {
            if (!imagePath) return;
            const img = new Image();
            img.src = imagePath;
            img.onload = () => {
              setImage(img);
            };
            img.onerror = () => {
              console.error("Failed to load image:", imagePath);
            };
          }, [imagePath]);
          reactExports.useEffect(() => {
            const handleResize = () => {
              if (!containerRef.current || !image) return;
              const container = containerRef.current;
              const aspect = image.width / image.height;
              let displayWidth = container.clientWidth;
              let displayHeight = displayWidth / aspect;
              if (displayHeight > container.clientHeight) {
                displayHeight = container.clientHeight;
                displayWidth = displayHeight * aspect;
              }
              setScale(displayWidth / image.width);
            };
            window.addEventListener("resize", handleResize);
            handleResize();
            return () => window.removeEventListener("resize", handleResize);
          }, [image]);
          reactExports.useEffect(() => {
            const canvas = canvasRef.current;
            if (!canvas || !image) return;
            const ctx = canvas.getContext("2d");
            if (!ctx) return;
            canvas.width = image.width;
            canvas.height = image.height;
            ctx.drawImage(image, 0, 0);
            const zonesToDraw = zones
              .filter((z) => z.points && z.points.length > 0)
              .map((zone) => ({
                zone,
                area: getPolygonArea(zone.points),
              }))
              .sort((a, b) => b.area - a.area);
            const isZoneContainedIn = (innerPts, outerPts) => {
              let cx = 0,
                cy = 0;
              for (const p of innerPts) {
                cx += p[0];
                cy += p[1];
              }
              cx /= innerPts.length;
              cy /= innerPts.length;
              let inside = false;
              for (
                let i = 0, j = outerPts.length - 1;
                i < outerPts.length;
                j = i++
              ) {
                const xi = outerPts[i][0],
                  yi = outerPts[i][1];
                const xj = outerPts[j][0],
                  yj = outerPts[j][1];
                const intersect =
                  yi > cy !== yj > cy &&
                  cx < ((xj - xi) * (cy - yi)) / (yj - yi) + xi;
                if (intersect) inside = !inside;
              }
              return inside;
            };
            const zonesWithHoles = zonesToDraw.map(({ zone, area }) => {
              const outerPts = zone.points;
              const holes = [];
              for (const { zone: innerZone, area: innerArea } of zonesToDraw) {
                if (innerZone.id === zone.id) continue;
                if (innerArea >= area) continue;
                const innerPts = innerZone.points;
                if (!isZoneContainedIn(innerPts, outerPts)) continue;
                let isDirectChild = true;
                for (const {
                  zone: middleZone,
                  area: middleArea,
                } of zonesToDraw) {
                  if (middleZone.id === zone.id) continue;
                  if (middleZone.id === innerZone.id) continue;
                  if (middleArea >= area) continue;
                  if (middleArea <= innerArea) continue;
                  const middlePts = middleZone.points;
                  if (
                    isZoneContainedIn(innerPts, middlePts) &&
                    isZoneContainedIn(middlePts, outerPts)
                  ) {
                    isDirectChild = false;
                    break;
                  }
                }
                if (isDirectChild) {
                  holes.push(innerPts);
                }
              }
              return { zone, area, holes };
            });
            zonesWithHoles.forEach(({ zone, holes }) => {
              const colorKey = coloredZones.get(zone.id);
              const isCorrect = verificationResult?.get(zone.id);
              const isWrong = verificationResult && isCorrect === false;
              let fillColor = null;
              let strokeColor = null;
              if (colorKey) {
                const palette = COLOR_PALETTES[paletteId];
                const colorInfo = palette?.colors.find(
                  (c) => c.key === colorKey,
                );
                if (colorInfo) fillColor = colorInfo.color;
              }
              if (isWrong) {
                fillColor = "#FF0000";
                strokeColor = "#FF0000";
              }
              if (fillColor || strokeColor) {
                drawPolygonWithHoles(
                  ctx,
                  zone.points,
                  holes,
                  fillColor,
                  strokeColor,
                );
              }
            });
          }, [image, coloredZones, verificationResult, zones, paletteId]);
          const drawPolygonWithHoles = (
            ctx,
            points,
            holes,
            fillColor,
            strokeColor,
          ) => {
            if (!points || points.length === 0) return;
            ctx.beginPath();
            ctx.moveTo(points[0][0], points[0][1]);
            for (let i = 1; i < points.length; i++) {
              ctx.lineTo(points[i][0], points[i][1]);
            }
            ctx.closePath();
            for (const hole of holes) {
              if (hole.length === 0) continue;
              ctx.moveTo(hole[hole.length - 1][0], hole[hole.length - 1][1]);
              for (let i = hole.length - 2; i >= 0; i--) {
                ctx.lineTo(hole[i][0], hole[i][1]);
              }
              ctx.closePath();
            }
            if (fillColor) {
              const prevComposite = ctx.globalCompositeOperation;
              ctx.globalCompositeOperation = "multiply";
              ctx.fillStyle = fillColor;
              ctx.fill("evenodd");
              ctx.globalCompositeOperation = prevComposite;
            }
            if (strokeColor) {
              ctx.strokeStyle = strokeColor;
              ctx.lineWidth = 4;
              ctx.stroke();
            }
          };
          const isPointInPolygon = (x, y, points) => {
            let inside = false;
            for (let i = 0, j = points.length - 1; i < points.length; j = i++) {
              const xi = points[i][0],
                yi = points[i][1];
              const xj = points[j][0],
                yj = points[j][1];
              const intersect =
                yi > y !== yj > y &&
                x < ((xj - xi) * (y - yi)) / (yj - yi) + xi;
              if (intersect) inside = !inside;
            }
            return inside;
          };
          const getPolygonArea = (points) => {
            let area = 0;
            const n = points.length;
            for (let i = 0; i < n; i++) {
              const j = (i + 1) % n;
              area += points[i][0] * points[j][1];
              area -= points[j][0] * points[i][1];
            }
            return Math.abs(area / 2);
          };
          const findSmallestZoneAtPoint = (x, y) => {
            let smallestZone = null;
            for (const zone of zones) {
              const points = zone.points;
              if (points && isPointInPolygon(x, y, points)) {
                const area = getPolygonArea(points);
                if (!smallestZone || area < smallestZone.area) {
                  smallestZone = { id: zone.id, area };
                }
              }
            }
            return smallestZone ? smallestZone.id : null;
          };
          const handleCanvasClick = (e) => {
            if (!canvasRef.current || !image) return;
            const rect = canvasRef.current.getBoundingClientRect();
            const scaleX = image.width / rect.width;
            const scaleY = image.height / rect.height;
            const x = (e.clientX - rect.left) * scaleX;
            const y = (e.clientY - rect.top) * scaleY;
            const zoneId = findSmallestZoneAtPoint(x, y);
            if (zoneId) {
              onZoneClick(zoneId);
            }
          };
          const handleDragOver = (e) => {
            e.preventDefault();
            e.dataTransfer.dropEffect = "copy";
          };
          const handleDrop = (e) => {
            e.preventDefault();
            const colorKey = e.dataTransfer.getData("text/plain");
            processDrop(e.clientX, e.clientY, colorKey);
          };
          const processDrop = (clientX, clientY, colorKey) => {
            if (!colorKey || !canvasRef.current || !image) return;
            const rect = canvasRef.current.getBoundingClientRect();
            if (
              clientX < rect.left ||
              clientX > rect.right ||
              clientY < rect.top ||
              clientY > rect.bottom
            ) {
              return;
            }
            const scaleX = image.width / rect.width;
            const scaleY = image.height / rect.height;
            const x = (clientX - rect.left) * scaleX;
            const y = (clientY - rect.top) * scaleY;
            const zoneId = findSmallestZoneAtPoint(x, y);
            if (zoneId && onZoneDrop) {
              onZoneDrop(zoneId, colorKey);
            }
          };
          reactExports.useImperativeHandle(ref, () => ({
            handleExternalDrop: (x, y, colorKey) => {
              processDrop(x, y, colorKey);
            },
          }));
          const hasPoints = zones.some((z) => z.points && z.points.length > 0);
          if (!imagePath || !hasPoints) {
            return /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
              className:
                "flex-1 flex items-center justify-center p-10 text-muted-foreground",
              children: imagePath
                ? "Loading image..."
                : "No image or zones defined.",
            });
          }
          return /* @__PURE__ */ jsxRuntimeExports.jsx("section", {
            className: "flex-1 flex flex-col p-5 overflow-hidden",
            children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", {
              ref: containerRef,
              className:
                "flex-1 flex items-center justify-center bg-muted/50 border-2 border-primary/20 shadow-lg overflow-hidden relative rounded-xl",
              onDragOver: handleDragOver,
              onDrop: handleDrop,
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
                  className:
                    "absolute top-0 left-0 w-8 h-8 border-t-4 border-l-4 border-primary/40 rounded-tl-xl",
                }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
                  className:
                    "absolute top-0 right-0 w-8 h-8 border-t-4 border-r-4 border-primary/40 rounded-tr-xl",
                }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
                  className:
                    "absolute bottom-0 left-0 w-8 h-8 border-b-4 border-l-4 border-primary/40 rounded-bl-xl",
                }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
                  className:
                    "absolute bottom-0 right-0 w-8 h-8 border-b-4 border-r-4 border-primary/40 rounded-br-xl",
                }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("canvas", {
                  ref: canvasRef,
                  onClick: handleCanvasClick,
                  className:
                    "max-w-full max-h-full object-contain cursor-crosshair",
                  style: { width: "auto", height: "auto" },
                }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
                  className:
                    "absolute inset-0 pointer-events-none opacity-10 scanlines",
                }),
              ],
            }),
          });
        },
      );

      function ProgressBar({ current, total }) {
        const percentage = total > 0 ? (current / total) * 100 : 0;
        return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", {
          className: "mx-5 mb-4",
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", {
              className: "flex items-center justify-between mb-1",
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
                  className:
                    "text-xs text-primary/60 font-mono-chem uppercase tracking-wider",
                  children: "Прогресс синтеза",
                }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("span", {
                  className: "text-xs text-primary font-mono-chem font-bold",
                  children: [Math.round(percentage), "%"],
                }),
              ],
            }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", {
              className:
                "h-6 bg-muted border border-primary/30 overflow-hidden relative",
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(motion.div, {
                  className: "h-full gradient-bg-toxic",
                  initial: { width: 0 },
                  animate: { width: `${percentage}%` },
                  transition: { duration: 0.3, ease: "easeOut" },
                }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
                  className:
                    "absolute inset-0 flex items-center justify-center",
                  children: /* @__PURE__ */ jsxRuntimeExports.jsxs("span", {
                    className:
                      "font-bold text-sm font-mono-chem text-foreground drop-shadow-lg",
                    children: [current, " / ", total],
                  }),
                }),
                percentage > 0 &&
                  percentage < 100 &&
                  /* @__PURE__ */ jsxRuntimeExports.jsx(motion.div, {
                    className:
                      "absolute top-0 bottom-0 w-8 bg-gradient-to-r from-transparent via-white/20 to-transparent",
                    animate: { x: [-32, 500] },
                    transition: {
                      duration: 2,
                      repeat: Infinity,
                      ease: "linear",
                    },
                  }),
              ],
            }),
          ],
        });
      }

      function FeedbackOverlay({ isVisible, isSuccess, message, onClose }) {
        return /* @__PURE__ */ jsxRuntimeExports.jsx(AnimatePresence, {
          children:
            isVisible &&
            /* @__PURE__ */ jsxRuntimeExports.jsx(motion.div, {
              initial: { opacity: 0 },
              animate: { opacity: 1 },
              exit: { opacity: 0 },
              onClick: onClose,
              className:
                "fixed inset-0 flex items-center justify-center bg-black/80 backdrop-blur-sm z-50 cursor-pointer",
              children: /* @__PURE__ */ jsxRuntimeExports.jsxs(motion.div, {
                initial: { scale: 0.8, opacity: 0 },
                animate: { scale: 1, opacity: 1 },
                exit: { scale: 0.8, opacity: 0 },
                transition: { type: "spring", damping: 20 },
                className: "relative",
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
                    className: "absolute -inset-2 hazard-stripes opacity-80",
                  }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", {
                    className: cn(
                      "relative px-16 py-10 text-center shadow-2xl border-4",
                      isSuccess
                        ? "bg-gradient-to-br from-green-900 to-green-950 border-success"
                        : "bg-gradient-to-br from-red-900 to-red-950 border-destructive",
                    ),
                    children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
                        className: "text-6xl mb-4",
                        children: isSuccess ? "☢️" : "💀",
                      }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
                        className:
                          "text-3xl font-bold uppercase tracking-wider font-oswald text-foreground",
                        children: isSuccess
                          ? "СИНТЕЗ ЗАВЕРШЁН"
                          : "ОШИБКА СИНТЕЗА",
                      }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
                        className:
                          "mt-2 text-lg text-muted-foreground font-mono-chem",
                        children: message,
                      }),
                      isSuccess &&
                        /* @__PURE__ */ jsxRuntimeExports.jsx(motion.div, {
                          className: "mt-4 text-sm text-accent font-mono-chem",
                          initial: { opacity: 0 },
                          animate: { opacity: 1 },
                          transition: { delay: 0.5 },
                          children: "99.1% ЧИСТОТА",
                        }),
                    ],
                  }),
                ],
              }),
            }),
        });
      }

      function BubblesBackground() {
        const [particles, setParticles] = reactExports.useState([]);
        reactExports.useEffect(() => {
          const newParticles = [
            // Toxic bubbles
            ...Array.from({ length: 8 }, (_, i) => ({
              id: i,
              size: Math.random() * 30 + 10,
              x: Math.random() * 100,
              delay: Math.random() * 10,
              duration: Math.random() * 15 + 20,
              type: "bubble",
            })),
            // Smoke particles
            ...Array.from({ length: 6 }, (_, i) => ({
              id: i + 10,
              size: Math.random() * 100 + 50,
              x: Math.random() * 100,
              delay: Math.random() * 5,
              duration: Math.random() * 20 + 25,
              type: "smoke",
            })),
          ];
          setParticles(newParticles);
        }, []);
        return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", {
          className: "fixed inset-0 pointer-events-none overflow-hidden z-0",
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
              className:
                "absolute inset-0 bg-gradient-to-t from-black/50 via-transparent to-transparent",
            }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
              className:
                "absolute top-0 left-1/4 w-96 h-96 bg-accent/5 rounded-full blur-3xl animate-toxic",
            }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
              className:
                "absolute bottom-0 right-1/4 w-80 h-80 bg-primary/5 rounded-full blur-3xl animate-toxic",
              style: { animationDelay: "1.5s" },
            }),
            particles.map((particle) =>
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                motion.div,
                {
                  className:
                    particle.type === "bubble"
                      ? "absolute rounded-full"
                      : "absolute rounded-full blur-xl",
                  style: {
                    width: particle.size,
                    height: particle.size,
                    left: `${particle.x}%`,
                    bottom: particle.type === "bubble" ? -particle.size : "10%",
                    background:
                      particle.type === "bubble"
                        ? `radial-gradient(circle at 30% 30%, hsla(120, 60%, 40%, 0.3), hsla(120, 60%, 30%, 0.1))`
                        : `radial-gradient(circle, hsla(55, 100%, 50%, 0.05), transparent)`,
                    border:
                      particle.type === "bubble"
                        ? "1px solid hsla(120, 60%, 40%, 0.2)"
                        : "none",
                  },
                  animate:
                    particle.type === "bubble"
                      ? {
                          y: [
                            0,
                            -(typeof window !== "undefined"
                              ? window.innerHeight
                              : 1e3) -
                              particle.size * 2,
                          ],
                          opacity: [0.3, 0.6, 0.4, 0],
                          scale: [1, 1.2, 1, 0.8],
                        }
                      : {
                          y: [0, -200],
                          x: [0, Math.random() * 100 - 50],
                          opacity: [0, 0.3, 0],
                          scale: [1, 1.5, 2],
                        },
                  transition: {
                    duration: particle.duration,
                    delay: particle.delay,
                    repeat: Infinity,
                    ease: "linear",
                  },
                },
                particle.id,
              ),
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
              className: "absolute bottom-10 left-10 opacity-10",
              children: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", {
                width: "80",
                height: "100",
                viewBox: "0 0 80 100",
                fill: "none",
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("path", {
                    d: "M25 10 L25 35 L5 85 C2 92 8 98 40 98 C72 98 78 92 75 85 L55 35 L55 10 Z",
                    stroke: "hsl(55, 100%, 50%)",
                    strokeWidth: "2",
                    fill: "none",
                  }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("path", {
                    d: "M12 70 Q40 65 68 70 L75 85 C78 92 72 98 40 98 C8 98 2 92 5 85 Z",
                    fill: "hsla(120, 60%, 30%, 0.3)",
                  }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("circle", {
                    cx: "25",
                    cy: "80",
                    r: "3",
                    fill: "hsla(120, 60%, 40%, 0.5)",
                  }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("circle", {
                    cx: "45",
                    cy: "75",
                    r: "2",
                    fill: "hsla(120, 60%, 40%, 0.5)",
                  }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("circle", {
                    cx: "55",
                    cy: "82",
                    r: "4",
                    fill: "hsla(120, 60%, 40%, 0.5)",
                  }),
                ],
              }),
            }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
              className: "absolute bottom-10 right-10 opacity-10",
              children: /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", {
                width: "60",
                height: "90",
                viewBox: "0 0 60 90",
                fill: "none",
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("rect", {
                    x: "5",
                    y: "10",
                    width: "50",
                    height: "70",
                    rx: "3",
                    stroke: "hsl(55, 100%, 50%)",
                    strokeWidth: "2",
                    fill: "none",
                  }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("path", {
                    d: "M5 30 L15 30",
                    stroke: "hsl(55, 100%, 50%)",
                    strokeWidth: "1",
                  }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("path", {
                    d: "M5 50 L15 50",
                    stroke: "hsl(55, 100%, 50%)",
                    strokeWidth: "1",
                  }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("path", {
                    d: "M5 70 L15 70",
                    stroke: "hsl(55, 100%, 50%)",
                    strokeWidth: "1",
                  }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("rect", {
                    x: "6",
                    y: "50",
                    width: "48",
                    height: "29",
                    fill: "hsla(55, 100%, 50%, 0.2)",
                  }),
                ],
              }),
            }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", {
              className:
                "absolute top-20 right-20 opacity-10 border-2 border-primary p-2 text-center",
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
                  className: "text-2xl font-bold text-primary",
                  children: "Br",
                }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
                  className: "text-xs text-primary/60",
                  children: "35",
                }),
              ],
            }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", {
              className:
                "absolute top-40 left-20 opacity-10 border-2 border-accent p-2 text-center",
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
                  className: "text-2xl font-bold text-accent",
                  children: "P",
                }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
                  className: "text-xs text-accent/60",
                  children: "15",
                }),
              ],
            }),
          ],
        });
      }

      const BB_TITLES = {
        bells: "Метиламин",
        tree: "Кристаллы",
        sock: "Лаборатория",
        wreath: "Синтез",
        candle: "Голубой мет",
      };
      const Index = () => {
        const [pages] = reactExports.useState(getAllPages());
        const coloringAreaRef = reactExports.useRef(null);
        const [currentPageIndex, setCurrentPageIndex] =
          reactExports.useState(0);
        const [selectedColor, setSelectedColor] = reactExports.useState(null);
        const [coloredZones, setColoredZones] = reactExports.useState(
          /* @__PURE__ */ new Map(),
        );
        const [verificationResult, setVerificationResult] =
          reactExports.useState(null);
        const [feedback, setFeedback] = reactExports.useState({
          visible: false,
          success: false,
          message: "",
        });
        const currentPage = pages[currentPageIndex] || pages[0];
        const palette =
          COLOR_PALETTES[currentPage.palette] || COLOR_PALETTES.saltEnvironment;
        const availableColors = reactExports.useMemo(
          () => getAvailableColors(currentPage),
          [currentPage],
        );
        const bbTitle = BB_TITLES[currentPage.id] || currentPage.title;
        const handlePrev = reactExports.useCallback(() => {
          if (currentPageIndex > 0) {
            setCurrentPageIndex((prev) => prev - 1);
            resetState();
          }
        }, [currentPageIndex]);
        const handleNext = reactExports.useCallback(() => {
          if (currentPageIndex < pages.length - 1) {
            setCurrentPageIndex((prev) => prev + 1);
            resetState();
          }
        }, [currentPageIndex, pages.length]);
        const resetState = reactExports.useCallback(() => {
          setSelectedColor(null);
          setColoredZones(/* @__PURE__ */ new Map());
          setVerificationResult(null);
          setFeedback({ visible: false, success: false, message: "" });
        }, []);
        const handleSelectColor = reactExports.useCallback((colorKey) => {
          setSelectedColor(colorKey);
        }, []);
        const handleZoneClick = reactExports.useCallback(
          (zoneId, colorOverride) => {
            const colorToApply = colorOverride || selectedColor;
            if (!colorToApply) return;
            if (colorOverride) {
              setSelectedColor(colorOverride);
            }
            setColoredZones((prev) => {
              const newMap = new Map(prev);
              newMap.set(zoneId, colorToApply);
              return newMap;
            });
            setVerificationResult(null);
          },
          [selectedColor],
        );
        const handleGlobalDrop = reactExports.useCallback((x, y, colorKey) => {
          if (coloringAreaRef.current) {
            coloringAreaRef.current.handleExternalDrop(x, y, colorKey);
          }
        }, []);
        const handleCheck = reactExports.useCallback(() => {
          const results = /* @__PURE__ */ new Map();
          let allCorrect = true;
          currentPage.zones.forEach((zone) => {
            const appliedColor = coloredZones.get(zone.id);
            const isCorrect = appliedColor === zone.correctColor;
            results.set(zone.id, isCorrect);
            if (!isCorrect) allCorrect = false;
          });
          setVerificationResult(results);
          setFeedback({
            visible: true,
            success: allCorrect,
            message: allCorrect
              ? "Чистота 99.1% достигнута!"
              : "Формула неверна. Повтори синтез!",
          });
          setTimeout(() => {
            setFeedback((prev) => ({ ...prev, visible: false }));
          }, 2500);
        }, [currentPage, coloredZones]);
        const handleReset = reactExports.useCallback(() => {
          resetState();
        }, [resetState]);
        const closeFeedback = reactExports.useCallback(() => {
          setFeedback((prev) => ({ ...prev, visible: false }));
        }, []);
        const isAllColored = coloredZones.size === currentPage.zones.length;
        const coloredCount = coloredZones.size;
        return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", {
          className: "h-full flex flex-col relative overflow-hidden",
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(BubblesBackground, {}),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(motion.div, {
              className: "h-full flex flex-col relative z-10",
              initial: { opacity: 0 },
              animate: { opacity: 1 },
              transition: { duration: 0.5 },
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Header, {
                  title: bbTitle,
                  instruction: currentPage.instruction,
                  onPrev: handlePrev,
                  onNext: handleNext,
                  canGoPrev: currentPageIndex > 0,
                  canGoNext: currentPageIndex < pages.length - 1,
                  currentPage: currentPageIndex + 1,
                  totalPages: pages.length,
                }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("main", {
                  className: "flex-1 flex overflow-hidden",
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(ColorPalette, {
                      colors: palette.colors,
                      selectedColor,
                      onSelectColor: handleSelectColor,
                      availableColors,
                      onGlobalDrop: handleGlobalDrop,
                    }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", {
                      className: "flex-1 flex flex-col overflow-hidden",
                      children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsx(ColoringArea, {
                          ref: coloringAreaRef,
                          zones: currentPage.zones,
                          coloredZones,
                          selectedColor,
                          paletteId: currentPage.palette,
                          verificationResult,
                          onZoneClick: (id) => handleZoneClick(id),
                          onZoneDrop: (id, color) => handleZoneClick(id, color),
                          imagePath: currentPage.image,
                        }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx(ProgressBar, {
                          current: coloredCount,
                          total: currentPage.zones.length,
                        }),
                      ],
                    }),
                  ],
                }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(Footer, {
                  onCheck: handleCheck,
                  onReset: handleReset,
                  isAllColored,
                }),
              ],
            }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(FeedbackOverlay, {
              isVisible: feedback.visible,
              isSuccess: feedback.success,
              message: feedback.message,
              onClose: closeFeedback,
            }),
          ],
        });
      };

      const NotFound = () => {
        const location = useLocation();
        reactExports.useEffect(() => {
          console.error(
            "404 Error: User attempted to access non-existent route:",
            location.pathname,
          );
        }, [location.pathname]);
        return /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
          className: "flex min-h-screen items-center justify-center bg-muted",
          children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", {
            className: "text-center",
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("h1", {
                className: "mb-4 text-4xl font-bold",
                children: "404",
              }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", {
                className: "mb-4 text-xl text-muted-foreground",
                children: "Oops! Page not found",
              }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("a", {
                href: "/",
                className: "text-primary underline hover:text-primary/90",
                children: "Return to Home",
              }),
            ],
          }),
        });
      };

      const queryClient = new QueryClient();
      const App = () =>
        /* @__PURE__ */ jsxRuntimeExports.jsx(QueryClientProvider, {
          client: queryClient,
          children: /* @__PURE__ */ jsxRuntimeExports.jsxs(TooltipProvider, {
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Toaster$1, {}),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Toaster, {}),
              /* @__PURE__ */ jsxRuntimeExports.jsx(HashRouter, {
                children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Routes, {
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(Route, {
                      path: "/",
                      element: /* @__PURE__ */ jsxRuntimeExports.jsx(Index, {}),
                    }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(Route, {
                      path: "*",
                      element: /* @__PURE__ */ jsxRuntimeExports.jsx(
                        NotFound,
                        {},
                      ),
                    }),
                  ],
                }),
              }),
            ],
          }),
        });

      createRoot(document.getElementById("root")).render(
        /* @__PURE__ */ jsxRuntimeExports.jsx(App, {}),
      );
    </script>
    <style rel="stylesheet" crossorigin>
      @import url("https://fonts.googleapis.com/css2?family=Oswald:wght@400;500;600;700&family=Roboto+Mono:wght@400;500;700&display=swap");

      *,
      ::before,
      ::after {
        --tw-border-spacing-x: 0;
        --tw-border-spacing-y: 0;
        --tw-translate-x: 0;
        --tw-translate-y: 0;
        --tw-rotate: 0;
        --tw-skew-x: 0;
        --tw-skew-y: 0;
        --tw-scale-x: 1;
        --tw-scale-y: 1;
        --tw-pan-x:  ;
        --tw-pan-y:  ;
        --tw-pinch-zoom:  ;
        --tw-scroll-snap-strictness: proximity;
        --tw-gradient-from-position:  ;
        --tw-gradient-via-position:  ;
        --tw-gradient-to-position:  ;
        --tw-ordinal:  ;
        --tw-slashed-zero:  ;
        --tw-numeric-figure:  ;
        --tw-numeric-spacing:  ;
        --tw-numeric-fraction:  ;
        --tw-ring-inset:  ;
        --tw-ring-offset-width: 0px;
        --tw-ring-offset-color: #fff;
        --tw-ring-color: rgb(59 130 246 / 0.5);
        --tw-ring-offset-shadow: 0 0 #0000;
        --tw-ring-shadow: 0 0 #0000;
        --tw-shadow: 0 0 #0000;
        --tw-shadow-colored: 0 0 #0000;
        --tw-blur:  ;
        --tw-brightness:  ;
        --tw-contrast:  ;
        --tw-grayscale:  ;
        --tw-hue-rotate:  ;
        --tw-invert:  ;
        --tw-saturate:  ;
        --tw-sepia:  ;
        --tw-drop-shadow:  ;
        --tw-backdrop-blur:  ;
        --tw-backdrop-brightness:  ;
        --tw-backdrop-contrast:  ;
        --tw-backdrop-grayscale:  ;
        --tw-backdrop-hue-rotate:  ;
        --tw-backdrop-invert:  ;
        --tw-backdrop-opacity:  ;
        --tw-backdrop-saturate:  ;
        --tw-backdrop-sepia:  ;
        --tw-contain-size:  ;
        --tw-contain-layout:  ;
        --tw-contain-paint:  ;
        --tw-contain-style:  ;
      }

      ::backdrop {
        --tw-border-spacing-x: 0;
        --tw-border-spacing-y: 0;
        --tw-translate-x: 0;
        --tw-translate-y: 0;
        --tw-rotate: 0;
        --tw-skew-x: 0;
        --tw-skew-y: 0;
        --tw-scale-x: 1;
        --tw-scale-y: 1;
        --tw-pan-x:  ;
        --tw-pan-y:  ;
        --tw-pinch-zoom:  ;
        --tw-scroll-snap-strictness: proximity;
        --tw-gradient-from-position:  ;
        --tw-gradient-via-position:  ;
        --tw-gradient-to-position:  ;
        --tw-ordinal:  ;
        --tw-slashed-zero:  ;
        --tw-numeric-figure:  ;
        --tw-numeric-spacing:  ;
        --tw-numeric-fraction:  ;
        --tw-ring-inset:  ;
        --tw-ring-offset-width: 0px;
        --tw-ring-offset-color: #fff;
        --tw-ring-color: rgb(59 130 246 / 0.5);
        --tw-ring-offset-shadow: 0 0 #0000;
        --tw-ring-shadow: 0 0 #0000;
        --tw-shadow: 0 0 #0000;
        --tw-shadow-colored: 0 0 #0000;
        --tw-blur:  ;
        --tw-brightness:  ;
        --tw-contrast:  ;
        --tw-grayscale:  ;
        --tw-hue-rotate:  ;
        --tw-invert:  ;
        --tw-saturate:  ;
        --tw-sepia:  ;
        --tw-drop-shadow:  ;
        --tw-backdrop-blur:  ;
        --tw-backdrop-brightness:  ;
        --tw-backdrop-contrast:  ;
        --tw-backdrop-grayscale:  ;
        --tw-backdrop-hue-rotate:  ;
        --tw-backdrop-invert:  ;
        --tw-backdrop-opacity:  ;
        --tw-backdrop-saturate:  ;
        --tw-backdrop-sepia:  ;
        --tw-contain-size:  ;
        --tw-contain-layout:  ;
        --tw-contain-paint:  ;
        --tw-contain-style:  ;
      }

      /*
! tailwindcss v3.4.17 | MIT License | https://tailwindcss.com
*/

      /*
1. Prevent padding and border from affecting element width. (https://github.com/mozdevs/cssremedy/issues/4)
2. Allow adding a border to an element by just adding a border-width. (https://github.com/tailwindcss/tailwindcss/pull/116)
*/

      *,
      ::before,
      ::after {
        box-sizing: border-box; /* 1 */
        border-width: 0; /* 2 */
        border-style: solid; /* 2 */
        border-color: #e5e7eb; /* 2 */
      }

      ::before,
      ::after {
        --tw-content: "";
      }

      /*
1. Use a consistent sensible line-height in all browsers.
2. Prevent adjustments of font size after orientation changes in iOS.
3. Use a more readable tab size.
4. Use the user's configured `sans` font-family by default.
5. Use the user's configured `sans` font-feature-settings by default.
6. Use the user's configured `sans` font-variation-settings by default.
7. Disable tap highlights on iOS
*/

      html,
      :host {
        line-height: 1.5; /* 1 */
        -webkit-text-size-adjust: 100%; /* 2 */
        -moz-tab-size: 4; /* 3 */
        -o-tab-size: 4;
        tab-size: 4; /* 3 */
        font-family:
          ui-sans-serif, system-ui, sans-serif, "Apple Color Emoji",
          "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji"; /* 4 */
        font-feature-settings: normal; /* 5 */
        font-variation-settings: normal; /* 6 */
        -webkit-tap-highlight-color: transparent; /* 7 */
      }

      /*
1. Remove the margin in all browsers.
2. Inherit line-height from `html` so users can set them as a class directly on the `html` element.
*/

      body {
        margin: 0; /* 1 */
        line-height: inherit; /* 2 */
      }

      /*
1. Add the correct height in Firefox.
2. Correct the inheritance of border color in Firefox. (https://bugzilla.mozilla.org/show_bug.cgi?id=190655)
3. Ensure horizontal rules are visible by default.
*/

      hr {
        height: 0; /* 1 */
        color: inherit; /* 2 */
        border-top-width: 1px; /* 3 */
      }

      /*
Add the correct text decoration in Chrome, Edge, and Safari.
*/

      abbr:where([title]) {
        -webkit-text-decoration: underline dotted;
        text-decoration: underline dotted;
      }

      /*
Remove the default font size and weight for headings.
*/

      h1,
      h2,
      h3,
      h4,
      h5,
      h6 {
        font-size: inherit;
        font-weight: inherit;
      }

      /*
Reset links to optimize for opt-in styling instead of opt-out.
*/

      a {
        color: inherit;
        text-decoration: inherit;
      }

      /*
Add the correct font weight in Edge and Safari.
*/

      b,
      strong {
        font-weight: bolder;
      }

      /*
1. Use the user's configured `mono` font-family by default.
2. Use the user's configured `mono` font-feature-settings by default.
3. Use the user's configured `mono` font-variation-settings by default.
4. Correct the odd `em` font sizing in all browsers.
*/

      code,
      kbd,
      samp,
      pre {
        font-family:
          Roboto Mono,
          monospace; /* 1 */
        font-feature-settings: normal; /* 2 */
        font-variation-settings: normal; /* 3 */
        font-size: 1em; /* 4 */
      }

      /*
Add the correct font size in all browsers.
*/

      small {
        font-size: 80%;
      }

      /*
Prevent `sub` and `sup` elements from affecting the line height in all browsers.
*/

      sub,
      sup {
        font-size: 75%;
        line-height: 0;
        position: relative;
        vertical-align: baseline;
      }

      sub {
        bottom: -0.25em;
      }

      sup {
        top: -0.5em;
      }

      /*
1. Remove text indentation from table contents in Chrome and Safari. (https://bugs.chromium.org/p/chromium/issues/detail?id=999088, https://bugs.webkit.org/show_bug.cgi?id=201297)
2. Correct table border color inheritance in all Chrome and Safari. (https://bugs.chromium.org/p/chromium/issues/detail?id=935729, https://bugs.webkit.org/show_bug.cgi?id=195016)
3. Remove gaps between table borders by default.
*/

      table {
        text-indent: 0; /* 1 */
        border-color: inherit; /* 2 */
        border-collapse: collapse; /* 3 */
      }

      /*
1. Change the font styles in all browsers.
2. Remove the margin in Firefox and Safari.
3. Remove default padding in all browsers.
*/

      button,
      input,
      optgroup,
      select,
      textarea {
        font-family: inherit; /* 1 */
        font-feature-settings: inherit; /* 1 */
        font-variation-settings: inherit; /* 1 */
        font-size: 100%; /* 1 */
        font-weight: inherit; /* 1 */
        line-height: inherit; /* 1 */
        letter-spacing: inherit; /* 1 */
        color: inherit; /* 1 */
        margin: 0; /* 2 */
        padding: 0; /* 3 */
      }

      /*
Remove the inheritance of text transform in Edge and Firefox.
*/

      button,
      select {
        text-transform: none;
      }

      /*
1. Correct the inability to style clickable types in iOS and Safari.
2. Remove default button styles.
*/

      button,
      input:where([type="button"]),
      input:where([type="reset"]),
      input:where([type="submit"]) {
        -webkit-appearance: button; /* 1 */
        background-color: transparent; /* 2 */
        background-image: none; /* 2 */
      }

      /*
Use the modern Firefox focus style for all focusable elements.
*/

      :-moz-focusring {
        outline: auto;
      }

      /*
Remove the additional `:invalid` styles in Firefox. (https://github.com/mozilla/gecko-dev/blob/2f9eacd9d3d995c937b4251a5557d95d494c9be1/layout/style/res/forms.css#L728-L737)
*/

      :-moz-ui-invalid {
        box-shadow: none;
      }

      /*
Add the correct vertical alignment in Chrome and Firefox.
*/

      progress {
        vertical-align: baseline;
      }

      /*
Correct the cursor style of increment and decrement buttons in Safari.
*/

      ::-webkit-inner-spin-button,
      ::-webkit-outer-spin-button {
        height: auto;
      }

      /*
1. Correct the odd appearance in Chrome and Safari.
2. Correct the outline style in Safari.
*/

      [type="search"] {
        -webkit-appearance: textfield; /* 1 */
        outline-offset: -2px; /* 2 */
      }

      /*
Remove the inner padding in Chrome and Safari on macOS.
*/

      ::-webkit-search-decoration {
        -webkit-appearance: none;
      }

      /*
1. Correct the inability to style clickable types in iOS and Safari.
2. Change font properties to `inherit` in Safari.
*/

      ::-webkit-file-upload-button {
        -webkit-appearance: button; /* 1 */
        font: inherit; /* 2 */
      }

      /*
Add the correct display in Chrome and Safari.
*/

      summary {
        display: list-item;
      }

      /*
Removes the default spacing and border for appropriate elements.
*/

      blockquote,
      dl,
      dd,
      h1,
      h2,
      h3,
      h4,
      h5,
      h6,
      hr,
      figure,
      p,
      pre {
        margin: 0;
      }

      fieldset {
        margin: 0;
        padding: 0;
      }

      legend {
        padding: 0;
      }

      ol,
      ul,
      menu {
        list-style: none;
        margin: 0;
        padding: 0;
      }

      /*
Reset default styling for dialogs.
*/

      dialog {
        padding: 0;
      }

      /*
Prevent resizing textareas horizontally by default.
*/

      textarea {
        resize: vertical;
      }

      /*
1. Reset the default placeholder opacity in Firefox. (https://github.com/tailwindlabs/tailwindcss/issues/3300)
2. Set the default placeholder color to the user's configured gray 400 color.
*/

      input::-moz-placeholder,
      textarea::-moz-placeholder {
        opacity: 1; /* 1 */
        color: #9ca3af; /* 2 */
      }

      input::placeholder,
      textarea::placeholder {
        opacity: 1; /* 1 */
        color: #9ca3af; /* 2 */
      }

      /*
Set the default cursor for buttons.
*/

      button,
      [role="button"] {
        cursor: pointer;
      }

      /*
Make sure disabled buttons don't get the pointer cursor.
*/

      :disabled {
        cursor: default;
      }

      /*
1. Make replaced elements `display: block` by default. (https://github.com/mozdevs/cssremedy/issues/14)
2. Add `vertical-align: middle` to align replaced elements more sensibly by default. (https://github.com/jensimmons/cssremedy/issues/14#issuecomment-634934210)
   This can trigger a poorly considered lint error in some tools but is included by design.
*/

      img,
      svg,
      video,
      canvas,
      audio,
      iframe,
      embed,
      object {
        display: block; /* 1 */
        vertical-align: middle; /* 2 */
      }

      /*
Constrain images and videos to the parent width and preserve their intrinsic aspect ratio. (https://github.com/mozdevs/cssremedy/issues/14)
*/

      img,
      video {
        max-width: 100%;
        height: auto;
      }

      /* Make elements with the HTML hidden attribute stay hidden by default */

      [hidden]:where(:not([hidden="until-found"])) {
        display: none;
      }

      :root {
        /* Breaking Bad dark industrial theme */
        --background: 80 10% 5%;
        --foreground: 55 100% 50%;

        --card: 80 15% 8%;
        --card-foreground: 55 90% 60%;

        --popover: 80 15% 8%;
        --popover-foreground: 55 90% 60%;

        /* Hazmat yellow - iconic BB color */
        --primary: 55 100% 50%;
        --primary-foreground: 80 10% 5%;

        --secondary: 120 60% 25%;
        --secondary-foreground: 55 100% 50%;

        --muted: 80 10% 15%;
        --muted-foreground: 55 30% 50%;

        --accent: 120 70% 35%;
        --accent-foreground: 55 100% 50%;

        --destructive: 0 70% 50%;
        --destructive-foreground: 0 0% 100%;

        --success: 120 60% 40%;
        --success-foreground: 0 0% 100%;

        --warning: 55 100% 50%;
        --warning-foreground: 80 10% 5%;

        --border: 55 30% 20%;
        --input: 80 10% 15%;
        --ring: 55 100% 50%;

        --radius: 0.25rem;

        /* Breaking Bad specific */
        --bb-yellow: 55 100% 50%;
        --bb-green: 120 60% 30%;
        --bb-dark: 80 10% 5%;
        --bb-toxic: 90 100% 40%;
        --bb-hazard: 45 100% 50%;

        /* Gradients */
        --gradient-primary: linear-gradient(
          135deg,
          hsl(55 100% 50%) 0%,
          hsl(45 100% 40%) 100%
        );
        --gradient-success: linear-gradient(
          135deg,
          hsl(120 60% 30%) 0%,
          hsl(120 70% 40%) 100%
        );
        --gradient-error: linear-gradient(
          135deg,
          hsl(0 70% 50%) 0%,
          hsl(0 70% 60%) 100%
        );
        --gradient-toxic: linear-gradient(
          135deg,
          hsl(90 100% 35%) 0%,
          hsl(120 60% 30%) 100%
        );

        /* Shadows */
        --shadow-sm: 0 2px 8px rgba(0, 0, 0, 0.5);
        --shadow-md: 0 4px 16px rgba(0, 0, 0, 0.6);
        --shadow-lg: 0 8px 32px rgba(0, 0, 0, 0.7);
        --shadow-glow: 0 0 20px hsla(55, 100%, 50%, 0.4);
        --shadow-toxic: 0 0 30px hsla(120, 60%, 30%, 0.5);

        --sidebar-background: 80 15% 8%;
        --sidebar-foreground: 55 90% 60%;
        --sidebar-primary: 55 100% 50%;
        --sidebar-primary-foreground: 80 10% 5%;
        --sidebar-accent: 120 60% 25%;
        --sidebar-accent-foreground: 55 100% 50%;
        --sidebar-border: 55 30% 20%;
        --sidebar-ring: 55 100% 50%;
      }

      .dark {
        --background: 80 10% 5%;
        --foreground: 55 100% 50%;
        --card: 80 15% 8%;
        --card-foreground: 55 90% 60%;
        --popover: 80 15% 8%;
        --popover-foreground: 55 90% 60%;
        --primary: 55 100% 50%;
        --primary-foreground: 80 10% 5%;
        --secondary: 120 60% 25%;
        --secondary-foreground: 55 100% 50%;
        --muted: 80 10% 15%;
        --muted-foreground: 55 30% 50%;
        --accent: 120 70% 35%;
        --accent-foreground: 55 100% 50%;
        --destructive: 0 70% 50%;
        --destructive-foreground: 0 0% 100%;
        --border: 55 30% 20%;
        --input: 80 10% 15%;
        --ring: 55 100% 50%;
        --sidebar-background: 80 15% 8%;
        --sidebar-foreground: 55 90% 60%;
        --sidebar-primary: 55 100% 50%;
        --sidebar-primary-foreground: 80 10% 5%;
        --sidebar-accent: 120 60% 25%;
        --sidebar-accent-foreground: 55 100% 50%;
        --sidebar-border: 55 30% 20%;
        --sidebar-ring: 55 100% 50%;
      }

      * {
        border-color: hsl(var(--border));
      }

      html,
      body,
      #root {
        height: 100%;
        overflow: hidden;
      }

      body {
        background-color: hsl(var(--background));
        color: hsl(var(--foreground));
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
        font-family: "Oswald", sans-serif;
        background:
          radial-gradient(
            ellipse at top,
            hsla(120, 60%, 20%, 0.15) 0%,
            transparent 50%
          ),
          linear-gradient(
            180deg,
            hsl(var(--background)) 0%,
            hsl(80 15% 3%) 100%
          );
      }

      .container {
        width: 100%;
        margin-right: auto;
        margin-left: auto;
        padding-right: 2rem;
        padding-left: 2rem;
      }

      @media (min-width: 1400px) {
        .container {
          max-width: 1400px;
        }
      }

      .sr-only {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        white-space: nowrap;
        border-width: 0;
      }

      .pointer-events-none {
        pointer-events: none;
      }

      .pointer-events-auto {
        pointer-events: auto;
      }

      .visible {
        visibility: visible;
      }

      .invisible {
        visibility: hidden;
      }

      .fixed {
        position: fixed;
      }

      .absolute {
        position: absolute;
      }

      .relative {
        position: relative;
      }

      .-inset-2 {
        inset: -0.5rem;
      }

      .inset-0 {
        inset: 0px;
      }

      .inset-x-0 {
        left: 0px;
        right: 0px;
      }

      .inset-y-0 {
        top: 0px;
        bottom: 0px;
      }

      .-bottom-12 {
        bottom: -3rem;
      }

      .-left-12 {
        left: -3rem;
      }

      .-right-1 {
        right: -0.25rem;
      }

      .-right-12 {
        right: -3rem;
      }

      .-right-2 {
        right: -0.5rem;
      }

      .-top-1 {
        top: -0.25rem;
      }

      .-top-12 {
        top: -3rem;
      }

      .-top-2 {
        top: -0.5rem;
      }

      .bottom-0 {
        bottom: 0px;
      }

      .bottom-10 {
        bottom: 2.5rem;
      }

      .left-0 {
        left: 0px;
      }

      .left-1 {
        left: 0.25rem;
      }

      .left-1\/2 {
        left: 50%;
      }

      .left-1\/4 {
        left: 25%;
      }

      .left-10 {
        left: 2.5rem;
      }

      .left-2 {
        left: 0.5rem;
      }

      .left-20 {
        left: 5rem;
      }

      .left-4 {
        left: 1rem;
      }

      .left-\[50\%\] {
        left: 50%;
      }

      .right-0 {
        right: 0px;
      }

      .right-1 {
        right: 0.25rem;
      }

      .right-1\/4 {
        right: 25%;
      }

      .right-10 {
        right: 2.5rem;
      }

      .right-2 {
        right: 0.5rem;
      }

      .right-20 {
        right: 5rem;
      }

      .right-3 {
        right: 0.75rem;
      }

      .right-4 {
        right: 1rem;
      }

      .top-0 {
        top: 0px;
      }

      .top-1\.5 {
        top: 0.375rem;
      }

      .top-1\/2 {
        top: 50%;
      }

      .top-2 {
        top: 0.5rem;
      }

      .top-20 {
        top: 5rem;
      }

      .top-3\.5 {
        top: 0.875rem;
      }

      .top-4 {
        top: 1rem;
      }

      .top-40 {
        top: 10rem;
      }

      .top-\[1px\] {
        top: 1px;
      }

      .top-\[50\%\] {
        top: 50%;
      }

      .top-\[60\%\] {
        top: 60%;
      }

      .top-full {
        top: 100%;
      }

      .z-0 {
        z-index: 0;
      }

      .z-10 {
        z-index: 10;
      }

      .z-20 {
        z-index: 20;
      }

      .z-50 {
        z-index: 50;
      }

      .z-\[100\] {
        z-index: 100;
      }

      .z-\[1\] {
        z-index: 1;
      }

      .-mx-1 {
        margin-left: -0.25rem;
        margin-right: -0.25rem;
      }

      .mx-2 {
        margin-left: 0.5rem;
        margin-right: 0.5rem;
      }

      .mx-3\.5 {
        margin-left: 0.875rem;
        margin-right: 0.875rem;
      }

      .mx-5 {
        margin-left: 1.25rem;
        margin-right: 1.25rem;
      }

      .mx-auto {
        margin-left: auto;
        margin-right: auto;
      }

      .my-0\.5 {
        margin-top: 0.125rem;
        margin-bottom: 0.125rem;
      }

      .my-1 {
        margin-top: 0.25rem;
        margin-bottom: 0.25rem;
      }

      .-ml-4 {
        margin-left: -1rem;
      }

      .-mt-4 {
        margin-top: -1rem;
      }

      .mb-1 {
        margin-bottom: 0.25rem;
      }

      .mb-4 {
        margin-bottom: 1rem;
      }

      .ml-1 {
        margin-left: 0.25rem;
      }

      .ml-auto {
        margin-left: auto;
      }

      .mr-2 {
        margin-right: 0.5rem;
      }

      .mt-1\.5 {
        margin-top: 0.375rem;
      }

      .mt-2 {
        margin-top: 0.5rem;
      }

      .mt-24 {
        margin-top: 6rem;
      }

      .mt-4 {
        margin-top: 1rem;
      }

      .mt-auto {
        margin-top: auto;
      }

      .block {
        display: block;
      }

      .flex {
        display: flex;
      }

      .inline-flex {
        display: inline-flex;
      }

      .table {
        display: table;
      }

      .grid {
        display: grid;
      }

      .hidden {
        display: none;
      }

      .aspect-square {
        aspect-ratio: 1 / 1;
      }

      .aspect-video {
        aspect-ratio: 16 / 9;
      }

      .size-4 {
        width: 1rem;
        height: 1rem;
      }

      .h-1 {
        height: 0.25rem;
      }

      .h-1\.5 {
        height: 0.375rem;
      }

      .h-10 {
        height: 2.5rem;
      }

      .h-11 {
        height: 2.75rem;
      }

      .h-12 {
        height: 3rem;
      }

      .h-2 {
        height: 0.5rem;
      }

      .h-2\.5 {
        height: 0.625rem;
      }

      .h-3 {
        height: 0.75rem;
      }

      .h-3\.5 {
        height: 0.875rem;
      }

      .h-4 {
        height: 1rem;
      }

      .h-5 {
        height: 1.25rem;
      }

      .h-6 {
        height: 1.5rem;
      }

      .h-7 {
        height: 1.75rem;
      }

      .h-8 {
        height: 2rem;
      }

      .h-80 {
        height: 20rem;
      }

      .h-9 {
        height: 2.25rem;
      }

      .h-96 {
        height: 24rem;
      }

      .h-\[1px\] {
        height: 1px;
      }

      .h-\[var\(--radix-navigation-menu-viewport-height\)\] {
        height: var(--radix-navigation-menu-viewport-height);
      }

      .h-\[var\(--radix-select-trigger-height\)\] {
        height: var(--radix-select-trigger-height);
      }

      .h-auto {
        height: auto;
      }

      .h-full {
        height: 100%;
      }

      .h-px {
        height: 1px;
      }

      .h-svh {
        height: 100svh;
      }

      .max-h-96 {
        max-height: 24rem;
      }

      .max-h-\[300px\] {
        max-height: 300px;
      }

      .max-h-full {
        max-height: 100%;
      }

      .max-h-screen {
        max-height: 100vh;
      }

      .min-h-0 {
        min-height: 0px;
      }

      .min-h-14 {
        min-height: 3.5rem;
      }

      .min-h-16 {
        min-height: 4rem;
      }

      .min-h-24 {
        min-height: 6rem;
      }

      .min-h-\[80px\] {
        min-height: 80px;
      }

      .min-h-screen {
        min-height: 100vh;
      }

      .min-h-svh {
        min-height: 100svh;
      }

      .w-0 {
        width: 0px;
      }

      .w-1 {
        width: 0.25rem;
      }

      .w-10 {
        width: 2.5rem;
      }

      .w-11 {
        width: 2.75rem;
      }

      .w-2 {
        width: 0.5rem;
      }

      .w-2\.5 {
        width: 0.625rem;
      }

      .w-3 {
        width: 0.75rem;
      }

      .w-3\.5 {
        width: 0.875rem;
      }

      .w-3\/4 {
        width: 75%;
      }

      .w-4 {
        width: 1rem;
      }

      .w-5 {
        width: 1.25rem;
      }

      .w-56 {
        width: 14rem;
      }

      .w-6 {
        width: 1.5rem;
      }

      .w-64 {
        width: 16rem;
      }

      .w-7 {
        width: 1.75rem;
      }

      .w-72 {
        width: 18rem;
      }

      .w-8 {
        width: 2rem;
      }

      .w-80 {
        width: 20rem;
      }

      .w-9 {
        width: 2.25rem;
      }

      .w-96 {
        width: 24rem;
      }

      .w-\[--sidebar-width\] {
        width: var(--sidebar-width);
      }

      .w-\[100px\] {
        width: 100px;
      }

      .w-\[1px\] {
        width: 1px;
      }

      .w-auto {
        width: auto;
      }

      .w-full {
        width: 100%;
      }

      .w-max {
        width: -moz-max-content;
        width: max-content;
      }

      .w-px {
        width: 1px;
      }

      .min-w-0 {
        min-width: 0px;
      }

      .min-w-10 {
        min-width: 2.5rem;
      }

      .min-w-16 {
        min-width: 4rem;
      }

      .min-w-48 {
        min-width: 12rem;
      }

      .min-w-5 {
        min-width: 1.25rem;
      }

      .min-w-56 {
        min-width: 14rem;
      }

      .min-w-\[12rem\] {
        min-width: 12rem;
      }

      .min-w-\[8rem\] {
        min-width: 8rem;
      }

      .min-w-\[var\(--radix-select-trigger-width\)\] {
        min-width: var(--radix-select-trigger-width);
      }

      .max-w-\[--skeleton-width\] {
        max-width: var(--skeleton-width);
      }

      .max-w-full {
        max-width: 100%;
      }

      .max-w-lg {
        max-width: 32rem;
      }

      .max-w-max {
        max-width: -moz-max-content;
        max-width: max-content;
      }

      .flex-1 {
        flex: 1 1 0%;
      }

      .shrink-0 {
        flex-shrink: 0;
      }

      .grow {
        flex-grow: 1;
      }

      .grow-0 {
        flex-grow: 0;
      }

      .basis-full {
        flex-basis: 100%;
      }

      .caption-bottom {
        caption-side: bottom;
      }

      .border-collapse {
        border-collapse: collapse;
      }

      .-translate-x-1\/2 {
        --tw-translate-x: -50%;
        transform: translate(var(--tw-translate-x), var(--tw-translate-y))
          rotate(var(--tw-rotate)) skewX(var(--tw-skew-x))
          skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x))
          scaleY(var(--tw-scale-y));
      }

      .-translate-x-px {
        --tw-translate-x: -1px;
        transform: translate(var(--tw-translate-x), var(--tw-translate-y))
          rotate(var(--tw-rotate)) skewX(var(--tw-skew-x))
          skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x))
          scaleY(var(--tw-scale-y));
      }

      .-translate-y-1\/2 {
        --tw-translate-y: -50%;
        transform: translate(var(--tw-translate-x), var(--tw-translate-y))
          rotate(var(--tw-rotate)) skewX(var(--tw-skew-x))
          skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x))
          scaleY(var(--tw-scale-y));
      }

      .translate-x-\[-50\%\] {
        --tw-translate-x: -50%;
        transform: translate(var(--tw-translate-x), var(--tw-translate-y))
          rotate(var(--tw-rotate)) skewX(var(--tw-skew-x))
          skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x))
          scaleY(var(--tw-scale-y));
      }

      .translate-x-px {
        --tw-translate-x: 1px;
        transform: translate(var(--tw-translate-x), var(--tw-translate-y))
          rotate(var(--tw-rotate)) skewX(var(--tw-skew-x))
          skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x))
          scaleY(var(--tw-scale-y));
      }

      .translate-y-\[-50\%\] {
        --tw-translate-y: -50%;
        transform: translate(var(--tw-translate-x), var(--tw-translate-y))
          rotate(var(--tw-rotate)) skewX(var(--tw-skew-x))
          skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x))
          scaleY(var(--tw-scale-y));
      }

      .rotate-45 {
        --tw-rotate: 45deg;
        transform: translate(var(--tw-translate-x), var(--tw-translate-y))
          rotate(var(--tw-rotate)) skewX(var(--tw-skew-x))
          skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x))
          scaleY(var(--tw-scale-y));
      }

      .rotate-90 {
        --tw-rotate: 90deg;
        transform: translate(var(--tw-translate-x), var(--tw-translate-y))
          rotate(var(--tw-rotate)) skewX(var(--tw-skew-x))
          skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x))
          scaleY(var(--tw-scale-y));
      }

      .transform {
        transform: translate(var(--tw-translate-x), var(--tw-translate-y))
          rotate(var(--tw-rotate)) skewX(var(--tw-skew-x))
          skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x))
          scaleY(var(--tw-scale-y));
      }

      @keyframes pulse {
        50% {
          opacity: 0.5;
        }
      }

      .animate-pulse {
        animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
      }

      .cursor-crosshair {
        cursor: crosshair;
      }

      .cursor-default {
        cursor: default;
      }

      .cursor-pointer {
        cursor: pointer;
      }

      .touch-none {
        touch-action: none;
      }

      .select-none {
        -webkit-user-select: none;
        -moz-user-select: none;
        user-select: none;
      }

      .resize {
        resize: both;
      }

      .list-none {
        list-style-type: none;
      }

      .flex-row {
        flex-direction: row;
      }

      .flex-col {
        flex-direction: column;
      }

      .flex-col-reverse {
        flex-direction: column-reverse;
      }

      .flex-wrap {
        flex-wrap: wrap;
      }

      .items-start {
        align-items: flex-start;
      }

      .items-end {
        align-items: flex-end;
      }

      .items-center {
        align-items: center;
      }

      .items-stretch {
        align-items: stretch;
      }

      .justify-center {
        justify-content: center;
      }

      .justify-between {
        justify-content: space-between;
      }

      .gap-1 {
        gap: 0.25rem;
      }

      .gap-1\.5 {
        gap: 0.375rem;
      }

      .gap-2 {
        gap: 0.5rem;
      }

      .gap-3 {
        gap: 0.75rem;
      }

      .gap-4 {
        gap: 1rem;
      }

      .space-x-1 > :not([hidden]) ~ :not([hidden]) {
        --tw-space-x-reverse: 0;
        margin-right: calc(0.25rem * var(--tw-space-x-reverse));
        margin-left: calc(0.25rem * calc(1 - var(--tw-space-x-reverse)));
      }

      .space-x-4 > :not([hidden]) ~ :not([hidden]) {
        --tw-space-x-reverse: 0;
        margin-right: calc(1rem * var(--tw-space-x-reverse));
        margin-left: calc(1rem * calc(1 - var(--tw-space-x-reverse)));
      }

      .space-y-1 > :not([hidden]) ~ :not([hidden]) {
        --tw-space-y-reverse: 0;
        margin-top: calc(0.25rem * calc(1 - var(--tw-space-y-reverse)));
        margin-bottom: calc(0.25rem * var(--tw-space-y-reverse));
      }

      .space-y-1\.5 > :not([hidden]) ~ :not([hidden]) {
        --tw-space-y-reverse: 0;
        margin-top: calc(0.375rem * calc(1 - var(--tw-space-y-reverse)));
        margin-bottom: calc(0.375rem * var(--tw-space-y-reverse));
      }

      .space-y-2 > :not([hidden]) ~ :not([hidden]) {
        --tw-space-y-reverse: 0;
        margin-top: calc(0.5rem * calc(1 - var(--tw-space-y-reverse)));
        margin-bottom: calc(0.5rem * var(--tw-space-y-reverse));
      }

      .space-y-4 > :not([hidden]) ~ :not([hidden]) {
        --tw-space-y-reverse: 0;
        margin-top: calc(1rem * calc(1 - var(--tw-space-y-reverse)));
        margin-bottom: calc(1rem * var(--tw-space-y-reverse));
      }

      .overflow-auto {
        overflow: auto;
      }

      .overflow-hidden {
        overflow: hidden;
      }

      .overflow-y-auto {
        overflow-y: auto;
      }

      .overflow-x-hidden {
        overflow-x: hidden;
      }

      .whitespace-nowrap {
        white-space: nowrap;
      }

      .break-words {
        overflow-wrap: break-word;
      }

      .rounded-\[2px\] {
        border-radius: 2px;
      }

      .rounded-\[inherit\] {
        border-radius: inherit;
      }

      .rounded-full {
        border-radius: 9999px;
      }

      .rounded-lg {
        border-radius: var(--radius);
      }

      .rounded-md {
        border-radius: calc(var(--radius) - 2px);
      }

      .rounded-none {
        border-radius: 0px;
      }

      .rounded-sm {
        border-radius: calc(var(--radius) - 4px);
      }

      .rounded-xl {
        border-radius: 0.75rem;
      }

      .rounded-t-\[10px\] {
        border-top-left-radius: 10px;
        border-top-right-radius: 10px;
      }

      .rounded-bl-xl {
        border-bottom-left-radius: 0.75rem;
      }

      .rounded-br-xl {
        border-bottom-right-radius: 0.75rem;
      }

      .rounded-tl-sm {
        border-top-left-radius: calc(var(--radius) - 4px);
      }

      .rounded-tl-xl {
        border-top-left-radius: 0.75rem;
      }

      .rounded-tr-xl {
        border-top-right-radius: 0.75rem;
      }

      .border {
        border-width: 1px;
      }

      .border-2 {
        border-width: 2px;
      }

      .border-4 {
        border-width: 4px;
      }

      .border-\[1\.5px\] {
        border-width: 1.5px;
      }

      .border-y {
        border-top-width: 1px;
        border-bottom-width: 1px;
      }

      .border-b {
        border-bottom-width: 1px;
      }

      .border-b-2 {
        border-bottom-width: 2px;
      }

      .border-b-4 {
        border-bottom-width: 4px;
      }

      .border-l {
        border-left-width: 1px;
      }

      .border-l-4 {
        border-left-width: 4px;
      }

      .border-r {
        border-right-width: 1px;
      }

      .border-r-2 {
        border-right-width: 2px;
      }

      .border-r-4 {
        border-right-width: 4px;
      }

      .border-t {
        border-top-width: 1px;
      }

      .border-t-2 {
        border-top-width: 2px;
      }

      .border-t-4 {
        border-top-width: 4px;
      }

      .border-dashed {
        border-style: dashed;
      }

      .border-none {
        border-style: none;
      }

      .border-\[--color-border\] {
        border-color: var(--color-border);
      }

      .border-accent {
        border-color: hsl(var(--accent));
      }

      .border-border\/50 {
        border-color: hsl(var(--border) / 0.5);
      }

      .border-destructive {
        border-color: hsl(var(--destructive));
      }

      .border-destructive\/50 {
        border-color: hsl(var(--destructive) / 0.5);
      }

      .border-foreground\/20 {
        border-color: hsl(var(--foreground) / 0.2);
      }

      .border-foreground\/30 {
        border-color: hsl(var(--foreground) / 0.3);
      }

      .border-input {
        border-color: hsl(var(--input));
      }

      .border-muted-foreground\/20 {
        border-color: hsl(var(--muted-foreground) / 0.2);
      }

      .border-muted-foreground\/30 {
        border-color: hsl(var(--muted-foreground) / 0.3);
      }

      .border-primary {
        border-color: hsl(var(--primary));
      }

      .border-primary\/20 {
        border-color: hsl(var(--primary) / 0.2);
      }

      .border-primary\/30 {
        border-color: hsl(var(--primary) / 0.3);
      }

      .border-primary\/40 {
        border-color: hsl(var(--primary) / 0.4);
      }

      .border-sidebar-border {
        border-color: hsl(var(--sidebar-border));
      }

      .border-success {
        border-color: hsl(var(--success));
      }

      .border-transparent {
        border-color: transparent;
      }

      .border-l-transparent {
        border-left-color: transparent;
      }

      .border-t-transparent {
        border-top-color: transparent;
      }

      .bg-\[--color-bg\] {
        background-color: var(--color-bg);
      }

      .bg-accent {
        background-color: hsl(var(--accent));
      }

      .bg-accent\/5 {
        background-color: hsl(var(--accent) / 0.05);
      }

      .bg-background {
        background-color: hsl(var(--background));
      }

      .bg-black\/80 {
        background-color: rgb(0 0 0 / 0.8);
      }

      .bg-border {
        background-color: hsl(var(--border));
      }

      .bg-card {
        background-color: hsl(var(--card));
      }

      .bg-chem-bg-tertiary {
        background-color: hsl(var(--chem-bg-tertiary));
      }

      .bg-destructive {
        background-color: hsl(var(--destructive));
      }

      .bg-foreground {
        background-color: hsl(var(--foreground));
      }

      .bg-muted {
        background-color: hsl(var(--muted));
      }

      .bg-muted\/50 {
        background-color: hsl(var(--muted) / 0.5);
      }

      .bg-popover {
        background-color: hsl(var(--popover));
      }

      .bg-primary {
        background-color: hsl(var(--primary));
      }

      .bg-primary\/10 {
        background-color: hsl(var(--primary) / 0.1);
      }

      .bg-primary\/5 {
        background-color: hsl(var(--primary) / 0.05);
      }

      .bg-secondary {
        background-color: hsl(var(--secondary));
      }

      .bg-sidebar {
        background-color: hsl(var(--sidebar-background));
      }

      .bg-sidebar-border {
        background-color: hsl(var(--sidebar-border));
      }

      .bg-transparent {
        background-color: transparent;
      }

      .bg-gradient-to-br {
        background-image: linear-gradient(
          to bottom right,
          var(--tw-gradient-stops)
        );
      }

      .bg-gradient-to-r {
        background-image: linear-gradient(to right, var(--tw-gradient-stops));
      }

      .bg-gradient-to-t {
        background-image: linear-gradient(to top, var(--tw-gradient-stops));
      }

      .from-black\/50 {
        --tw-gradient-from: rgb(0 0 0 / 0.5) var(--tw-gradient-from-position);
        --tw-gradient-to: rgb(0 0 0 / 0) var(--tw-gradient-to-position);
        --tw-gradient-stops: var(--tw-gradient-from), var(--tw-gradient-to);
      }

      .from-green-900 {
        --tw-gradient-from: #14532d var(--tw-gradient-from-position);
        --tw-gradient-to: rgb(20 83 45 / 0) var(--tw-gradient-to-position);
        --tw-gradient-stops: var(--tw-gradient-from), var(--tw-gradient-to);
      }

      .from-red-900 {
        --tw-gradient-from: #7f1d1d var(--tw-gradient-from-position);
        --tw-gradient-to: rgb(127 29 29 / 0) var(--tw-gradient-to-position);
        --tw-gradient-stops: var(--tw-gradient-from), var(--tw-gradient-to);
      }

      .from-transparent {
        --tw-gradient-from: transparent var(--tw-gradient-from-position);
        --tw-gradient-to: rgb(0 0 0 / 0) var(--tw-gradient-to-position);
        --tw-gradient-stops: var(--tw-gradient-from), var(--tw-gradient-to);
      }

      .via-transparent {
        --tw-gradient-to: rgb(0 0 0 / 0) var(--tw-gradient-to-position);
        --tw-gradient-stops:
          var(--tw-gradient-from), transparent var(--tw-gradient-via-position),
          var(--tw-gradient-to);
      }

      .via-white\/20 {
        --tw-gradient-to: rgb(255 255 255 / 0) var(--tw-gradient-to-position);
        --tw-gradient-stops:
          var(--tw-gradient-from),
          rgb(255 255 255 / 0.2) var(--tw-gradient-via-position),
          var(--tw-gradient-to);
      }

      .to-green-950 {
        --tw-gradient-to: #052e16 var(--tw-gradient-to-position);
      }

      .to-red-950 {
        --tw-gradient-to: #450a0a var(--tw-gradient-to-position);
      }

      .to-transparent {
        --tw-gradient-to: transparent var(--tw-gradient-to-position);
      }

      .fill-current {
        fill: currentColor;
      }

      .object-contain {
        -o-object-fit: contain;
        object-fit: contain;
      }

      .p-0 {
        padding: 0px;
      }

      .p-1 {
        padding: 0.25rem;
      }

      .p-10 {
        padding: 2.5rem;
      }

      .p-2 {
        padding: 0.5rem;
      }

      .p-3 {
        padding: 0.75rem;
      }

      .p-4 {
        padding: 1rem;
      }

      .p-5 {
        padding: 1.25rem;
      }

      .p-6 {
        padding: 1.5rem;
      }

      .p-\[1px\] {
        padding: 1px;
      }

      .px-1 {
        padding-left: 0.25rem;
        padding-right: 0.25rem;
      }

      .px-16 {
        padding-left: 4rem;
        padding-right: 4rem;
      }

      .px-2 {
        padding-left: 0.5rem;
        padding-right: 0.5rem;
      }

      .px-2\.5 {
        padding-left: 0.625rem;
        padding-right: 0.625rem;
      }

      .px-3 {
        padding-left: 0.75rem;
        padding-right: 0.75rem;
      }

      .px-4 {
        padding-left: 1rem;
        padding-right: 1rem;
      }

      .px-5 {
        padding-left: 1.25rem;
        padding-right: 1.25rem;
      }

      .px-6 {
        padding-left: 1.5rem;
        padding-right: 1.5rem;
      }

      .px-8 {
        padding-left: 2rem;
        padding-right: 2rem;
      }

      .py-0\.5 {
        padding-top: 0.125rem;
        padding-bottom: 0.125rem;
      }

      .py-1 {
        padding-top: 0.25rem;
        padding-bottom: 0.25rem;
      }

      .py-1\.5 {
        padding-top: 0.375rem;
        padding-bottom: 0.375rem;
      }

      .py-10 {
        padding-top: 2.5rem;
        padding-bottom: 2.5rem;
      }

      .py-2 {
        padding-top: 0.5rem;
        padding-bottom: 0.5rem;
      }

      .py-3 {
        padding-top: 0.75rem;
        padding-bottom: 0.75rem;
      }

      .py-4 {
        padding-top: 1rem;
        padding-bottom: 1rem;
      }

      .py-6 {
        padding-top: 1.5rem;
        padding-bottom: 1.5rem;
      }

      .pb-3 {
        padding-bottom: 0.75rem;
      }

      .pb-4 {
        padding-bottom: 1rem;
      }

      .pl-2\.5 {
        padding-left: 0.625rem;
      }

      .pl-4 {
        padding-left: 1rem;
      }

      .pl-8 {
        padding-left: 2rem;
      }

      .pr-2 {
        padding-right: 0.5rem;
      }

      .pr-2\.5 {
        padding-right: 0.625rem;
      }

      .pr-8 {
        padding-right: 2rem;
      }

      .pt-0 {
        padding-top: 0px;
      }

      .pt-1 {
        padding-top: 0.25rem;
      }

      .pt-3 {
        padding-top: 0.75rem;
      }

      .pt-4 {
        padding-top: 1rem;
      }

      .text-left {
        text-align: left;
      }

      .text-center {
        text-align: center;
      }

      .align-middle {
        vertical-align: middle;
      }

      .font-mono {
        font-family:
          Roboto Mono,
          monospace;
      }

      .font-oswald {
        font-family: Oswald, sans-serif;
      }

      .text-2xl {
        font-size: 1.5rem;
        line-height: 2rem;
      }

      .text-3xl {
        font-size: 1.875rem;
        line-height: 2.25rem;
      }

      .text-4xl {
        font-size: 2.25rem;
        line-height: 2.5rem;
      }

      .text-6xl {
        font-size: 3.75rem;
        line-height: 1;
      }

      .text-\[0\.8rem\] {
        font-size: 0.8rem;
      }

      .text-base {
        font-size: 1rem;
        line-height: 1.5rem;
      }

      .text-lg {
        font-size: 1.125rem;
        line-height: 1.75rem;
      }

      .text-sm {
        font-size: 0.875rem;
        line-height: 1.25rem;
      }

      .text-xl {
        font-size: 1.25rem;
        line-height: 1.75rem;
      }

      .text-xs {
        font-size: 0.75rem;
        line-height: 1rem;
      }

      .font-bold {
        font-weight: 700;
      }

      .font-medium {
        font-weight: 500;
      }

      .font-normal {
        font-weight: 400;
      }

      .font-semibold {
        font-weight: 600;
      }

      .uppercase {
        text-transform: uppercase;
      }

      .tabular-nums {
        --tw-numeric-spacing: tabular-nums;
        font-variant-numeric: var(--tw-ordinal) var(--tw-slashed-zero)
          var(--tw-numeric-figure) var(--tw-numeric-spacing)
          var(--tw-numeric-fraction);
      }

      .leading-none {
        line-height: 1;
      }

      .leading-tight {
        line-height: 1.25;
      }

      .tracking-tight {
        letter-spacing: -0.025em;
      }

      .tracking-wide {
        letter-spacing: 0.025em;
      }

      .tracking-wider {
        letter-spacing: 0.05em;
      }

      .tracking-widest {
        letter-spacing: 0.1em;
      }

      .text-accent {
        color: hsl(var(--accent));
      }

      .text-accent-foreground {
        color: hsl(var(--accent-foreground));
      }

      .text-accent\/60 {
        color: hsl(var(--accent) / 0.6);
      }

      .text-background {
        color: hsl(var(--background));
      }

      .text-card-foreground {
        color: hsl(var(--card-foreground));
      }

      .text-current {
        color: currentColor;
      }

      .text-destructive {
        color: hsl(var(--destructive));
      }

      .text-destructive-foreground {
        color: hsl(var(--destructive-foreground));
      }

      .text-foreground {
        color: hsl(var(--foreground));
      }

      .text-foreground\/50 {
        color: hsl(var(--foreground) / 0.5);
      }

      .text-muted-foreground {
        color: hsl(var(--muted-foreground));
      }

      .text-popover-foreground {
        color: hsl(var(--popover-foreground));
      }

      .text-primary {
        color: hsl(var(--primary));
      }

      .text-primary-foreground {
        color: hsl(var(--primary-foreground));
      }

      .text-primary\/40 {
        color: hsl(var(--primary) / 0.4);
      }

      .text-primary\/60 {
        color: hsl(var(--primary) / 0.6);
      }

      .text-secondary-foreground {
        color: hsl(var(--secondary-foreground));
      }

      .text-sidebar-foreground {
        color: hsl(var(--sidebar-foreground));
      }

      .text-sidebar-foreground\/70 {
        color: hsl(var(--sidebar-foreground) / 0.7);
      }

      .underline {
        text-decoration-line: underline;
      }

      .underline-offset-4 {
        text-underline-offset: 4px;
      }

      .opacity-0 {
        opacity: 0;
      }

      .opacity-10 {
        opacity: 0.1;
      }

      .opacity-20 {
        opacity: 0.2;
      }

      .opacity-50 {
        opacity: 0.5;
      }

      .opacity-60 {
        opacity: 0.6;
      }

      .opacity-70 {
        opacity: 0.7;
      }

      .opacity-80 {
        opacity: 0.8;
      }

      .opacity-90 {
        opacity: 0.9;
      }

      .shadow-2xl {
        --tw-shadow: 0 25px 50px -12px rgb(0 0 0 / 0.25);
        --tw-shadow-colored: 0 25px 50px -12px var(--tw-shadow-color);
        box-shadow:
          var(--tw-ring-offset-shadow, 0 0 #0000),
          var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);
      }

      .shadow-\[0_0_0_1px_hsl\(var\(--sidebar-border\)\)\] {
        --tw-shadow: 0 0 0 1px hsl(var(--sidebar-border));
        --tw-shadow-colored: 0 0 0 1px var(--tw-shadow-color);
        box-shadow:
          var(--tw-ring-offset-shadow, 0 0 #0000),
          var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);
      }

      .shadow-lg {
        --tw-shadow:
          0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        --tw-shadow-colored:
          0 10px 15px -3px var(--tw-shadow-color),
          0 4px 6px -4px var(--tw-shadow-color);
        box-shadow:
          var(--tw-ring-offset-shadow, 0 0 #0000),
          var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);
      }

      .shadow-md {
        --tw-shadow:
          0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
        --tw-shadow-colored:
          0 4px 6px -1px var(--tw-shadow-color),
          0 2px 4px -2px var(--tw-shadow-color);
        box-shadow:
          var(--tw-ring-offset-shadow, 0 0 #0000),
          var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);
      }

      .shadow-none {
        --tw-shadow: 0 0 #0000;
        --tw-shadow-colored: 0 0 #0000;
        box-shadow:
          var(--tw-ring-offset-shadow, 0 0 #0000),
          var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);
      }

      .shadow-sm {
        --tw-shadow: 0 1px 2px 0 rgb(0 0 0 / 0.05);
        --tw-shadow-colored: 0 1px 2px 0 var(--tw-shadow-color);
        box-shadow:
          var(--tw-ring-offset-shadow, 0 0 #0000),
          var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);
      }

      .shadow-xl {
        --tw-shadow:
          0 20px 25px -5px rgb(0 0 0 / 0.1), 0 8px 10px -6px rgb(0 0 0 / 0.1);
        --tw-shadow-colored:
          0 20px 25px -5px var(--tw-shadow-color),
          0 8px 10px -6px var(--tw-shadow-color);
        box-shadow:
          var(--tw-ring-offset-shadow, 0 0 #0000),
          var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);
      }

      .outline-none {
        outline: 2px solid transparent;
        outline-offset: 2px;
      }

      .outline {
        outline-style: solid;
      }

      .ring-0 {
        --tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0
          var(--tw-ring-offset-width) var(--tw-ring-offset-color);
        --tw-ring-shadow: var(--tw-ring-inset) 0 0 0
          calc(0px + var(--tw-ring-offset-width)) var(--tw-ring-color);
        box-shadow:
          var(--tw-ring-offset-shadow), var(--tw-ring-shadow),
          var(--tw-shadow, 0 0 #0000);
      }

      .ring-2 {
        --tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0
          var(--tw-ring-offset-width) var(--tw-ring-offset-color);
        --tw-ring-shadow: var(--tw-ring-inset) 0 0 0
          calc(2px + var(--tw-ring-offset-width)) var(--tw-ring-color);
        box-shadow:
          var(--tw-ring-offset-shadow), var(--tw-ring-shadow),
          var(--tw-shadow, 0 0 #0000);
      }

      .ring-ring {
        --tw-ring-color: hsl(var(--ring));
      }

      .ring-sidebar-ring {
        --tw-ring-color: hsl(var(--sidebar-ring));
      }

      .ring-offset-background {
        --tw-ring-offset-color: hsl(var(--background));
      }

      .blur-3xl {
        --tw-blur: blur(64px);
        filter: var(--tw-blur) var(--tw-brightness) var(--tw-contrast)
          var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert)
          var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow);
      }

      .blur-xl {
        --tw-blur: blur(24px);
        filter: var(--tw-blur) var(--tw-brightness) var(--tw-contrast)
          var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert)
          var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow);
      }

      .drop-shadow-lg {
        --tw-drop-shadow: drop-shadow(0 10px 8px rgb(0 0 0 / 0.04))
          drop-shadow(0 4px 3px rgb(0 0 0 / 0.1));
        filter: var(--tw-blur) var(--tw-brightness) var(--tw-contrast)
          var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert)
          var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow);
      }

      .filter {
        filter: var(--tw-blur) var(--tw-brightness) var(--tw-contrast)
          var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert)
          var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow);
      }

      .backdrop-blur-sm {
        --tw-backdrop-blur: blur(4px);
        -webkit-backdrop-filter: var(--tw-backdrop-blur)
          var(--tw-backdrop-brightness) var(--tw-backdrop-contrast)
          var(--tw-backdrop-grayscale) var(--tw-backdrop-hue-rotate)
          var(--tw-backdrop-invert) var(--tw-backdrop-opacity)
          var(--tw-backdrop-saturate) var(--tw-backdrop-sepia);
        backdrop-filter: var(--tw-backdrop-blur) var(--tw-backdrop-brightness)
          var(--tw-backdrop-contrast) var(--tw-backdrop-grayscale)
          var(--tw-backdrop-hue-rotate) var(--tw-backdrop-invert)
          var(--tw-backdrop-opacity) var(--tw-backdrop-saturate)
          var(--tw-backdrop-sepia);
      }

      .transition {
        transition-property:
          color,
          background-color,
          border-color,
          text-decoration-color,
          fill,
          stroke,
          opacity,
          box-shadow,
          transform,
          filter,
          -webkit-backdrop-filter;
        transition-property:
          color, background-color, border-color, text-decoration-color, fill,
          stroke, opacity, box-shadow, transform, filter, backdrop-filter;
        transition-property:
          color,
          background-color,
          border-color,
          text-decoration-color,
          fill,
          stroke,
          opacity,
          box-shadow,
          transform,
          filter,
          backdrop-filter,
          -webkit-backdrop-filter;
        transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
        transition-duration: 150ms;
      }

      .transition-\[left\2c right\2c width\] {
        transition-property: left, right, width;
        transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
        transition-duration: 150ms;
      }

      .transition-\[margin\2c opa\] {
        transition-property: margin, opa;
        transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
        transition-duration: 150ms;
      }

      .transition-\[width\2c height\2c padding\] {
        transition-property: width, height, padding;
        transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
        transition-duration: 150ms;
      }

      .transition-\[width\] {
        transition-property: width;
        transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
        transition-duration: 150ms;
      }

      .transition-all {
        transition-property: all;
        transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
        transition-duration: 150ms;
      }

      .transition-colors {
        transition-property:
          color, background-color, border-color, text-decoration-color, fill,
          stroke;
        transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
        transition-duration: 150ms;
      }

      .transition-opacity {
        transition-property: opacity;
        transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
        transition-duration: 150ms;
      }

      .transition-transform {
        transition-property: transform;
        transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
        transition-duration: 150ms;
      }

      .duration-1000 {
        transition-duration: 1000ms;
      }

      .duration-200 {
        transition-duration: 200ms;
      }

      .ease-in-out {
        transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
      }

      .ease-linear {
        transition-timing-function: linear;
      }

      @keyframes enter {
        from {
          opacity: var(--tw-enter-opacity, 1);
          transform: translate3d(
              var(--tw-enter-translate-x, 0),
              var(--tw-enter-translate-y, 0),
              0
            )
            scale3d(
              var(--tw-enter-scale, 1),
              var(--tw-enter-scale, 1),
              var(--tw-enter-scale, 1)
            )
            rotate(var(--tw-enter-rotate, 0));
        }
      }

      @keyframes exit {
        to {
          opacity: var(--tw-exit-opacity, 1);
          transform: translate3d(
              var(--tw-exit-translate-x, 0),
              var(--tw-exit-translate-y, 0),
              0
            )
            scale3d(
              var(--tw-exit-scale, 1),
              var(--tw-exit-scale, 1),
              var(--tw-exit-scale, 1)
            )
            rotate(var(--tw-exit-rotate, 0));
        }
      }

      .animate-in {
        animation-name: enter;
        animation-duration: 150ms;
        --tw-enter-opacity: initial;
        --tw-enter-scale: initial;
        --tw-enter-rotate: initial;
        --tw-enter-translate-x: initial;
        --tw-enter-translate-y: initial;
      }

      .fade-in-0 {
        --tw-enter-opacity: 0;
      }

      .fade-in-80 {
        --tw-enter-opacity: 0.8;
      }

      .zoom-in-95 {
        --tw-enter-scale: 0.95;
      }

      .duration-1000 {
        animation-duration: 1000ms;
      }

      .duration-200 {
        animation-duration: 200ms;
      }

      .ease-in-out {
        animation-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
      }

      .ease-linear {
        animation-timing-function: linear;
      }

      .gradient-text {
        -webkit-background-clip: text;
        background-clip: text;
        color: transparent;
        background-image: var(--gradient-primary);
      }

      .gradient-bg-success {
        background: var(--gradient-success);
      }

      .gradient-bg-toxic {
        background: var(--gradient-toxic);
      }

      .shadow-glow {
        box-shadow: var(--shadow-glow);
      }

      .font-mono-chem {
        font-family: "Roboto Mono", monospace;
      }

      /* Hazard stripes pattern */

      .hazard-stripes {
        background: repeating-linear-gradient(
          45deg,
          hsl(55 100% 50%),
          hsl(55 100% 50%) 10px,
          hsl(0 0% 10%) 10px,
          hsl(0 0% 10%) 20px
        );
      }

      /* Scanlines effect */

      .scanlines::after {
        content: "";
        position: absolute;
        inset: 0;
        background: repeating-linear-gradient(
          0deg,
          transparent,
          transparent 2px,
          rgba(0, 0, 0, 0.1) 2px,
          rgba(0, 0, 0, 0.1) 4px
        );
        pointer-events: none;
      }

      /* Breaking Bad Chemistry Theme - Design System */

      /* Custom scrollbar for BB theme */

      ::-webkit-scrollbar {
        width: 8px;
      }

      ::-webkit-scrollbar-track {
        background: hsl(80 10% 8%);
        border-radius: 0;
      }

      ::-webkit-scrollbar-thumb {
        background: hsl(55 100% 30%);
        border-radius: 0;
      }

      ::-webkit-scrollbar-thumb:hover {
        background: hsl(55 100% 50%);
      }

      /* Pulse animation for correct zones */

      @keyframes pulse-correct {
        0%,
        100% {
          box-shadow: 0 0 10px hsla(120, 60%, 40%, 0.5);
        }
        50% {
          box-shadow: 0 0 25px hsla(120, 60%, 40%, 0.8);
        }
      }

      @keyframes flash-wrong {
        0%,
        100% {
          opacity: 1;
        }
        25%,
        75% {
          opacity: 0.3;
          border-color: hsl(0 70% 50%);
        }
      }

      @keyframes toxic-pulse {
        0%,
        100% {
          opacity: 0.3;
        }
        50% {
          opacity: 0.6;
        }
      }

      .animate-pulse-correct {
        animation: pulse-correct 1s ease-in-out infinite;
      }

      .animate-flash-wrong {
        animation: flash-wrong 0.4s ease-in-out;
      }

      .animate-toxic {
        animation: toxic-pulse 3s ease-in-out infinite;
      }

      .file\:border-0::file-selector-button {
        border-width: 0px;
      }

      .file\:bg-transparent::file-selector-button {
        background-color: transparent;
      }

      .file\:text-sm::file-selector-button {
        font-size: 0.875rem;
        line-height: 1.25rem;
      }

      .file\:font-medium::file-selector-button {
        font-weight: 500;
      }

      .file\:text-foreground::file-selector-button {
        color: hsl(var(--foreground));
      }

      .placeholder\:text-muted-foreground::-moz-placeholder {
        color: hsl(var(--muted-foreground));
      }

      .placeholder\:text-muted-foreground::placeholder {
        color: hsl(var(--muted-foreground));
      }

      .after\:absolute::after {
        content: var(--tw-content);
        position: absolute;
      }

      .after\:-inset-2::after {
        content: var(--tw-content);
        inset: -0.5rem;
      }

      .after\:inset-y-0::after {
        content: var(--tw-content);
        top: 0px;
        bottom: 0px;
      }

      .after\:left-1\/2::after {
        content: var(--tw-content);
        left: 50%;
      }

      .after\:w-1::after {
        content: var(--tw-content);
        width: 0.25rem;
      }

      .after\:w-\[2px\]::after {
        content: var(--tw-content);
        width: 2px;
      }

      .after\:-translate-x-1\/2::after {
        content: var(--tw-content);
        --tw-translate-x: -50%;
        transform: translate(var(--tw-translate-x), var(--tw-translate-y))
          rotate(var(--tw-rotate)) skewX(var(--tw-skew-x))
          skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x))
          scaleY(var(--tw-scale-y));
      }

      .first\:rounded-l-md:first-child {
        border-top-left-radius: calc(var(--radius) - 2px);
        border-bottom-left-radius: calc(var(--radius) - 2px);
      }

      .first\:border-l:first-child {
        border-left-width: 1px;
      }

      .last\:rounded-r-md:last-child {
        border-top-right-radius: calc(var(--radius) - 2px);
        border-bottom-right-radius: calc(var(--radius) - 2px);
      }

      .focus-within\:relative:focus-within {
        position: relative;
      }

      .focus-within\:z-20:focus-within {
        z-index: 20;
      }

      .hover\:-translate-y-0\.5:hover {
        --tw-translate-y: -0.125rem;
        transform: translate(var(--tw-translate-x), var(--tw-translate-y))
          rotate(var(--tw-rotate)) skewX(var(--tw-skew-x))
          skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x))
          scaleY(var(--tw-scale-y));
      }

      .hover\:border-destructive:hover {
        border-color: hsl(var(--destructive));
      }

      .hover\:border-primary:hover {
        border-color: hsl(var(--primary));
      }

      .hover\:border-primary\/50:hover {
        border-color: hsl(var(--primary) / 0.5);
      }

      .hover\:bg-accent:hover {
        background-color: hsl(var(--accent));
      }

      .hover\:bg-destructive\/10:hover {
        background-color: hsl(var(--destructive) / 0.1);
      }

      .hover\:bg-destructive\/80:hover {
        background-color: hsl(var(--destructive) / 0.8);
      }

      .hover\:bg-destructive\/90:hover {
        background-color: hsl(var(--destructive) / 0.9);
      }

      .hover\:bg-muted:hover {
        background-color: hsl(var(--muted));
      }

      .hover\:bg-muted\/50:hover {
        background-color: hsl(var(--muted) / 0.5);
      }

      .hover\:bg-primary:hover {
        background-color: hsl(var(--primary));
      }

      .hover\:bg-primary\/10:hover {
        background-color: hsl(var(--primary) / 0.1);
      }

      .hover\:bg-primary\/5:hover {
        background-color: hsl(var(--primary) / 0.05);
      }

      .hover\:bg-primary\/80:hover {
        background-color: hsl(var(--primary) / 0.8);
      }

      .hover\:bg-primary\/90:hover {
        background-color: hsl(var(--primary) / 0.9);
      }

      .hover\:bg-secondary:hover {
        background-color: hsl(var(--secondary));
      }

      .hover\:bg-secondary\/80:hover {
        background-color: hsl(var(--secondary) / 0.8);
      }

      .hover\:bg-sidebar-accent:hover {
        background-color: hsl(var(--sidebar-accent));
      }

      .hover\:text-accent-foreground:hover {
        color: hsl(var(--accent-foreground));
      }

      .hover\:text-foreground:hover {
        color: hsl(var(--foreground));
      }

      .hover\:text-muted-foreground:hover {
        color: hsl(var(--muted-foreground));
      }

      .hover\:text-primary-foreground:hover {
        color: hsl(var(--primary-foreground));
      }

      .hover\:text-primary\/90:hover {
        color: hsl(var(--primary) / 0.9);
      }

      .hover\:text-sidebar-accent-foreground:hover {
        color: hsl(var(--sidebar-accent-foreground));
      }

      .hover\:underline:hover {
        text-decoration-line: underline;
      }

      .hover\:opacity-100:hover {
        opacity: 1;
      }

      .hover\:shadow-\[0_0_0_1px_hsl\(var\(--sidebar-accent\)\)\]:hover {
        --tw-shadow: 0 0 0 1px hsl(var(--sidebar-accent));
        --tw-shadow-colored: 0 0 0 1px var(--tw-shadow-color);
        box-shadow:
          var(--tw-ring-offset-shadow, 0 0 #0000),
          var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);
      }

      .hover\:shadow-glow:hover {
        box-shadow: var(--shadow-glow);
      }

      .hover\:shadow-toxic:hover {
        box-shadow: var(--shadow-toxic);
      }

      .hover\:after\:bg-sidebar-border:hover::after {
        content: var(--tw-content);
        background-color: hsl(var(--sidebar-border));
      }

      .focus\:bg-accent:focus {
        background-color: hsl(var(--accent));
      }

      .focus\:bg-primary:focus {
        background-color: hsl(var(--primary));
      }

      .focus\:text-accent-foreground:focus {
        color: hsl(var(--accent-foreground));
      }

      .focus\:text-primary-foreground:focus {
        color: hsl(var(--primary-foreground));
      }

      .focus\:opacity-100:focus {
        opacity: 1;
      }

      .focus\:outline-none:focus {
        outline: 2px solid transparent;
        outline-offset: 2px;
      }

      .focus\:ring-2:focus {
        --tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0
          var(--tw-ring-offset-width) var(--tw-ring-offset-color);
        --tw-ring-shadow: var(--tw-ring-inset) 0 0 0
          calc(2px + var(--tw-ring-offset-width)) var(--tw-ring-color);
        box-shadow:
          var(--tw-ring-offset-shadow), var(--tw-ring-shadow),
          var(--tw-shadow, 0 0 #0000);
      }

      .focus\:ring-ring:focus {
        --tw-ring-color: hsl(var(--ring));
      }

      .focus\:ring-offset-2:focus {
        --tw-ring-offset-width: 2px;
      }

      .focus-visible\:outline-none:focus-visible {
        outline: 2px solid transparent;
        outline-offset: 2px;
      }

      .focus-visible\:ring-1:focus-visible {
        --tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0
          var(--tw-ring-offset-width) var(--tw-ring-offset-color);
        --tw-ring-shadow: var(--tw-ring-inset) 0 0 0
          calc(1px + var(--tw-ring-offset-width)) var(--tw-ring-color);
        box-shadow:
          var(--tw-ring-offset-shadow), var(--tw-ring-shadow),
          var(--tw-shadow, 0 0 #0000);
      }

      .focus-visible\:ring-2:focus-visible {
        --tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0
          var(--tw-ring-offset-width) var(--tw-ring-offset-color);
        --tw-ring-shadow: var(--tw-ring-inset) 0 0 0
          calc(2px + var(--tw-ring-offset-width)) var(--tw-ring-color);
        box-shadow:
          var(--tw-ring-offset-shadow), var(--tw-ring-shadow),
          var(--tw-shadow, 0 0 #0000);
      }

      .focus-visible\:ring-ring:focus-visible {
        --tw-ring-color: hsl(var(--ring));
      }

      .focus-visible\:ring-sidebar-ring:focus-visible {
        --tw-ring-color: hsl(var(--sidebar-ring));
      }

      .focus-visible\:ring-offset-1:focus-visible {
        --tw-ring-offset-width: 1px;
      }

      .focus-visible\:ring-offset-2:focus-visible {
        --tw-ring-offset-width: 2px;
      }

      .focus-visible\:ring-offset-background:focus-visible {
        --tw-ring-offset-color: hsl(var(--background));
      }

      .active\:bg-sidebar-accent:active {
        background-color: hsl(var(--sidebar-accent));
      }

      .active\:text-sidebar-accent-foreground:active {
        color: hsl(var(--sidebar-accent-foreground));
      }

      .disabled\:pointer-events-none:disabled {
        pointer-events: none;
      }

      .disabled\:cursor-not-allowed:disabled {
        cursor: not-allowed;
      }

      .disabled\:opacity-30:disabled {
        opacity: 0.3;
      }

      .disabled\:opacity-50:disabled {
        opacity: 0.5;
      }

      .group\/menu-item:focus-within
        .group-focus-within\/menu-item\:opacity-100 {
        opacity: 1;
      }

      .group\/menu-item:hover .group-hover\/menu-item\:opacity-100 {
        opacity: 1;
      }

      .group:hover .group-hover\:opacity-100 {
        opacity: 1;
      }

      .group.destructive .group-\[\.destructive\]\:border-muted\/40 {
        border-color: hsl(var(--muted) / 0.4);
      }

      .group.toaster .group-\[\.toaster\]\:border-border {
        border-color: hsl(var(--border));
      }

      .group.toast .group-\[\.toast\]\:bg-muted {
        background-color: hsl(var(--muted));
      }

      .group.toast .group-\[\.toast\]\:bg-primary {
        background-color: hsl(var(--primary));
      }

      .group.toaster .group-\[\.toaster\]\:bg-background {
        background-color: hsl(var(--background));
      }

      .group.destructive .group-\[\.destructive\]\:text-red-300 {
        --tw-text-opacity: 1;
        color: rgb(252 165 165 / var(--tw-text-opacity, 1));
      }

      .group.toast .group-\[\.toast\]\:text-muted-foreground {
        color: hsl(var(--muted-foreground));
      }

      .group.toast .group-\[\.toast\]\:text-primary-foreground {
        color: hsl(var(--primary-foreground));
      }

      .group.toaster .group-\[\.toaster\]\:text-foreground {
        color: hsl(var(--foreground));
      }

      .group.toaster .group-\[\.toaster\]\:shadow-lg {
        --tw-shadow:
          0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        --tw-shadow-colored:
          0 10px 15px -3px var(--tw-shadow-color),
          0 4px 6px -4px var(--tw-shadow-color);
        box-shadow:
          var(--tw-ring-offset-shadow, 0 0 #0000),
          var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);
      }

      .group.destructive
        .group-\[\.destructive\]\:hover\:border-destructive\/30:hover {
        border-color: hsl(var(--destructive) / 0.3);
      }

      .group.destructive .group-\[\.destructive\]\:hover\:bg-destructive:hover {
        background-color: hsl(var(--destructive));
      }

      .group.destructive
        .group-\[\.destructive\]\:hover\:text-destructive-foreground:hover {
        color: hsl(var(--destructive-foreground));
      }

      .group.destructive .group-\[\.destructive\]\:hover\:text-red-50:hover {
        --tw-text-opacity: 1;
        color: rgb(254 242 242 / var(--tw-text-opacity, 1));
      }

      .group.destructive
        .group-\[\.destructive\]\:focus\:ring-destructive:focus {
        --tw-ring-color: hsl(var(--destructive));
      }

      .group.destructive .group-\[\.destructive\]\:focus\:ring-red-400:focus {
        --tw-ring-opacity: 1;
        --tw-ring-color: rgb(248 113 113 / var(--tw-ring-opacity, 1));
      }

      .group.destructive
        .group-\[\.destructive\]\:focus\:ring-offset-red-600:focus {
        --tw-ring-offset-color: #dc2626;
      }

      .peer\/menu-button:hover
        ~ .peer-hover\/menu-button\:text-sidebar-accent-foreground {
        color: hsl(var(--sidebar-accent-foreground));
      }

      .peer:disabled ~ .peer-disabled\:cursor-not-allowed {
        cursor: not-allowed;
      }

      .peer:disabled ~ .peer-disabled\:opacity-70 {
        opacity: 0.7;
      }

      .has-\[\[data-variant\=inset\]\]\:bg-sidebar:has([data-variant="inset"]) {
        background-color: hsl(var(--sidebar-background));
      }

      .has-\[\:disabled\]\:opacity-50:has(:disabled) {
        opacity: 0.5;
      }

      .group\/menu-item:has([data-sidebar="menu-action"])
        .group-has-\[\[data-sidebar\=menu-action\]\]\/menu-item\:pr-8 {
        padding-right: 2rem;
      }

      .aria-disabled\:pointer-events-none[aria-disabled="true"] {
        pointer-events: none;
      }

      .aria-disabled\:opacity-50[aria-disabled="true"] {
        opacity: 0.5;
      }

      .aria-selected\:bg-accent[aria-selected="true"] {
        background-color: hsl(var(--accent));
      }

      .aria-selected\:bg-accent\/50[aria-selected="true"] {
        background-color: hsl(var(--accent) / 0.5);
      }

      .aria-selected\:text-accent-foreground[aria-selected="true"] {
        color: hsl(var(--accent-foreground));
      }

      .aria-selected\:text-muted-foreground[aria-selected="true"] {
        color: hsl(var(--muted-foreground));
      }

      .aria-selected\:opacity-100[aria-selected="true"] {
        opacity: 1;
      }

      .aria-selected\:opacity-30[aria-selected="true"] {
        opacity: 0.3;
      }

      .data-\[disabled\=true\]\:pointer-events-none[data-disabled="true"] {
        pointer-events: none;
      }

      .data-\[disabled\]\:pointer-events-none[data-disabled] {
        pointer-events: none;
      }

      .data-\[panel-group-direction\=vertical\]\:h-px[data-panel-group-direction="vertical"] {
        height: 1px;
      }

      .data-\[panel-group-direction\=vertical\]\:w-full[data-panel-group-direction="vertical"] {
        width: 100%;
      }

      .data-\[side\=bottom\]\:translate-y-1[data-side="bottom"] {
        --tw-translate-y: 0.25rem;
        transform: translate(var(--tw-translate-x), var(--tw-translate-y))
          rotate(var(--tw-rotate)) skewX(var(--tw-skew-x))
          skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x))
          scaleY(var(--tw-scale-y));
      }

      .data-\[side\=left\]\:-translate-x-1[data-side="left"] {
        --tw-translate-x: -0.25rem;
        transform: translate(var(--tw-translate-x), var(--tw-translate-y))
          rotate(var(--tw-rotate)) skewX(var(--tw-skew-x))
          skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x))
          scaleY(var(--tw-scale-y));
      }

      .data-\[side\=right\]\:translate-x-1[data-side="right"] {
        --tw-translate-x: 0.25rem;
        transform: translate(var(--tw-translate-x), var(--tw-translate-y))
          rotate(var(--tw-rotate)) skewX(var(--tw-skew-x))
          skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x))
          scaleY(var(--tw-scale-y));
      }

      .data-\[side\=top\]\:-translate-y-1[data-side="top"] {
        --tw-translate-y: -0.25rem;
        transform: translate(var(--tw-translate-x), var(--tw-translate-y))
          rotate(var(--tw-rotate)) skewX(var(--tw-skew-x))
          skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x))
          scaleY(var(--tw-scale-y));
      }

      .data-\[state\=checked\]\:translate-x-5[data-state="checked"] {
        --tw-translate-x: 1.25rem;
        transform: translate(var(--tw-translate-x), var(--tw-translate-y))
          rotate(var(--tw-rotate)) skewX(var(--tw-skew-x))
          skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x))
          scaleY(var(--tw-scale-y));
      }

      .data-\[state\=unchecked\]\:translate-x-0[data-state="unchecked"] {
        --tw-translate-x: 0px;
        transform: translate(var(--tw-translate-x), var(--tw-translate-y))
          rotate(var(--tw-rotate)) skewX(var(--tw-skew-x))
          skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x))
          scaleY(var(--tw-scale-y));
      }

      .data-\[swipe\=cancel\]\:translate-x-0[data-swipe="cancel"] {
        --tw-translate-x: 0px;
        transform: translate(var(--tw-translate-x), var(--tw-translate-y))
          rotate(var(--tw-rotate)) skewX(var(--tw-skew-x))
          skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x))
          scaleY(var(--tw-scale-y));
      }

      .data-\[swipe\=end\]\:translate-x-\[var\(--radix-toast-swipe-end-x\)\][data-swipe="end"] {
        --tw-translate-x: var(--radix-toast-swipe-end-x);
        transform: translate(var(--tw-translate-x), var(--tw-translate-y))
          rotate(var(--tw-rotate)) skewX(var(--tw-skew-x))
          skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x))
          scaleY(var(--tw-scale-y));
      }

      .data-\[swipe\=move\]\:translate-x-\[var\(--radix-toast-swipe-move-x\)\][data-swipe="move"] {
        --tw-translate-x: var(--radix-toast-swipe-move-x);
        transform: translate(var(--tw-translate-x), var(--tw-translate-y))
          rotate(var(--tw-rotate)) skewX(var(--tw-skew-x))
          skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x))
          scaleY(var(--tw-scale-y));
      }

      @keyframes accordion-up {
        from {
          height: var(--radix-accordion-content-height);
        }

        to {
          height: 0;
        }
      }

      .data-\[state\=closed\]\:animate-accordion-up[data-state="closed"] {
        animation: accordion-up 0.2s ease-out;
      }

      @keyframes accordion-down {
        from {
          height: 0;
        }

        to {
          height: var(--radix-accordion-content-height);
        }
      }

      .data-\[state\=open\]\:animate-accordion-down[data-state="open"] {
        animation: accordion-down 0.2s ease-out;
      }

      .data-\[panel-group-direction\=vertical\]\:flex-col[data-panel-group-direction="vertical"] {
        flex-direction: column;
      }

      .data-\[active\=true\]\:bg-sidebar-accent[data-active="true"] {
        background-color: hsl(var(--sidebar-accent));
      }

      .data-\[active\]\:bg-accent\/50[data-active] {
        background-color: hsl(var(--accent) / 0.5);
      }

      .data-\[selected\=\'true\'\]\:bg-accent[data-selected="true"] {
        background-color: hsl(var(--accent));
      }

      .data-\[state\=active\]\:bg-background[data-state="active"] {
        background-color: hsl(var(--background));
      }

      .data-\[state\=checked\]\:bg-primary[data-state="checked"] {
        background-color: hsl(var(--primary));
      }

      .data-\[state\=on\]\:bg-accent[data-state="on"] {
        background-color: hsl(var(--accent));
      }

      .data-\[state\=open\]\:bg-accent[data-state="open"] {
        background-color: hsl(var(--accent));
      }

      .data-\[state\=open\]\:bg-accent\/50[data-state="open"] {
        background-color: hsl(var(--accent) / 0.5);
      }

      .data-\[state\=open\]\:bg-secondary[data-state="open"] {
        background-color: hsl(var(--secondary));
      }

      .data-\[state\=selected\]\:bg-muted[data-state="selected"] {
        background-color: hsl(var(--muted));
      }

      .data-\[state\=unchecked\]\:bg-input[data-state="unchecked"] {
        background-color: hsl(var(--input));
      }

      .data-\[active\=true\]\:font-medium[data-active="true"] {
        font-weight: 500;
      }

      .data-\[active\=true\]\:text-sidebar-accent-foreground[data-active="true"] {
        color: hsl(var(--sidebar-accent-foreground));
      }

      .data-\[selected\=true\]\:text-accent-foreground[data-selected="true"] {
        color: hsl(var(--accent-foreground));
      }

      .data-\[state\=active\]\:text-foreground[data-state="active"] {
        color: hsl(var(--foreground));
      }

      .data-\[state\=checked\]\:text-primary-foreground[data-state="checked"] {
        color: hsl(var(--primary-foreground));
      }

      .data-\[state\=on\]\:text-accent-foreground[data-state="on"] {
        color: hsl(var(--accent-foreground));
      }

      .data-\[state\=open\]\:text-accent-foreground[data-state="open"] {
        color: hsl(var(--accent-foreground));
      }

      .data-\[state\=open\]\:text-muted-foreground[data-state="open"] {
        color: hsl(var(--muted-foreground));
      }

      .data-\[disabled\=true\]\:opacity-50[data-disabled="true"] {
        opacity: 0.5;
      }

      .data-\[disabled\]\:opacity-50[data-disabled] {
        opacity: 0.5;
      }

      .data-\[state\=open\]\:opacity-100[data-state="open"] {
        opacity: 1;
      }

      .data-\[state\=active\]\:shadow-sm[data-state="active"] {
        --tw-shadow: 0 1px 2px 0 rgb(0 0 0 / 0.05);
        --tw-shadow-colored: 0 1px 2px 0 var(--tw-shadow-color);
        box-shadow:
          var(--tw-ring-offset-shadow, 0 0 #0000),
          var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);
      }

      .data-\[swipe\=move\]\:transition-none[data-swipe="move"] {
        transition-property: none;
      }

      .data-\[state\=closed\]\:duration-300[data-state="closed"] {
        transition-duration: 300ms;
      }

      .data-\[state\=open\]\:duration-500[data-state="open"] {
        transition-duration: 500ms;
      }

      .data-\[motion\^\=from-\]\:animate-in[data-motion^="from-"] {
        animation-name: enter;
        animation-duration: 150ms;
        --tw-enter-opacity: initial;
        --tw-enter-scale: initial;
        --tw-enter-rotate: initial;
        --tw-enter-translate-x: initial;
        --tw-enter-translate-y: initial;
      }

      .data-\[state\=open\]\:animate-in[data-state="open"] {
        animation-name: enter;
        animation-duration: 150ms;
        --tw-enter-opacity: initial;
        --tw-enter-scale: initial;
        --tw-enter-rotate: initial;
        --tw-enter-translate-x: initial;
        --tw-enter-translate-y: initial;
      }

      .data-\[state\=visible\]\:animate-in[data-state="visible"] {
        animation-name: enter;
        animation-duration: 150ms;
        --tw-enter-opacity: initial;
        --tw-enter-scale: initial;
        --tw-enter-rotate: initial;
        --tw-enter-translate-x: initial;
        --tw-enter-translate-y: initial;
      }

      .data-\[motion\^\=to-\]\:animate-out[data-motion^="to-"] {
        animation-name: exit;
        animation-duration: 150ms;
        --tw-exit-opacity: initial;
        --tw-exit-scale: initial;
        --tw-exit-rotate: initial;
        --tw-exit-translate-x: initial;
        --tw-exit-translate-y: initial;
      }

      .data-\[state\=closed\]\:animate-out[data-state="closed"] {
        animation-name: exit;
        animation-duration: 150ms;
        --tw-exit-opacity: initial;
        --tw-exit-scale: initial;
        --tw-exit-rotate: initial;
        --tw-exit-translate-x: initial;
        --tw-exit-translate-y: initial;
      }

      .data-\[state\=hidden\]\:animate-out[data-state="hidden"] {
        animation-name: exit;
        animation-duration: 150ms;
        --tw-exit-opacity: initial;
        --tw-exit-scale: initial;
        --tw-exit-rotate: initial;
        --tw-exit-translate-x: initial;
        --tw-exit-translate-y: initial;
      }

      .data-\[swipe\=end\]\:animate-out[data-swipe="end"] {
        animation-name: exit;
        animation-duration: 150ms;
        --tw-exit-opacity: initial;
        --tw-exit-scale: initial;
        --tw-exit-rotate: initial;
        --tw-exit-translate-x: initial;
        --tw-exit-translate-y: initial;
      }

      .data-\[motion\^\=from-\]\:fade-in[data-motion^="from-"] {
        --tw-enter-opacity: 0;
      }

      .data-\[motion\^\=to-\]\:fade-out[data-motion^="to-"] {
        --tw-exit-opacity: 0;
      }

      .data-\[state\=closed\]\:fade-out-0[data-state="closed"] {
        --tw-exit-opacity: 0;
      }

      .data-\[state\=closed\]\:fade-out-80[data-state="closed"] {
        --tw-exit-opacity: 0.8;
      }

      .data-\[state\=hidden\]\:fade-out[data-state="hidden"] {
        --tw-exit-opacity: 0;
      }

      .data-\[state\=open\]\:fade-in-0[data-state="open"] {
        --tw-enter-opacity: 0;
      }

      .data-\[state\=visible\]\:fade-in[data-state="visible"] {
        --tw-enter-opacity: 0;
      }

      .data-\[state\=closed\]\:zoom-out-95[data-state="closed"] {
        --tw-exit-scale: 0.95;
      }

      .data-\[state\=open\]\:zoom-in-90[data-state="open"] {
        --tw-enter-scale: 0.9;
      }

      .data-\[state\=open\]\:zoom-in-95[data-state="open"] {
        --tw-enter-scale: 0.95;
      }

      .data-\[motion\=from-end\]\:slide-in-from-right-52[data-motion="from-end"] {
        --tw-enter-translate-x: 13rem;
      }

      .data-\[motion\=from-start\]\:slide-in-from-left-52[data-motion="from-start"] {
        --tw-enter-translate-x: -13rem;
      }

      .data-\[motion\=to-end\]\:slide-out-to-right-52[data-motion="to-end"] {
        --tw-exit-translate-x: 13rem;
      }

      .data-\[motion\=to-start\]\:slide-out-to-left-52[data-motion="to-start"] {
        --tw-exit-translate-x: -13rem;
      }

      .data-\[side\=bottom\]\:slide-in-from-top-2[data-side="bottom"] {
        --tw-enter-translate-y: -0.5rem;
      }

      .data-\[side\=left\]\:slide-in-from-right-2[data-side="left"] {
        --tw-enter-translate-x: 0.5rem;
      }

      .data-\[side\=right\]\:slide-in-from-left-2[data-side="right"] {
        --tw-enter-translate-x: -0.5rem;
      }

      .data-\[side\=top\]\:slide-in-from-bottom-2[data-side="top"] {
        --tw-enter-translate-y: 0.5rem;
      }

      .data-\[state\=closed\]\:slide-out-to-bottom[data-state="closed"] {
        --tw-exit-translate-y: 100%;
      }

      .data-\[state\=closed\]\:slide-out-to-left[data-state="closed"] {
        --tw-exit-translate-x: -100%;
      }

      .data-\[state\=closed\]\:slide-out-to-left-1\/2[data-state="closed"] {
        --tw-exit-translate-x: -50%;
      }

      .data-\[state\=closed\]\:slide-out-to-right[data-state="closed"] {
        --tw-exit-translate-x: 100%;
      }

      .data-\[state\=closed\]\:slide-out-to-right-full[data-state="closed"] {
        --tw-exit-translate-x: 100%;
      }

      .data-\[state\=closed\]\:slide-out-to-top[data-state="closed"] {
        --tw-exit-translate-y: -100%;
      }

      .data-\[state\=closed\]\:slide-out-to-top-\[48\%\][data-state="closed"] {
        --tw-exit-translate-y: -48%;
      }

      .data-\[state\=open\]\:slide-in-from-bottom[data-state="open"] {
        --tw-enter-translate-y: 100%;
      }

      .data-\[state\=open\]\:slide-in-from-left[data-state="open"] {
        --tw-enter-translate-x: -100%;
      }

      .data-\[state\=open\]\:slide-in-from-left-1\/2[data-state="open"] {
        --tw-enter-translate-x: -50%;
      }

      .data-\[state\=open\]\:slide-in-from-right[data-state="open"] {
        --tw-enter-translate-x: 100%;
      }

      .data-\[state\=open\]\:slide-in-from-top[data-state="open"] {
        --tw-enter-translate-y: -100%;
      }

      .data-\[state\=open\]\:slide-in-from-top-\[48\%\][data-state="open"] {
        --tw-enter-translate-y: -48%;
      }

      .data-\[state\=open\]\:slide-in-from-top-full[data-state="open"] {
        --tw-enter-translate-y: -100%;
      }

      .data-\[state\=closed\]\:duration-300[data-state="closed"] {
        animation-duration: 300ms;
      }

      .data-\[state\=open\]\:duration-500[data-state="open"] {
        animation-duration: 500ms;
      }

      .data-\[panel-group-direction\=vertical\]\:after\:left-0[data-panel-group-direction="vertical"]::after {
        content: var(--tw-content);
        left: 0px;
      }

      .data-\[panel-group-direction\=vertical\]\:after\:h-1[data-panel-group-direction="vertical"]::after {
        content: var(--tw-content);
        height: 0.25rem;
      }

      .data-\[panel-group-direction\=vertical\]\:after\:w-full[data-panel-group-direction="vertical"]::after {
        content: var(--tw-content);
        width: 100%;
      }

      .data-\[panel-group-direction\=vertical\]\:after\:-translate-y-1\/2[data-panel-group-direction="vertical"]::after {
        content: var(--tw-content);
        --tw-translate-y: -50%;
        transform: translate(var(--tw-translate-x), var(--tw-translate-y))
          rotate(var(--tw-rotate)) skewX(var(--tw-skew-x))
          skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x))
          scaleY(var(--tw-scale-y));
      }

      .data-\[panel-group-direction\=vertical\]\:after\:translate-x-0[data-panel-group-direction="vertical"]::after {
        content: var(--tw-content);
        --tw-translate-x: 0px;
        transform: translate(var(--tw-translate-x), var(--tw-translate-y))
          rotate(var(--tw-rotate)) skewX(var(--tw-skew-x))
          skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x))
          scaleY(var(--tw-scale-y));
      }

      .data-\[state\=open\]\:hover\:bg-sidebar-accent:hover[data-state="open"] {
        background-color: hsl(var(--sidebar-accent));
      }

      .data-\[state\=open\]\:hover\:text-sidebar-accent-foreground:hover[data-state="open"] {
        color: hsl(var(--sidebar-accent-foreground));
      }

      .group[data-collapsible="offcanvas"]
        .group-data-\[collapsible\=offcanvas\]\:left-\[calc\(var\(--sidebar-width\)\*-1\)\] {
        left: calc(var(--sidebar-width) * -1);
      }

      .group[data-collapsible="offcanvas"]
        .group-data-\[collapsible\=offcanvas\]\:right-\[calc\(var\(--sidebar-width\)\*-1\)\] {
        right: calc(var(--sidebar-width) * -1);
      }

      .group[data-side="left"] .group-data-\[side\=left\]\:-right-4 {
        right: -1rem;
      }

      .group[data-side="right"] .group-data-\[side\=right\]\:left-0 {
        left: 0px;
      }

      .group[data-collapsible="icon"] .group-data-\[collapsible\=icon\]\:-mt-8 {
        margin-top: -2rem;
      }

      .group[data-collapsible="icon"]
        .group-data-\[collapsible\=icon\]\:hidden {
        display: none;
      }

      .group[data-collapsible="icon"]
        .group-data-\[collapsible\=icon\]\:\!size-8 {
        width: 2rem !important;
        height: 2rem !important;
      }

      .group[data-collapsible="icon"]
        .group-data-\[collapsible\=icon\]\:w-\[--sidebar-width-icon\] {
        width: var(--sidebar-width-icon);
      }

      .group[data-collapsible="icon"]
        .group-data-\[collapsible\=icon\]\:w-\[calc\(var\(--sidebar-width-icon\)_\+_theme\(spacing\.4\)\)\] {
        width: calc(var(--sidebar-width-icon) + 1rem);
      }

      .group[data-collapsible="icon"]
        .group-data-\[collapsible\=icon\]\:w-\[calc\(var\(--sidebar-width-icon\)_\+_theme\(spacing\.4\)_\+2px\)\] {
        width: calc(var(--sidebar-width-icon) + 1rem + 2px);
      }

      .group[data-collapsible="offcanvas"]
        .group-data-\[collapsible\=offcanvas\]\:w-0 {
        width: 0px;
      }

      .group[data-collapsible="offcanvas"]
        .group-data-\[collapsible\=offcanvas\]\:translate-x-0 {
        --tw-translate-x: 0px;
        transform: translate(var(--tw-translate-x), var(--tw-translate-y))
          rotate(var(--tw-rotate)) skewX(var(--tw-skew-x))
          skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x))
          scaleY(var(--tw-scale-y));
      }

      .group[data-side="right"] .group-data-\[side\=right\]\:rotate-180 {
        --tw-rotate: 180deg;
        transform: translate(var(--tw-translate-x), var(--tw-translate-y))
          rotate(var(--tw-rotate)) skewX(var(--tw-skew-x))
          skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x))
          scaleY(var(--tw-scale-y));
      }

      .group[data-state="open"] .group-data-\[state\=open\]\:rotate-180 {
        --tw-rotate: 180deg;
        transform: translate(var(--tw-translate-x), var(--tw-translate-y))
          rotate(var(--tw-rotate)) skewX(var(--tw-skew-x))
          skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x))
          scaleY(var(--tw-scale-y));
      }

      .group[data-collapsible="icon"]
        .group-data-\[collapsible\=icon\]\:overflow-hidden {
        overflow: hidden;
      }

      .group[data-variant="floating"]
        .group-data-\[variant\=floating\]\:rounded-lg {
        border-radius: var(--radius);
      }

      .group[data-variant="floating"]
        .group-data-\[variant\=floating\]\:border {
        border-width: 1px;
      }

      .group[data-side="left"] .group-data-\[side\=left\]\:border-r {
        border-right-width: 1px;
      }

      .group[data-side="right"] .group-data-\[side\=right\]\:border-l {
        border-left-width: 1px;
      }

      .group[data-variant="floating"]
        .group-data-\[variant\=floating\]\:border-sidebar-border {
        border-color: hsl(var(--sidebar-border));
      }

      .group[data-collapsible="icon"] .group-data-\[collapsible\=icon\]\:\!p-0 {
        padding: 0px !important;
      }

      .group[data-collapsible="icon"] .group-data-\[collapsible\=icon\]\:\!p-2 {
        padding: 0.5rem !important;
      }

      .group[data-collapsible="icon"]
        .group-data-\[collapsible\=icon\]\:opacity-0 {
        opacity: 0;
      }

      .group[data-variant="floating"]
        .group-data-\[variant\=floating\]\:shadow {
        --tw-shadow:
          0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1);
        --tw-shadow-colored:
          0 1px 3px 0 var(--tw-shadow-color),
          0 1px 2px -1px var(--tw-shadow-color);
        box-shadow:
          var(--tw-ring-offset-shadow, 0 0 #0000),
          var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);
      }

      .group[data-collapsible="offcanvas"]
        .group-data-\[collapsible\=offcanvas\]\:after\:left-full::after {
        content: var(--tw-content);
        left: 100%;
      }

      .group[data-collapsible="offcanvas"]
        .group-data-\[collapsible\=offcanvas\]\:hover\:bg-sidebar:hover {
        background-color: hsl(var(--sidebar-background));
      }

      .peer\/menu-button[data-size="default"]
        ~ .peer-data-\[size\=default\]\/menu-button\:top-1\.5 {
        top: 0.375rem;
      }

      .peer\/menu-button[data-size="lg"]
        ~ .peer-data-\[size\=lg\]\/menu-button\:top-2\.5 {
        top: 0.625rem;
      }

      .peer\/menu-button[data-size="sm"]
        ~ .peer-data-\[size\=sm\]\/menu-button\:top-1 {
        top: 0.25rem;
      }

      .peer[data-variant="inset"]
        ~ .peer-data-\[variant\=inset\]\:min-h-\[calc\(100svh-theme\(spacing\.4\)\)\] {
        min-height: calc(100svh - 1rem);
      }

      .peer\/menu-button[data-active="true"]
        ~ .peer-data-\[active\=true\]\/menu-button\:text-sidebar-accent-foreground {
        color: hsl(var(--sidebar-accent-foreground));
      }

      .dark\:border-destructive:is(.dark *) {
        border-color: hsl(var(--destructive));
      }

      @media (min-width: 640px) {
        .sm\:bottom-0 {
          bottom: 0px;
        }

        .sm\:right-0 {
          right: 0px;
        }

        .sm\:top-auto {
          top: auto;
        }

        .sm\:mt-0 {
          margin-top: 0px;
        }

        .sm\:inline {
          display: inline;
        }

        .sm\:flex {
          display: flex;
        }

        .sm\:max-w-sm {
          max-width: 24rem;
        }

        .sm\:flex-row {
          flex-direction: row;
        }

        .sm\:flex-col {
          flex-direction: column;
        }

        .sm\:justify-end {
          justify-content: flex-end;
        }

        .sm\:gap-2\.5 {
          gap: 0.625rem;
        }

        .sm\:space-x-2 > :not([hidden]) ~ :not([hidden]) {
          --tw-space-x-reverse: 0;
          margin-right: calc(0.5rem * var(--tw-space-x-reverse));
          margin-left: calc(0.5rem * calc(1 - var(--tw-space-x-reverse)));
        }

        .sm\:space-x-4 > :not([hidden]) ~ :not([hidden]) {
          --tw-space-x-reverse: 0;
          margin-right: calc(1rem * var(--tw-space-x-reverse));
          margin-left: calc(1rem * calc(1 - var(--tw-space-x-reverse)));
        }

        .sm\:space-y-0 > :not([hidden]) ~ :not([hidden]) {
          --tw-space-y-reverse: 0;
          margin-top: calc(0px * calc(1 - var(--tw-space-y-reverse)));
          margin-bottom: calc(0px * var(--tw-space-y-reverse));
        }

        .sm\:rounded-lg {
          border-radius: var(--radius);
        }

        .sm\:text-left {
          text-align: left;
        }

        .sm\:text-3xl {
          font-size: 1.875rem;
          line-height: 2.25rem;
        }

        .data-\[state\=open\]\:sm\:slide-in-from-bottom-full[data-state="open"] {
          --tw-enter-translate-y: 100%;
        }
      }

      @media (min-width: 768px) {
        .md\:absolute {
          position: absolute;
        }

        .md\:block {
          display: block;
        }

        .md\:flex {
          display: flex;
        }

        .md\:w-\[var\(--radix-navigation-menu-viewport-width\)\] {
          width: var(--radix-navigation-menu-viewport-width);
        }

        .md\:w-auto {
          width: auto;
        }

        .md\:max-w-\[420px\] {
          max-width: 420px;
        }

        .md\:text-sm {
          font-size: 0.875rem;
          line-height: 1.25rem;
        }

        .md\:opacity-0 {
          opacity: 0;
        }

        .after\:md\:hidden::after {
          content: var(--tw-content);
          display: none;
        }

        .peer[data-variant="inset"] ~ .md\:peer-data-\[variant\=inset\]\:m-2 {
          margin: 0.5rem;
        }

        .peer[data-state="collapsed"][data-variant="inset"]
          ~ .md\:peer-data-\[state\=collapsed\]\:peer-data-\[variant\=inset\]\:ml-2 {
          margin-left: 0.5rem;
        }

        .peer[data-variant="inset"] ~ .md\:peer-data-\[variant\=inset\]\:ml-0 {
          margin-left: 0px;
        }

        .peer[data-variant="inset"]
          ~ .md\:peer-data-\[variant\=inset\]\:rounded-xl {
          border-radius: 0.75rem;
        }

        .peer[data-variant="inset"]
          ~ .md\:peer-data-\[variant\=inset\]\:shadow {
          --tw-shadow:
            0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1);
          --tw-shadow-colored:
            0 1px 3px 0 var(--tw-shadow-color),
            0 1px 2px -1px var(--tw-shadow-color);
          box-shadow:
            var(--tw-ring-offset-shadow, 0 0 #0000),
            var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);
        }
      }

      .\[\&\:has\(\[aria-selected\]\)\]\:bg-accent:has([aria-selected]) {
        background-color: hsl(var(--accent));
      }

      .first\:\[\&\:has\(\[aria-selected\]\)\]\:rounded-l-md:has(
          [aria-selected]
        ):first-child {
        border-top-left-radius: calc(var(--radius) - 2px);
        border-bottom-left-radius: calc(var(--radius) - 2px);
      }

      .last\:\[\&\:has\(\[aria-selected\]\)\]\:rounded-r-md:has(
          [aria-selected]
        ):last-child {
        border-top-right-radius: calc(var(--radius) - 2px);
        border-bottom-right-radius: calc(var(--radius) - 2px);
      }

      .\[\&\:has\(\[aria-selected\]\.day-outside\)\]\:bg-accent\/50:has(
          [aria-selected].day-outside
        ) {
        background-color: hsl(var(--accent) / 0.5);
      }

      .\[\&\:has\(\[aria-selected\]\.day-range-end\)\]\:rounded-r-md:has(
          [aria-selected].day-range-end
        ) {
        border-top-right-radius: calc(var(--radius) - 2px);
        border-bottom-right-radius: calc(var(--radius) - 2px);
      }

      .\[\&\:has\(\[role\=checkbox\]\)\]\:pr-0:has([role="checkbox"]) {
        padding-right: 0px;
      }

      .\[\&\>button\]\:hidden > button {
        display: none;
      }

      .\[\&\>span\:last-child\]\:truncate > span:last-child {
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
      }

      .\[\&\>span\]\:line-clamp-1 > span {
        overflow: hidden;
        display: -webkit-box;
        -webkit-box-orient: vertical;
        -webkit-line-clamp: 1;
      }

      .\[\&\>svg\+div\]\:translate-y-\[-3px\] > svg + div {
        --tw-translate-y: -3px;
        transform: translate(var(--tw-translate-x), var(--tw-translate-y))
          rotate(var(--tw-rotate)) skewX(var(--tw-skew-x))
          skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x))
          scaleY(var(--tw-scale-y));
      }

      .\[\&\>svg\]\:absolute > svg {
        position: absolute;
      }

      .\[\&\>svg\]\:left-4 > svg {
        left: 1rem;
      }

      .\[\&\>svg\]\:top-4 > svg {
        top: 1rem;
      }

      .\[\&\>svg\]\:size-3\.5 > svg {
        width: 0.875rem;
        height: 0.875rem;
      }

      .\[\&\>svg\]\:size-4 > svg {
        width: 1rem;
        height: 1rem;
      }

      .\[\&\>svg\]\:h-2\.5 > svg {
        height: 0.625rem;
      }

      .\[\&\>svg\]\:h-3 > svg {
        height: 0.75rem;
      }

      .\[\&\>svg\]\:w-2\.5 > svg {
        width: 0.625rem;
      }

      .\[\&\>svg\]\:w-3 > svg {
        width: 0.75rem;
      }

      .\[\&\>svg\]\:shrink-0 > svg {
        flex-shrink: 0;
      }

      .\[\&\>svg\]\:text-destructive > svg {
        color: hsl(var(--destructive));
      }

      .\[\&\>svg\]\:text-foreground > svg {
        color: hsl(var(--foreground));
      }

      .\[\&\>svg\]\:text-muted-foreground > svg {
        color: hsl(var(--muted-foreground));
      }

      .\[\&\>svg\]\:text-sidebar-accent-foreground > svg {
        color: hsl(var(--sidebar-accent-foreground));
      }

      .\[\&\>svg\~\*\]\:pl-7 > svg ~ * {
        padding-left: 1.75rem;
      }

      .\[\&\>tr\]\:last\:border-b-0:last-child > tr {
        border-bottom-width: 0px;
      }

      .\[\&\[data-panel-group-direction\=vertical\]\>div\]\:rotate-90[data-panel-group-direction="vertical"]
        > div {
        --tw-rotate: 90deg;
        transform: translate(var(--tw-translate-x), var(--tw-translate-y))
          rotate(var(--tw-rotate)) skewX(var(--tw-skew-x))
          skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x))
          scaleY(var(--tw-scale-y));
      }

      .\[\&\[data-state\=open\]\>svg\]\:rotate-180[data-state="open"] > svg {
        --tw-rotate: 180deg;
        transform: translate(var(--tw-translate-x), var(--tw-translate-y))
          rotate(var(--tw-rotate)) skewX(var(--tw-skew-x))
          skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x))
          scaleY(var(--tw-scale-y));
      }

      .\[\&_\.recharts-cartesian-axis-tick_text\]\:fill-muted-foreground
        .recharts-cartesian-axis-tick
        text {
        fill: hsl(var(--muted-foreground));
      }

      .\[\&_\.recharts-cartesian-grid_line\[stroke\=\'\#ccc\'\]\]\:stroke-border\/50
        .recharts-cartesian-grid
        line[stroke="#ccc"] {
        stroke: hsl(var(--border) / 0.5);
      }

      .\[\&_\.recharts-curve\.recharts-tooltip-cursor\]\:stroke-border
        .recharts-curve.recharts-tooltip-cursor {
        stroke: hsl(var(--border));
      }

      .\[\&_\.recharts-dot\[stroke\=\'\#fff\'\]\]\:stroke-transparent
        .recharts-dot[stroke="#fff"] {
        stroke: transparent;
      }

      .\[\&_\.recharts-layer\]\:outline-none .recharts-layer {
        outline: 2px solid transparent;
        outline-offset: 2px;
      }

      .\[\&_\.recharts-polar-grid_\[stroke\=\'\#ccc\'\]\]\:stroke-border
        .recharts-polar-grid
        [stroke="#ccc"] {
        stroke: hsl(var(--border));
      }

      .\[\&_\.recharts-radial-bar-background-sector\]\:fill-muted
        .recharts-radial-bar-background-sector {
        fill: hsl(var(--muted));
      }

      .\[\&_\.recharts-rectangle\.recharts-tooltip-cursor\]\:fill-muted
        .recharts-rectangle.recharts-tooltip-cursor {
        fill: hsl(var(--muted));
      }

      .\[\&_\.recharts-reference-line_\[stroke\=\'\#ccc\'\]\]\:stroke-border
        .recharts-reference-line
        [stroke="#ccc"] {
        stroke: hsl(var(--border));
      }

      .\[\&_\.recharts-sector\[stroke\=\'\#fff\'\]\]\:stroke-transparent
        .recharts-sector[stroke="#fff"] {
        stroke: transparent;
      }

      .\[\&_\.recharts-sector\]\:outline-none .recharts-sector {
        outline: 2px solid transparent;
        outline-offset: 2px;
      }

      .\[\&_\.recharts-surface\]\:outline-none .recharts-surface {
        outline: 2px solid transparent;
        outline-offset: 2px;
      }

      .\[\&_\[cmdk-group-heading\]\]\:px-2 [cmdk-group-heading] {
        padding-left: 0.5rem;
        padding-right: 0.5rem;
      }

      .\[\&_\[cmdk-group-heading\]\]\:py-1\.5 [cmdk-group-heading] {
        padding-top: 0.375rem;
        padding-bottom: 0.375rem;
      }

      .\[\&_\[cmdk-group-heading\]\]\:text-xs [cmdk-group-heading] {
        font-size: 0.75rem;
        line-height: 1rem;
      }

      .\[\&_\[cmdk-group-heading\]\]\:font-medium [cmdk-group-heading] {
        font-weight: 500;
      }

      .\[\&_\[cmdk-group-heading\]\]\:text-muted-foreground
        [cmdk-group-heading] {
        color: hsl(var(--muted-foreground));
      }

      .\[\&_\[cmdk-group\]\:not\(\[hidden\]\)_\~\[cmdk-group\]\]\:pt-0
        [cmdk-group]:not([hidden])
        ~ [cmdk-group] {
        padding-top: 0px;
      }

      .\[\&_\[cmdk-group\]\]\:px-2 [cmdk-group] {
        padding-left: 0.5rem;
        padding-right: 0.5rem;
      }

      .\[\&_\[cmdk-input-wrapper\]_svg\]\:h-5 [cmdk-input-wrapper] svg {
        height: 1.25rem;
      }

      .\[\&_\[cmdk-input-wrapper\]_svg\]\:w-5 [cmdk-input-wrapper] svg {
        width: 1.25rem;
      }

      .\[\&_\[cmdk-input\]\]\:h-12 [cmdk-input] {
        height: 3rem;
      }

      .\[\&_\[cmdk-item\]\]\:px-2 [cmdk-item] {
        padding-left: 0.5rem;
        padding-right: 0.5rem;
      }

      .\[\&_\[cmdk-item\]\]\:py-3 [cmdk-item] {
        padding-top: 0.75rem;
        padding-bottom: 0.75rem;
      }

      .\[\&_\[cmdk-item\]_svg\]\:h-5 [cmdk-item] svg {
        height: 1.25rem;
      }

      .\[\&_\[cmdk-item\]_svg\]\:w-5 [cmdk-item] svg {
        width: 1.25rem;
      }

      .\[\&_p\]\:leading-relaxed p {
        line-height: 1.625;
      }

      .\[\&_svg\]\:pointer-events-none svg {
        pointer-events: none;
      }

      .\[\&_svg\]\:size-4 svg {
        width: 1rem;
        height: 1rem;
      }

      .\[\&_svg\]\:shrink-0 svg {
        flex-shrink: 0;
      }

      .\[\&_tr\:last-child\]\:border-0 tr:last-child {
        border-width: 0px;
      }

      .\[\&_tr\]\:border-b tr {
        border-bottom-width: 1px;
      }

      [data-side="left"][data-collapsible="offcanvas"]
        .\[\[data-side\=left\]\[data-collapsible\=offcanvas\]_\&\]\:-right-2 {
        right: -0.5rem;
      }

      [data-side="left"][data-state="collapsed"]
        .\[\[data-side\=left\]\[data-state\=collapsed\]_\&\]\:cursor-e-resize {
        cursor: e-resize;
      }

      [data-side="left"] .\[\[data-side\=left\]_\&\]\:cursor-w-resize {
        cursor: w-resize;
      }

      [data-side="right"][data-collapsible="offcanvas"]
        .\[\[data-side\=right\]\[data-collapsible\=offcanvas\]_\&\]\:-left-2 {
        left: -0.5rem;
      }

      [data-side="right"][data-state="collapsed"]
        .\[\[data-side\=right\]\[data-state\=collapsed\]_\&\]\:cursor-w-resize {
        cursor: w-resize;
      }

      [data-side="right"] .\[\[data-side\=right\]_\&\]\:cursor-e-resize {
        cursor: e-resize;
      }
    </style>
  </head>

  <body>
    <div id="root"></div>

    <!-- Dynamic Data Loading for File Protocol -->
    <script>
      // Initialize global storage for custom pages
      window.CUSTOM_PAGES = {};

      // Define registerPage globally so data scripts can use it immediately
      window.registerPage = function (data) {
        // Ensure ID exists
        if (!data.id) {
          console.error("Page registered without ID", data);
          return;
        }
        window.CUSTOM_PAGES[data.id] = data;
        console.log("Registered custom page:", data.id);
      };
    </script>
    <script src="js/manifest.js"></script>
    <script>
      // Load all data files defined in the manifest
      if (window.DATA_MANIFEST) {
        window.DATA_MANIFEST.forEach(function (file) {
          document.write('<script src="data/' + file + '"><\/script>');
        });
      }
    </script>
  </body>
</html>
